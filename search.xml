<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基于MT9V032的障碍识别功能]]></title>
    <url>%2Fposts%2F31100%2F</url>
    <content type="text"><![CDATA[前言 今天在翻以前的一些云存储文件，看到了之前搞过的一个障碍识别的视频，感觉还挺有意思的，就想着写一下，把整个代码流程搞顺点，那么先简单的介绍下摄像头和芯片把 摄像头：本质是一种半导体芯片，其表面包含有几十万到几百万的光电二极管。光电二极管受到光照射时，就会产生电荷 目前我们使用的是CMOS摄像头 网上找的图，先将就着看 一个摄像头硬件上包括五个部分：，镜头(Lens) ，对焦马达，红外滤光片(IR cutfilter)，图像传感器(Image Sensor) 和挠性印刷电路板(FPCB)。 镜头(Lens)它的主要作用就是收集外部的光线，将光线汇聚到图像传感器上 ，传递为光信号，镜头的好坏决定了你摄像头图像的清晰度与成像质量 对焦马达这个咱不是太懂，到时候学习了再介绍把 红外滤波片红外滤波片的主要作用是滤除不能被人眼观察不到的紫外光和红外光，是位于镜头和图像传感器之间的部件因为目前大部分的图像传感器都是基于RGB三原色成像的，而最原始的RAW文件数据每个像素点，只有三种颜色要么是红，要么是蓝，要么是绿(rgb三原色)，最后经过图像传感器处理之后得到我们所看到的彩色图片，但是图像传感器并不能区分与过滤紫外光和红外光，在读取镜头传递过来的光信号时，就会导致读取的数据不准确，处理之后的图像与真实颜色会有很大差距，图像色彩的还原度就会变得很差，因此需要红外滤波片来解决这个问题 图像传感器摄像头的核心部件，你可以理解为单片机的MCU 将镜头传递的光信号处理，转换为电信号，再通过内部的DA转换为数字信号，图像的像素，对焦成像，等等功能都取决于它，传感器的每个pixel只能感光R光或者B光或者G光，因此每个像素此时存贮的是单色的，我们称之为RAW DATA数据 我们目前使用都是CMOS图像传感器 其性能远远优于线性CCD摄像头 印刷电路板(FPCB)PCB负责将摄像头的其他组件与主处理器连接起来，完成整个摄像头功能的连接与实现，并将图像传单器得到的信号通过数据总线传输出去，完成图像的数据读取与显示功能 关于CMOS摄像头硬件原理与数据处理这里我们就不说了，比较复杂，有想去的可自行百度， 之后还是先看下视频效果把，代码和讲解之后有时间会更新 因为使用的MT9V032是一款纯裸摄像头，图像读取,二值化等等都需要自己去写底层，可能讲起来有点难度，最近实在是没时间去写了，之后有时间会更新，或者加入智能车实验室啊，可以学到更多东西呀]]></content>
      <categories>
        <category>NXP智能车</category>
      </categories>
      <tags>
        <tag>NXP智能车</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【c语言】宏]]></title>
    <url>%2Fposts%2F62824%2F</url>
    <content type="text"><![CDATA[c语言宏的简单认识，列举了C语言目前已有的预处理分类 什么是宏？宏是学习任何语言所不可缺少的，优秀的宏定义可以使得代码变得很简洁且高效，有效地提高编程效率。 宏是一种预处理指令，它提供了一种机制，可以用来替换源代码中的字符串，解释器或编译器在遇到宏时会自动进行这一模式替换 C语言有简单的宏系统，由编译器或汇编器的预处理器实现。C的宏预处理器的工作只是简单的文本搜索和替换， C语言的宏非常简单，我们只需要做好宏定义，其余交给编译器预处理即可 C语言的宏(预处理功能)有以下几类： 宏定义 包含头文件的宏 条件编译宏 预定义宏 宏定义c程序提供的预处理功能之一。包括带参数的宏定义和不带参数的宏定义。具体是指用一个指定的标志符来进行简单的字符串替换或者进行阐述替换。形式为： 1#define 标志符[（参数表）] 字符串 其中“#”表示这是一条预处理命令(在 C 语言中凡是以“#”开头的均为预处理命令)“define”为宏定义命令,“标识符”为所定义的宏名, “字符串”可以是常数、表达式、格式串等。符号常量的定义就是一种无参宏定义 常见使用 1234567891011121314//宏定义#define SIZE 1000//取消宏#undef SIZE//普通宏#define PI 3.1415926//带参数的宏#define max(a,b) ((a)&gt;(b)? (a),(b)) 其实宏定义就是一个简单的字符串替换，将前面的字符串替换成后面的字符串。 当然要注意，#define宏定义的作用仅仅是替换，它只是一个简单的替换,比如下方代码： 1234#define m(a,b) a*3+b*4c = m(5+6,2+4)//C的结果等于41 这里的宏定义仅仅是将a换为5+6 而不是11 将b换位2+4 而不是6因此顺序应该是 5+63+2+44 = 41 如果想要实际的预期结果 则需要 1234#define m(a,b) a*3+b*4c = m((5+6),(2+4)) //应该使用括号将其包围//C的结果等于57 再比如 123#define point (int*);point a,b; 本意是a和b都是int型指针，但是实际上变成int* a,b; a是int型指针，而b是int型变量。 这点要尤为注意 宏连接： C语言中，使用两个#即可将两个字符连接成为一个 123456789#include &lt;stdio.h&gt;#define A1 printf("print A1\r\n")#define A2 printf("print A2\r\n")#define A(NAME) A##NAMEint main()&#123; A(1); return 0;&#125; 会打印： 1print A1 在该例子中，调用宏A(1)时，NAME为1。A##NAME这个符号连接，即将A和1连接成了一个符号A1，然后执行宏A1的内容。最终打印出来了print A1 还有就是 无法通过宏展开的方式创建预处理器命令。即使宏的展开结果会生成形式上有效的命令，但预处理器不会执行它 你所要知道的小知识： 定义宏不占用内存，只有在使用时才分配内存 宏定义不存在类型问题，它的参数也是无类型的 字符串” “中不能使用宏定义 预处理是在编译之前的处理，而编译工作的任务之一就是语法检查，预处理不做语法检查 宏替换在预处理阶段进行，函数调用在编译后程序运行时进行，并且分配内存。预处理在编译之前，因此宏替换不分配内存 宏定义前面的替换必须是C语言合法的用户标识符 如 #define 0a 25 就是错误的 重复定义的宏只有最后一个是有效的 宏定义不是C语句，不必在行未加“；”号，如果加了连“；”号一起进行置换； 包含头文件的宏用一个include表示，引入的头文件有两种区别 一种是C语言自带的头文件,用 &lt;&gt;来表示 1#include &lt;stdio.h&gt; 编译的时候会在编译器的bin目录下面查找 另一种是用户自定义头文件，用&quot;&quot;来表示 1#include "LED.h" 编译时从对应自定义文件路径查找 当然 ，C语言自带头文件也可以使用 &quot;&quot; 这个我们讲解下： “”先在自定义路径查找有无该头文件，有则包含该目录下的头文件，没有则到系统指定的目录下找该头文件 &lt;&gt;直接到系统指定的目录下查找该文件 也就是说使用双引号比使用尖括号多了一个查找路径 #include 引入头文件的本质就是源码替换，预处理的时候将那些.h文件中的代码替换到头文件引入的位置进行编译 比如printf就会从stdio.h中寻找对应源码，之后进行替换，再替换以后的结果再交给编译器处理，进行编译。 条件编译宏c语言中条件编译相关的预编译指令 123456789101112#define 定义一个预处理宏#undef 取消宏的定义#if 编译预处理中的条件命令，相当于C语法中的if语句#ifdef 判断某个宏是否被定义，若已定义，执行随后的语句#ifndef 与#ifdef相反，判断某个宏是否未被定义#elif 若#if, #ifdef, #ifndef或前面的#elif条件不满足，则执行#elif之后的语句，相当于C语法中的else-if#else 与#if, #ifdef, #ifndef对应, 若这些条件不满足，则执行#else之后的语句，相当于C语法中的else#endif #if, #ifdef, #ifndef这些条件命令的结束标志.defined 与#if, #elif配合使用，判断某个宏是否被定义#error 编译程序时如果遇到#error就会生成一个编译错误提示信息并停止编译 举个简单的例子： 1234567#define ZZX#ifdef ZZXprintf("定义了Z小旋"); #else printf("没有定义Z小旋"); #endif 上面的代码就会输出定义Z小旋 而不满足条件的代码就不会编译 我们经常使用条件编译来定义头文件 123456#ifndef _DataCollect_H_#define _DataCollect_H_#代码块#endif 条件编译再我们正常程序的编写中是非常见的，你可以使用条件编译完成模块不同功能的设置，比如你想要用一套代码编译一个产品的两个功能，使用条件编译，一个#ifndef 即可完成两个不同代码块的切换，决定编译的时候生成的是哪个功能的代码。 总览图 预定义宏 宏名称 功能 _LINE_ 正在编译的文件的行号 _FILE_ 正在编译的文件的名字 _DATE_ 编译时刻的日期字符串 _TIME_ 编译时刻的时间字符串 _STDC_ 判断该程序是否为标准的c程序 标准的预定义宏都是用一两个下划线字符开头和结尾，这类宏不能被#undef所取消也不能被编程人员重新定义和修改 ，常用来说明文件信息等 123456789#include &lt;stdio.h&gt;int main() &#123;printf("Date : %s\n", __DATE__);printf("Time : %s\n", __TIME__);printf("File : %s\n", __FILE__);printf("Line : %d\n", __LINE__);system("pause");return 0;&#125; 输出如下： 1234Date : Sep 28 2019Time : 21:46:50File : C:\Users\48013\Desktop\小学弟的渣渣c\预定义宏.cLine : 6 剩余部分宏： 宏名称 功能 _STDC_VERSION_ 表示ISO C的版本 _STDC_HOSTED_ 如果值为1的话，表示目标环境有完成的标准C库 _BYTE_ORDER_ 表示当前环境的字节序 _LP64_ 表示当前环境是不是64位，如果该值为1，则环境为64位环境]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【STM32】HAL库 STM32CubeMX教程八---定时器输入捕获]]></title>
    <url>%2Fposts%2F18833%2F</url>
    <content type="text"><![CDATA[前言：本系列教程将外设原理，HAL库与STM32CubeMX结合在一起讲解，使您可以更快速的学会各个模块的使用 所用工具： 1、芯片： STM32F407ZET6/STM32F103ZET6 2、STM32CubeMx软件 3、IDE： MDK-Keil软件 4、STM32F1xx/STM32F4xxHAL库 5 知识概括： 通过本篇博客您将学到： SMT32定时器输入捕获 测量PWM频率和占空比 输入捕获输入捕获概念输入捕获模式可以用来测量脉冲宽度或者测量频率。STM32的定时器，除了TIM6、TIM7，其他的定时器都有输入捕获的功能。 具体请参看《【STM32】HAL库 STM32CubeMX教程六—-定时器中断》 输入捕获的工作原理 ①先设置输入捕获为上升沿检测， ②记录发生上升沿时TIMx_CNT(计数器)的值 ③配置捕获信号为下降沿捕获，当下降沿到来的时候发生捕获 ④记录此时的TIMx_CN(计数器)T的值 ⑤前后两次TIMx_CNT(计数器)的值之差就是高电平的脉宽。同时根据TIM的计数频率，我们就能知道高电平脉宽的准确时间。 简单说： 当你设置的捕获开始的时候，cpu会将计数寄存器的值复制到捕获比较寄存器中并开始计数，当再次捕捉到电平变化时，这是计数寄存器中的值减去刚才复制的值就是这段电平的持续时间，你可以设置上升沿捕获、下降沿捕获、或者上升沿下降沿都捕获， 输入捕获的工作流程(对应CubeMx的四个选项) 设置输入捕获滤波器STM32在很多功能中都提供了滤波器，滤波器的功能简单来说就是多次检测视为一次有效，达到滤波效果， 数字滤波器由一个事件计数器组成，假设我们是检测高电平，滤波N次，那么记录到N个事件后计数器会产生一个输出的跳变。也就是说连续N次采样检测，如果都是高电平，则说明这是一个有效的电平信号，这样便可以过滤掉那些因为某些而干扰产生的一些信号 输入捕获滤波器IC1F[3:0]，这个用于设置采样频率和数字滤波器长度。其中：fCK_INT是定时器的输入频率，fDTS是根据TIMx_CR1的CKD[1:0]的设置来确定的。 设置输入捕获极性设置具体为那种捕获事件 可以设置上升沿捕获、下降沿捕获、或者上升沿下降沿都捕获 设置输入捕获映射关系STM32为了更好的优化使用，TIMx_CH1通道1捕捉到的信号可以传输到IC1，TIMx_CH1捕捉到的信号也可以连接到IC2，TIMx_CH2捕捉到的信号也可以连接到IC2，也可以连接到IC2 设置输入捕获分频器设置每N个事件触发一次捕获**，可以设置为1/2/4/8次检测到电平变化才触发捕获** 溢出时间计算： t1时刻检测到高电平，发生中断，在中断里将计数值置0，开始记溢出次数N， 其中每计数0xFFFF次溢出一次，直到t2时刻跳变回低电平， 获取最后一次溢出时到t2时刻的计数值TIM5CH1_CAPTURE_VAL 则 ** 高电平时间 = 溢出次数65535+TIM5CH1_CAPTURE_VAL us* ；根据定时器初始化时的频率即可计算出溢出总次数所占用的时间，即为高电平时间。 如果计数器值为 32 bit 那么最大为0xFFFFFFFF 高电平时间： ![](https://img-blog.csdnimg.cn/20190813172958716.png)输入捕获的工作框图 工程创建设置RCC 设置高速外部时钟HSE 选择外部时钟源 2设置时钟 *我的是 外部晶振为8MHz * *1选择外部时钟HSE 8MHz * 2PLL锁相环倍频72倍 3系统时钟来源选择为PLL 4设置APB1分频器为 /2 5 这时候定时器的时钟频率为72Mhz 32的时钟树框图 如果不懂的话请看《【STM32】系统时钟RCC详解(超详细，超全面)》 3定时器配置 这里我们选择TIM5的通道1 预分频系数为71 计数时钟频率就是 72MHz/(71+1) = 1MHz 此时1us计数一次 自动加载值设置为32bit最大值 0xFFFFFFFF 上升沿捕获 不分频 滤波值为8 同时在NVIC一栏使能TIM5的中断 对应引脚设置下拉电阻，保证没有信号输入的时候电平稳定 4项目文件设置 1 设置项目名称 2 设置存储路径 3 选择所用IDE 5创建工程文件 然后点击*GENERATE CODE *创建工程 配置下载工具新建的工程所有配置都是默认的 我们需要自行选择下载模式，勾选上下载后复位运行 例程实现：定义变量： 1/* USER CODE BEGIN 0 */ uint32\_t capture\_Buf\[3\] = &#123;0&#125;; //存放计数值 uint8\_t capture\_Cnt = 0; //状态标志位 uint32\_t high\_time; //高电平时间/* USER CODE END 0 */ 在 while(1)中的用户代码区 3，写入TIM2 CH1通道的输入捕获控制和数据处理 12345678910111213141516171819while (1)&#123; /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ switch (capture_Cnt)&#123; case 0: capture_Cnt++; \_\_HAL\_TIM\_SET\_CAPTUREPOLARITY(&amp;htim5, TIM\_CHANNEL\_1, TIM\_INPUTCHANNELPOLARITY\_RISING); HAL\_TIM\_IC\_Start\_IT(&amp;htim5, TIM\_CHANNEL\_1); //启动输入捕获 或者: \_\_HAL\_TIM_ENABLE(&amp;htim5); break; case 3: high\_time = capture\_Buf\[1\]- capture_Buf\[0\]; //高电平时间 HAL\_UART\_Transmit(&amp;huart1, (uint8\_t *)high\_time, 1, 0xffff); //发送高电平时间 HAL_Delay(1000); //延时1S capture_Cnt = 0; //清空标志位 break; &#125;&#125;/* USER CODE END 3 */ 在main函数下方添加中断回调函数： 1234567891011121314/* USER CODE BEGIN 4 */void HAL\_TIM\_IC\_CaptureCallback(TIM\_HandleTypeDef *htim)&#123; if(TIM5 == htim-&gt;Instance) &#123; switch(capture_Cnt)&#123; case 1: capture\_Buf\[0\] = HAL\_TIM\_ReadCapturedValue(&amp;htim5,TIM\_CHANNEL_1);//获取当前的捕获值. \_\_HAL\_TIM\_SET\_CAPTUREPOLARITY(&amp;htim5,TIM\_CHANNEL\_1,TIM\_ICPOLARITY\_FALLING); //设置为下降沿捕获 capture_Cnt++; break; case 2: capture\_Buf\[1\] = HAL\_TIM\_ReadCapturedValue(&amp;htim5,TIM\_CHANNEL_1);//获取当前的捕获值. HAL\_TIM\_IC\_Stop\_IT(&amp;htim5,TIM\_CHANNEL\_1); //停止捕获 或者: \_\_HAL\_TIM_DISABLE(&amp;htim5); capture_Cnt++; &#125; &#125; &#125;/* USER CODE END 4 */ 具体流程： 1.设置TIM5 CH1为输入捕获功能； 2.设置上升沿捕获； 3.使能TIM2 CH1捕获功能； 4.捕获到上升沿后，定时器当前计数值存入capture_buf[0]，改为捕获下降沿； 5.捕获到下降沿后，定时器当前计数值存入存入capture_buf[1]，关闭TIM2 CH1捕获功能； capture_Cnt=3； 高电平时间： capture_buf[1] - capture_buf[0] 发送到上位机 重新启动输入捕获 __HAL_TIM_SET_COUNTER(&amp;TIM5_Handler,0); //设置计数寄存器的值变为0 HAL_TIM_PWM_Start() 函数用于使能定时器某一通道的PWM输出。 HAL_TIM_IC_Start_IT() 函数用于使能定时器某一通道的输入捕获功能，并使能相应的中断 HAL_TIM_IC_Stop_IT() 函数和开启功能相反，是关闭定时器某一通道的输入捕获功能和相应中断 __HAL_TIM_SET_CAPTUREPOLARITY不是函数，而是底层操作的一个宏定义 在stm32f4xx_hal_tim.h文件中可以找到。其作用是修改定时器某一通道的输入捕获极性 其中有两个函数，第一个为清除清除原来的捕获极性，第二个为设置通道捕捉极性 等价于： 1TIM\_RESET\_CAPTUREPOLARITY(&amp;TIM5\_Handler,TIM\_CHANNEL\_1); //一定要先清除原来的捕获极性！！TIM\_SET\_CAPTUREPOLARITY(&amp;TIM5\_Handler,TIM\_CHANNEL\_1,TIM\_ICPOLARITY\_FALLING);//定时器5通道1设置为下降沿捕获（重设捕获极性） 在修改定时器某一通道的输入捕获极性时，一定要先清除该通道之前捕获极性 __HAL_TIM_GET_COMPARE也是一个宏定义。 在stm32f4xx_hal_tim.h文件中可以找到。其作用是获取定时器某一通道的捕获/比较寄存器值 等价于 ： HAL_TIM_ReadCapturedValue(&amp;htim5,TIM_CHANNEL_1); 两者都是直接读取对应CCRx寄存器的值]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【STM32】系统时钟RCC详解(超详细，超全面)]]></title>
    <url>%2Fposts%2F52363%2F</url>
    <content type="text"><![CDATA[1什么是时钟时钟是单片机运行的基础，时钟信号推动单片机内各个部分执行相应的指令。时钟系统就是CPU的脉搏，决定cpu速率，像人的心跳一样 只有有了心跳，人才能做其他的事情，而单片机有了时钟，才能够运行执行指令，才能够做其他的处理 (点灯，串口，ADC)，时钟的重要性不言而喻。 为什么 STM32 要有多个时钟源呢？ STM32本身十分复杂，外设非常多 但我们实际使用的时候只会用到有限的几个外设，使用任何外设都需要时钟才能启动，但并不是所有的外设都需要系统时钟那么高的频率，为了兼容不同速度的设备，有些高速，有些低速，如果都用高速时钟，势必造成浪费 并且，同一个电路，时钟越快功耗越快，同时抗电磁干扰能力也就越弱，所以较为复杂的MCU都是采用多时钟源的方法来解决这些问题。所以便有了STM32的时钟系统和时钟树 总括： STM32时钟系统主要的目的就是给相对独立的外设模块提供时钟，也是为了降低整个芯片的耗能。 系统时钟，是处理器运行时间基准（每一条机器指令一个时钟周期） 时钟是单片机运行的基础，时钟信号推动单片机内各个部分执行相应的指令。 一个单片机内提供多个不同的系统时钟，可以适应更多的应用场合。 不同的功能模块会有不同的时钟上限，因此提供不同的时钟，也能在一个单片机内放置更多的功能模块。对不同模块的时钟增加开启和关闭功能，可以降低单片机的功耗 STM32为了低功耗，他将所有的外设时钟都设置为disable(不使能)，用到什么外设，只要打开对应外设的时钟就可以， 其他的没用到的可以还是disable(不使能)，这样耗能就会减少。 这就是为什么不管你配置什么功能都需要先打开对应的时钟的原因 STM32的时钟系统框图 === 乍一看很吓人，但其实很好理解，我们看*系统时钟SYSCLK 的左边 系统时钟有很多种选择，而左边的部分就是设置系统时钟使用那个时钟源， * 系统时钟SYSCLK 的右边，则是系统时钟通过AHB预分频器，给相对应的外设设置相对应的时钟频率 从左到右可以简单理解为 各个时钟源—&gt;系统时钟来源的设置—&gt;各个外设时钟的设置 时钟系统1各个时钟源 (左边的部分)STM32 有4个独立时钟源:HSI、HSE、LSI、LSE。①、HSI是高速内部时钟，RC振荡器，频率为8MHz，精度不高。②、HSE是高速外部时钟，可接石英/陶瓷谐振器，或者接外部时钟源，频率范围为4MHz~16MHz。③、LSI是低速内部时钟，RC振荡器，频率为40kHz，提供低功耗时钟。 ④、LSE是低速外部时钟，接频率为32.768kHz的石英晶体。 其中LSI是作为IWDGCLK(独立看门狗)时钟源和RTC时钟源 *而独立使用 * 而HSI高速内部时钟 HSE高速外部时钟 LSI低速内部时钟 这三个经过分频或者倍频 作为系统时钟来使用 PLL为锁相环倍频输出，其时钟输入源可选择为HSI/2、HSE或者HSE/2。倍频可选择为2~16倍，但是其输出频率最大不得超过72MHz。 通过倍频之后作为系统时钟的时钟源 举个例子：Keil编写程序是默认的时钟为72Mhz，其实是这么来的：外部晶振(HSE)提供的8MHz（与电路板上的晶振的相关）通过PLLXTPRE分频器后，进入PLLSRC选择开关，进而通过PLLMUL锁相环进行倍频（x9）后，为系统提供72MHz的系统时钟（SYSCLK）。之后是AHB预分频器对时钟信号进行分频，然后为低速外设提供时钟。 或者内部RC振荡器(HSI) 为8MHz /2 为4MHz 进入PLLSRC选择开关，通过PLLMUL锁相环进行倍频（x16）后 为72MHz PS: 网上有很多人说是5个时钟源，这种说法有点问题，学习之后就会发现PLL并不是自己产生的时钟源，而是通过其他三个时钟源倍频得到的时钟 2系统时钟SYSCLK系统时钟SYSCLK可来源于三个时钟源：①、HSI振荡器时钟②、HSE振荡器时钟③、PLL时钟最大为72Mhz 3USB时钟 STM32中有一个全速功能的USB模块，其串行接口引擎需要一个频率为48MHz的时钟源。该时钟源只能从PLL输出端获取（唯一的），，可以选择为1.5分频或者1分频，也就是，当需要使用USB模块时，PLL必须使能，并且时钟频率配置为48MHz或72MHz 4把时钟信号输出到外部 STM32可以选择一个时钟信号输出到MCO脚(PA8)上，可以选择为PLL输出的2分频、HSI、HSE、或者系统时钟。可以把时钟信号输出供外部使用 5系统时钟通过AHB分频器给外设提供时钟(右边的部分) 重点从左到右可以简单理解为 系统时钟—&gt;AHB分频器—&gt;各个外设分频倍频器 —&gt; 外设时钟的设置 右边部分为：系统时钟SYSCLK通过AHB分频器分频后送给各模块使用，AHB分频器可选择1、2、4、8、16、64、128、256、512分频。其中AHB分频器输出的时钟送给5大模块使用： ①内核总线：送给AHB总线、内核、内存和DMA使用的HCLK时钟。 ②Tick定时器：通过8分频后送给Cortex的系统定时器时钟。 ③I2S总线：直接送给Cortex的空闲运行时钟FCLK。 ④APB1外设：送给APB1分频器。APB1分频器可选择1、2、4、8、16分频，其输出一路供APB1外设使用(PCLK1，最大频率36MHz)，另一路送给通用定时器使用。该倍频器可选择1或者2倍频，时钟输出供定时器2-7使用。 ⑤APB2外设：送给APB2分频器。APB2分频器可选择1、2、4、8、16分频，其输出一路供APB2外设使用(PCLK2，最大频率72MHz)，另一路送给高级定时器。该倍频器可选择1或者2倍频，时钟输出供定时器1和定时器8使用。 另外，APB2分频器还有一路输出供ADC分频器使用，分频后送给ADC模块使用。ADC分频器可选择为2、4、6、8分频。 需要注意的是，如果 APB 预分频器分频系数是 1，则定时器时钟频率 (TIMxCLK) 为 PCLKx。否则，定 时器时钟频率将为 APB 域的频率的两倍：TIMxCLK = 2xPCLKx。 APB1和APB2的对应外设F1系列 APB1上面连接的是低速外设，包括电源接口、备份接口、CAN、USB、I2C1、I2C2、USART2、USART3、UART4、UART5、SPI2、SP3等； 而APB2上面连接的是高速外设，包括UART1、SPI1、Timer1、ADC1、ADC2、ADC3、所有的普通I/O口（PA-PE）、第二功能I/O（AFIO）口等。 F4系列 这个和F1系列类似，我们就举几个特殊的 APB2总线:高级定时器timer1, timer8以及通用定时器timer9, timer10, timer11 UTART1,USART6 APB1总线:通用定时器timer2~timer5，通用定时器timer12~timer14以及基本定时器timer6,timer7 UTART2~UTART5 F4系列的系统时钟频率最高能到168M 具体 可以在 stm32f10x_rcc.h 和stm32f40x_rcc.h 中查看 或者通过 STM32参考手册搜索“系统架构”或者“系统结构” 查看外设挂在哪个时钟下， RCC相关寄存器：这里我们以F1系列为例 123RCC 寄存器结构，RCC_TypeDeff，在文件“stm32f10x.h”中定义如下：1059行-&gt;1081行。： typedef struct &#123; vu32 CR; //HSI,HSE,CSS,PLL等的使能 vu32 CFGR; //PLL等的时钟源选择以及分频系数设定 vu32 CIR; // 清除/使能 时钟就绪中断 vu32 APB2RSTR; //APB2线上外设复位寄存器 vu32 APB1RSTR; //APB1线上外设复位寄存器 vu32 AHBENR; //DMA，SDIO等时钟使能 vu32 APB2ENR; //APB2线上外设时钟使能 vu32 APB1ENR; //APB1线上外设时钟使能 vu32 BDCR; //备份域控制寄存器 vu32 CSR; &#125; RCC_TypeDef; 可以对上上面的时钟框图和RCC寄存器来学习，对STM32的时钟系统有个大概的了解 其实也就是我们上面介绍的流程，理解了自然也就能写出来 RCC初始化：这里我们使用HSE(外部时钟），正常使用的时候也都是使用外部时钟 使用HSE时钟，程序设置时钟参数流程：1、将RCC寄存器重新设置为默认值 RCC_DeInit;2、打开外部高速时钟晶振HSE RCC_HSEConfig(RCC_HSE_ON);3、等待外部高速时钟晶振工作 HSEStartUpStatus = RCC_WaitForHSEStartUp();4、设置AHB时钟 RCC_HCLKConfig;5、设置高速AHB时钟 RCC_PCLK2Config;6、设置低速速AHB时钟 RCC_PCLK1Config;7、设置PLL RCC_PLLConfig;8、打开PLL RCC_PLLCmd(ENABLE);9、等待PLL工作 while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)10、设置系统时钟 RCC_SYSCLKConfig;11、判断是否PLL是系统时钟 while(RCC_GetSYSCLKSource() != 0x08)12、打开要使用的外设时钟 RCC_APB2PeriphClockCmd()/RCC_APB1PeriphClockCmd() 代码实现：对RCC的配置函数(使用外部8MHz晶振) 系统时钟72MHz，APH 72MHz，APB2 72MHz，APB1 32MHz，USB 48MHz TIMCLK=72M 1234567891011121314151617181920void RCC_Configuration(void)&#123; //----------使用外部RC晶振----------- RCC_DeInit(); //初始化为缺省值 RCC\_HSEConfig(RCC\_HSE_ON); //使能外部的高速时钟 while(RCC\_GetFlagStatus(RCC\_FLAG_HSERDY) == RESET); //等待外部高速时钟使能就绪 FLASH\_PrefetchBufferCmd(FLASH\_PrefetchBuffer_Enable); //Enable Prefetch Buffer FLASH\_SetLatency(FLASH\_Latency_2); //Flash 2 wait state RCC\_HCLKConfig(RCC\_SYSCLK_Div1); //HCLK = SYSCLK RCC\_PCLK2Config(RCC\_HCLK_Div1); //PCLK2 = HCLK RCC\_PCLK1Config(RCC\_HCLK_Div2); //PCLK1 = HCLK/2 RCC\_PLLConfig(RCC\_PLLSource\_HSE\_Div1,RCC\_PLLMul\_9); //PLLCLK = 8MHZ * 9 =72MHZ RCC_PLLCmd(ENABLE); //Enable PLLCLK while(RCC\_GetFlagStatus(RCC\_FLAG_PLLRDY) == RESET); //Wait till PLLCLK is ready RCC\_SYSCLKConfig(RCC\_SYSCLKSource_PLLCLK); //Select PLL as system clock while(RCC_GetSYSCLKSource()!=0x08); //Wait till PLL is used as system clock source //---------打开相应外设时钟-------------------- RCC\_APB2PeriphClockCmd(RCC\_APB2Periph_GPIOA,ENABLE); //使能APB2外设的GPIOA的时钟 &#125; 也就是我们时钟树框图从左到右的配置， 时钟监视系统（CSS） STM32还提供了一个时钟监视系统（CSS），用于监视高速外部时钟（HSE）的工作状态。倘若HSE失效，会自动切换（高速内部时钟）HSI作为系统时钟的输入，保证系统的正常运行。]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【STM32】 定时器---正交解码编码器模式详解]]></title>
    <url>%2Fposts%2F51504%2F</url>
    <content type="text"><![CDATA[增量式编码器增量式编码器也成为正交编码器，是通过两个信号线的脉冲输出来进行数据处理，一个输出脉冲信号就对应于一个增量位移，编码器每转动固定的位移，就会产生一个脉冲信号 通过读取单位时间脉冲信号的数量，便可以达到测速的效果(v=s/t），通过对脉冲信号的累加，和编码器的码盘的周长(转一圈对应距离) ** 便可以达到计算行走距离的效果(s=nd*) *编码器信号： * A 脉冲输出 B 脉冲输出 Z 零点信号 当编码器旋转到零点时，Z信号会发出一个脉冲表示现在是零位置 表示编码器转了1圈，可用来记录编码器转了多少圈，从而知道运行距离 VCC 电源线 GND 地线 编码器线数：编码器的线数 ,是说编码器转一圈输出多少个脉冲,,,如果一个编码器是500线,说明这个编码器转一圈对应的信号线会输出500个脉冲, A B两相转一圈发出的脉冲数一样的,不过存在90°相位差 线数越高代表编码器能够反应的位置精度越高 编码器原理：增量式编码器有两个脉冲输出，A相和B相，并且两个相位永远存在90°相位差。 如果两个信号相位差为90度，则这两个信号称为正交。由于两个信号相差90度，因此可以根据两个信号哪个先哪个后来判断方向、并且可以根据AB相脉冲信号数量测得速度，位移等， 编码器正反转： 正转的时候信号线A先输出信号,信号线B后输出 A相超前B相90度 证明是正转 反转的时候信号线B先输出信号,信号线A后输出 B相超前A相90度 证明是反转 STM32定时器编码器模式 STM32的编码器模式共有三种： 仅在TL1计数(A相) ** 仅在TL2计数(B相)** ** 在TL1和TL2都计数(A相和B相都计数)** 仅在TL1计数(A相) TI2(B相)为高电平时： 1时刻： TI1(A相)下降沿， 则向上计数(正转)。 2时刻：TI1(A相)上升沿， 则向下计数(反转) TI2(B相)为低电平时： 3时刻： TI1(A相)上升沿， 则向上计数(正转)。 4时刻：TI1(A相)下降沿， 则向下计数(反转) 仅在TL2计数(B相) TI1(A相)为高电平时： 1时刻： TI2(B相)上升沿， 则向上计数(正转)。 2时刻：TI2(B相)下降沿， 则向下计数(反转) TI2(B相)为低电平时： 3时刻： TI2(B相)下降沿， 则向上计数(正转)。 4时刻：TI2(B相)上升沿， 则向下计数(反转) 在TL1和TL2都计数(A相和B相都计数) 一个脉冲信号周期完成4次跳变。精度提高 1时刻：TI2为低电平，TI1上升沿跳变，计数器向上计数； 2时刻：TI1为高电平，TI2上升沿跳变，计数器仍然向上计数； 3时刻：TI2为高电平，TI1下降沿跳变，计数器仍然向上计数； 4时刻：TI1为低电平，TI2下降沿跳变，计数器仍然向上计数。 毛刺：只有一个相位脉冲 过滤掉 编码器转动过程中可能产生的毛刺过滤掉 计数器向下计数原理相同 看图即可很好理解。 计数器向下计数： A下降沿，B低电平B下降沿，A高电平B上升沿，A低电平A上升沿，B高电平 上升沿与下降沿参看 《外部中断—-高低电平触发,(边沿触发)上升沿触发和下降沿触发区别》 注意事项： 需要增加测量的精度时，可以采用4倍频方式，即分别在A、B相波形的上升沿和下降沿计数，分辨率可以提高4倍， 如果只是测速,不要求方向，那么只需要用单片机随意选择一个信号线就行了,,然后定时器边沿触发，检测脉冲计数即可 一般是定时器的通道1和2才能作为编码器输入口，对应编码器输出的两相。 GPIO配置为配置为上拉输入模式 一个定时器做一种工作，如果你配置了编码器模式，那么剩下的通道就不能配置其他模式 两相计数模式下， *读出来数需要/4 * *一个脉冲信号对应四次计数 * 编码器配置标准外设库TIM_EncoderInterfaceConfig，它就是编码器接口的配置函数。简单的只需要配置该函数，使能TIM，即可实现采集编码器上面的信息 1void TIM\_EncoderInterfaceConfig(TIM\_TypeDef* TIMx, uint16\_t TIM\_EncoderMode, uint16\_t TIM\_IC1Polarity, uint16\_t TIM\_IC2Polarity) TIMx参数就是使用哪个定时器作为编码器接口的捕捉定时器。 TIM_EncoderMode参数是模式，是单相计数(仅在TL1计数或仅在TL2计数)还是两相计数(在TL1和TL2都计数)。 TIM_IC1Polarity和TIM_IC2Polarity参数就是通道1、2的捕捉极性。 相关寄存器配置● CC1S=’01’ (TIMx_CCMR1寄存器，IC1FP1映射到TI1) ● CC2S=’01’ (TIMx_CCMR2寄存器，IC2FP2映射到TI2) ● CC1P=’0’ (TIMx_CCER寄存器，IC1FP1不反相，IC1FP1=TI1) ● CC2P=’0’ (TIMx_CCER寄存器，IC2FP2不反相，IC2FP2=TI2) ● SMS=’011’ (TIMx_SMCR寄存器，所有的输入均在上升沿和下降沿有效). ● CEN=’1’ (TIMx_CR1寄存器，计数器使能) *如果计数器只在TI2的边沿计数，则置TIMx_SMCR寄存器中的SMS=001；如果只在TI1边沿计数，则置SMS=010；如果计数器同时在TI1和TI2边沿计数，则置SMS=011 * 编码器模式功能： stm32f407中定时器1、2、3、4、5、8提供编码器接口模式 可以对输入信号TI1,TI2进行滤波处理，数字滤波器由事件器组成，每N个事件才视为一个有效边沿，可以在TIMx_CCMR1、TIMx_CCMR2中的IC1F位域设置 *也就是可以设置每产生几次脉冲才视为1次有效 * 各个值的计算：转速计算方法:用捕获值（一秒内输出的脉冲数）/编码器线数（转速一圈输出脉冲数）/电机减数比（内部电机转动圈数与电机输出轴转动圈数比，即减速齿轮比 没有则不用除） 运动距离计算：输出的总脉冲数 / 编码器线数*编码器齿轮周长 所转角度计算： 输出的总脉冲数 / 编码器线数 *360 或 溢出中断次数*360+当前计数值 转动方向： *方向在定时器CR1的DIR位里 *dir=(TIMX-&gt;CR1 &amp; 0x0010)&gt;&gt;4; //取方向标志位if(dir &gt; 0) //向下计数 else //向上计数 那么我们直接看代码： 定时器初始化设置 1234567891011121314151617181920212223242526272829303132void TIM3\_Int\_Init() &#123; TIM\_TimeBaseInitTypeDef TIM\_TimeBaseInitStructure; TIM\_ICInitTypeDef TIM\_ICInitStructure; NVIC\_InitTypeDef NVIC\_InitStructure; RCC\_APB1PeriphClockCmd(RCC\_APB1Periph_TIM3,ENABLE); //定时器设置------------------------------------------------------------- TIM\_TimeBaseInitStructure.TIM\_Period = 359*4; //重装载值 TIM\_TimeBaseInitStructure.TIM\_Prescaler=0x0; //预分频 TIM\_TimeBaseInitStructure.TIM\_CounterMode=TIM\_CounterMode\_Up; //向上计数 TIM\_TimeBaseInitStructure.TIM\_ClockDivision=TIM\_CKD\_DIV1; //时钟分割 TIM\_TimeBaseInit(TIM3,&amp;TIM\_TimeBaseInitStructure);//初始化TIM3//编码器模式设置-------------------------------------------------------------- TIM\_EncoderInterfaceConfig(TIM3,TIM\_EncoderMode\_TI12,TIM\_ICPolarity\_Rising, TIM\_ICPolarity_Rising);//计数模式3 TIM\_ICStructInit(&amp;TIM\_ICInitStructure); //将结构体中的内容缺省输入 TIM\_ICInitStructure.TIM\_ICFilter = 0;//滤波器值 TIM\_ICInit(TIM3, &amp;TIM\_ICInitStructure); //将TIM_ICInitStructure中的指定参数初始化TIM3//溢出中断设置-------------------------------------------------------------- TIM\_ITConfig(TIM3,TIM\_IT_Update,ENABLE); //允许TIM3溢出中断 NVIC\_InitStructure.NVIC\_IRQChannel=TIM3_IRQn; NVIC\_InitStructure.NVIC\_IRQChannelPreemptionPriority=0x01; NVIC\_InitStructure.NVIC\_IRQChannelSubPriority=0x01; NVIC\_InitStructure.NVIC\_IRQChannelCmd=ENABLE; NVIC\_Init(&amp;NVIC\_InitStructure); TIM_SetCounter(TIM3,0); //TIM3-&gt;CNT=0 TIM_Cmd(TIM3, ENABLE); &#125; 重装载值： (编码器线数-1 ) *4 因为我们是两相计数，一个脉冲信号4次计数，所以乘4，保证转完1整圈才触发中断 中断设置： 12345678int circle\_count=0;//圈数void TIM3\_IRQHandler(void)&#123; if(TIM\_GetITStatus(TIM3,TIM\_IT_Update)==SET) &#123; if((TIM3-&gt;CR1&gt;&gt;4 &amp; 0x01)==0) //DIR==0 circle_count++; else if((TIM3-&gt;CR1&gt;&gt;4 &amp; 0x01)==1)//DIR==1 circle_count--; &#125; TIM\_ClearITPendingBit(TIM3,TIM\_IT_Update); &#125; 各个值的计算： 脉冲数： TIM_GetCounter(TIM3)/4 1int angle=0; //转过总角度int Realyangle = 0; //当前实际角度 0~360int Distiance=0; //运行距离extern int circle\_count; //转过圈数Realyangle = TIM\_GetCounter(TIM3)/4/360 ; //先除4 最后除编码器线数angle=Realyangle +circle\_count\*360;//当前角度Distiance = angle/360\*编码器齿轮周长 + circle\_count*编码器齿轮周长]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【STM32】STM32F4 GPIO八种模式及工作原理详解]]></title>
    <url>%2Fposts%2F15066%2F</url>
    <content type="text"><![CDATA[1 GPIO简介GPIO,即通用I/O(输入/输出)端口，是STM32可控制的引脚。STM32芯片的GPIO引脚与外部设备连接起来，可实现与外部通讯、控制外部硬件或者采集外部硬件数据的功能。 *STM32F407有7组IO。分别为GPIOA~GPIOG，每组IO有16个IO口，共有112个IO口 通常称为 PAx、PBx、PCx、PDx、PEx、PFx、PGx，其中x为0-15。 并且F4系列是基于Cortex-M4内核 * GPIO的复用： STM32F4 有很多的内置外设，这些外设的外部引脚都是与 GPIO 共用的。也就是说，一个引脚可以有很多作用，但是默认为IO口，如果想使用一个 GPIO内置外设的功能引脚，就需要GPIO的复用，那么当这个 GPIO 作为内置外设使用的时候，就叫做复用。 比如说串口 就是GPIO复用为串口 2 GPIO的工作模式1、4种输入模式 （1）GPIO_Mode_IN_FLOATING 浮空输入（2）GPIO_Mode_IPU 上拉输入（3）GPIO_Mode_IPD 下拉输入（4）GPIO_Mode_AIN 模拟输入 *2、4种输出模式 * （5）GPIO_Mode_Out_OD 开漏输出（带上拉或者下拉）（6）GPIO_Mode_AF_OD 复用开漏输出（带上拉或者下拉）（7）GPIO_Mode_Out_PP 推挽输出（带上拉或者下拉）（8）GPIO_Mode_AF_PP 复用推挽输出（带上拉或者下拉）3、4种最大输出速度（1）2MHZ (低速)（2）25MHZ (中速)（3）50MHZ (快速)（4）100MHZ (高速) 关于他们的定义，都在 stm32f4xx_gpio.h 中，都为结构体形式的定义 3 GPIO框图剖析 我们所用到的每一个GPIO其内部结构都是这样，分别对应着GPIO的八种模式 这里我们简单的介绍下： 保护二极管： IO引脚上下两边两个二极管用于防止引脚外部过高、过低的电压输入，当引脚电压高于VDD_FT**时，上方的二极管导通，当引脚电压低于VSS时，下方的二极管导通，防止不正常电压引入芯片导致芯片烧毁 ** 上拉、下拉电阻：控制引脚默认状态的电压，开启上拉的时候引脚默认电压为高电平，开启下拉的时候引脚默认电压为低电平 TTL施密特触发器：基本原理是当输入电压高于正向阈值电压，输出为高；当输入电压低于负向阈值电压，输出为低；IO口信号经过触发器后，模拟信号转化为0和1的数字信号 也就是高低电平 并且是TTL电平协议 这也是为什么STM32是TTL电平协议的原因 P-MOS管和N-MOS管：信号由P-MOS管和N-MOS管，依据两个MOS管的工作方式，使得GPIO具有“推挽输出”和“开漏输出”的模式 P-MOS管高电平导通，低电平关闭，下方的N-MOS低电平导通，高电平关闭 注： *VDD_FT 代表IO口，兼容3.3V和5V，如果没有标注“FT”，就代表着不兼容5V * 在芯片数据手册的引脚定义中，会看到有“I/O电平”一列 有FT即为支持5V 4 GPIO的八种工作模式剖析：浮空输入模式浮空输入模式下，I/O端口的电平信号直接进入输入数据寄存器。MCU直接读取I/O口电平，I/O的电平状态是不确定的，完全由外部输入决定；如果在该引脚悬空（在无信号输入）的情况下，读取该端口的电平是不确定的。 (接用电压表测量其引脚电压为1点几伏，这是个不确定值*) *以用来做KEY识别 上拉输入模式![](https://img-blog.csdnimg.cn/20190801194218819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)** IO内部接上拉电阻，此时如果IO口外部没有信号输入或者引脚悬空，IO口默认为高电平 如果I/O口输入低电平，那么引脚就为低电平，MCU读取到的就是低电平** STM32的内部上拉是”弱上拉”，即通过此上拉输出的电流是很弱的，如要求大电流还是需要外部上拉。 下拉输入模式![](https://img-blog.csdnimg.cn/20190801195135782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)** IO内部接下拉电阻，此时如果IO口外部没有信号输入或者引脚悬空，IO口默认为低电平 如果I/O口输入高电平，那么引脚就为高电平，MCU读取到的就是高电平** 模拟输入模式![](https://img-blog.csdnimg.cn/20190801200336884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)当GPIO引脚用于ADC采集电压的输入通道时，用作”模拟输入”功能，此时信号不经过施密特触发器，直接直接进入ADC模块，并且输入数据寄存器为空 ，CPU不能在输入数据寄存器上读到引脚状态 当GPIO用于模拟功能时，引脚的上、下拉电阻是不起作用的，这个时候即使配置了上拉或下拉模式，也不会影响到模拟信号的输入输出 除了 ADC 和 DAC 要将 IO 配置为模拟通道之外其他外设功能一律 要配置为复用功能模式， 开漏输出模式（带上拉或者下拉）![](https://img-blog.csdnimg.cn/20190801205006100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)在开漏输出模式时，只有N-MOS管工作，如果我们控制输出为0，低电平，则P-MOS管关闭，N-MOS管导通，使输出低电平，I/O端口的电平就是低电平，若控制输出为1时，高电平，则P-MOS管和N-MOS管都关闭，输出指令就不会起到作用，此时I/O端口的电平就不会由输出的高电平决定，而是由I/O端口外部的上拉或者下拉决定 如果没有上拉或者下拉 IO口就处于悬空状态 *并且此时施密特触发器是打开的，即输入可用，通过输入数据寄存器GPIOx_IDR可读取I/O的实际状态。，I/O口的电平不一定是输出的电平 * 推挽输出模式（带上拉或者下拉）![](https://img-blog.csdnimg.cn/20190801213632139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)在推挽输出模式时，N-MOS管和P-MOS管都工作，如果我们控制输出为0，低电平，则P-MOS管关闭，N-MOS管导通，使输出低电平，I/O端口的电平就是低电平，若控制输出为1 高电平，则P-MOS管导通N-MOS管关闭，使输出高电平，I/O端口的电平就是高电平， 外部上拉和下拉的作用是控制在没有输出时IO口电平 *此时施密特触发器是打开的，即输入可用，通过输入数据寄存器GPIOx_IDR可读取I/O的实际状态。I/O口的电平一定是输出的电平 * 复用开漏输出（带上拉或者下拉）![](https://img-blog.csdnimg.cn/20190801214830330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)GPIO复用为其他外设，输出数据寄存器GPIOx_ODR无效； 输出的高低电平的来源于其它外设，施密特触发器打开，输入可用，通过输入数据寄存器可获取I/O实际状态 除了输出信号的来源改变 其他与开漏输出功能相同 复用推挽输出（带上拉或者下拉）![](https://img-blog.csdnimg.cn/20190801215400510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)GPIO复用为其他外设(如 I2C)，输出数据寄存器GPIOx_ODR无效； 输出的高低电平的来源于其它外设，施密特触发器打开，输入可用，通过输入数据寄存器可获取I/O实际状态 除了输出信号的来源改变 其他与开漏输出功能相同 开漏输出和推挽输出的区别： 推挽输出： *可以输出强高低电平，连接数字器件 * 推挽结构一般是指两个三极管分别受两互补信号的控制,总是在一个三极管导通的时候另一个截止. 开漏输出： 可以输出强低电平，高电平得靠外部电阻拉高。输出端相当于三极管的集电极. 需要外接上拉电阻，才能实现输出高电平合于做电流型的驱动，其吸收电流的能力相对强(一般20ma以内)； 在使用任何一种开漏模式时，都需要接上拉电阻，否则只能输出低电平 、 推挽输出电路： 其中IN端输出高电平时下面的PNP三极管截止，而上面NPN三极管导通，输出电平VS+；当IN端输出低电平时则恰恰相反，PNP三极管导通，输出和地相连，为低电平 开漏输出电路：IN端输出低电平时，三极管导通，使输出接地，IN端输出高电平时，三极管截止，所以引脚既不输出高电平，也不输出低电平，为高阻态。为正常使用时必须接上拉电阻， 在STM32中选用IO模式: 上拉输入、下拉输入可以用来检测外部信号；例如，按键等； 模拟输入 ——应用ADC模拟输入，或者低功耗下省电 开漏输出一般应用在I2C、SMBUS通讯等需要”线与”功能的总线电路中。 推挽输出模式一般应用在输出电平为0和3.3伏而且需要高速切换开关状态的场合。在STM32的应用中，除了必须用开漏模式的场合，我们都习惯使用推挽输出模式。 复用功能的推挽输出_AF_PP ——片内外设功能（I2C的SCL,SDA） 复用功能的开漏输出_AF_OD——片内外设功能（TX1,MOSI,MISO.SCK.SS） F4系列与F1系列区别:本质上的区别是F4系列采用了Cortex-M4内核 而F1系列采用Cortex-M3内核 F1系列(M3)IO口基本结构： F4系列(M4)IO口基本结构： F4系列设计的更加高级与人性化，他将外部上下拉电阻转移到了输出/输入驱动器外部，使得输出模式下也可以实现内部上拉与下拉，方便了用户的使用，增加了灵活性 GPIO的初始化(F4)这里我们以初始化LED为例 1.定义一个 GPIO_InitTypeDef 类型的结构体 GPIO_InitTypeDef GPIO_InitStructure; /定义一个 GPIO_InitTypeDef 类型的结构体/ 一共有5个参数 2开启 LED 相关的 GPIO 外设时钟 RCC_AHB1PeriphClockCmd ( RCC_AHB1Periph_GPIOB, ENABLE); /开启 AHB1时钟/ Q:为什么要设置时钟？ 任何外设都需要时钟，51单片机，stm32，430等等，因为寄存器是由D触发器组成的，往触发器里面写东西，前提条件是有时钟输入。stm32是低功耗，他将所有的门都默认设置为disable(不使能)，在你需要用哪个门的时候，开哪个门就可以，也就是说用到什么外设，只要打开对应外设的时钟就可以， 其他的没用到的可以还是disable(不使能)，这样耗能就会减少。Q:为什么 STM32 要有多个时钟源呢？ 因为首 先 STM32 本身非常复杂，外设非常的多，但是并不是所有外设都需要系统时钟这么高的频率， 比如看门狗以及 RTC 只需要几十 k 的时钟即可。同一个电路，时钟越快功耗越大，同时抗电磁 干扰能力也会越弱，所以对于较为复杂的 MCU 一般都是采取多时钟源的方法来解决这些问题。 而相对应的外设功能所使用的时钟 在stm32f4xx.h 中即可查看到 RCC_AHB1 RCC_APB1 3选择要控制的 GPIO 引脚 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; /选择Pin9引脚/ 可选引脚为0-15 一组IO口有16个引脚 4设置所选引脚的模式 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT; /设定为输出模式/ 引脚的模式共有四种，分别为输入，输出，复用，和模拟模式 5 设定所选引脚的输出类型 GPIO_InitStructure.GPIO_OType = GPIO_OType_PP; /设置引脚的输出类型为推挽输出/ 输出模式有两种：推挽输出和开漏输出 只有输出模式才需要配置，输入模式下不需要配置 6 设定所选管脚的速度 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;//设定速度为100MHz 高速模式 7 设定所选管脚的上拉与下拉 GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP; /设置引脚为上拉模式/ 可设置为：上拉，下拉，与浮空 8初始化GPIO GPIO_Init(GPIOB, &amp;GPIO_InitStructure); //初始化所设置的引脚 GPIO_Init() 是官方配置的初始化函数 第一个参数是GPIOX 第二个参数是结构体所对应GPIO各种参数的配置 GPIO的初始化(F1)F4的初始化相较于F1系列有了很大的改变，在配置F1系列时，结构体只有三个参数 ** GPIO_InitTypeDef 类型的结构体** 所选管脚的速度 所选管脚的8种模式 区别： F1(M-3)系列管脚速度只有三种模式 并且管脚的模式配置八种模式全部都在一起定义，直接设置即可 总归还是大同小异，不做过多介绍，看下下方配置即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294void led_init(void)&#123;1 GPIO简介--------**GPIO**,即通用I/O(输入/输出)端口，是STM32可控制的引脚。STM32芯片的GPIO引脚与外部设备连接起来，可实现与外部通讯、控制外部硬件或者采集外部硬件数据的功能。**STM32F407有7组IO。分别为GPIOA~GPIOG，每组IO有16个IO口，共有112个IO口 通常称为 PAx、PBx、PCx、PDx、PEx、PFx、PGx，其中x为0-15。 并且F4系列是基于Cortex-M4内核 ****GPIO的复用：**STM32F4 有很多的**内置外设**，这些外设的外部引脚都是与 GPIO 共用的。也就是说，**一个引脚可以有很多作用，但是默认为IO口，如果想使用一个 GPIO内置外设的功能引脚，就需要GPIO的复用，那么当这个 GPIO 作为内置外设使用的时候，就叫做复用。** 比如说串口 就是GPIO复用为串口 2 GPIO的工作模式-----------**1、4种输入模式**（1）GPIO\_Mode\_IN_FLOATING 浮空输入 （2）GPIO\_Mode\_IPU 上拉输入 （3）GPIO\_Mode\_IPD 下拉输入 （4）GPIO\_Mode\_AIN 模拟输入**2、4种输出模式 **（5）GPIO\_Mode\_Out_OD 开漏输出（带上拉或者下拉） （6）GPIO\_Mode\_AF_OD 复用开漏输出（带上拉或者下拉） （7）GPIO\_Mode\_Out_PP 推挽输出（带上拉或者下拉） （8）GPIO\_Mode\_AF_PP 复用推挽输出（带上拉或者下拉） **3、4种最大输出速度** （1）2MHZ (低速) （2）25MHZ (中速) （3）50MHZ (快速) （4）100MHZ (高速) **关于他们的定义，都在 stm32f4xx_gpio.h 中，都为结构体形式的定义**3 **GPIO框图剖析**--------------![](https://img-blog.csdnimg.cn/20190801161834709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)我们所用到的每一个GPIO其内部结构都是这样，分别对应着GPIO的八种模式 这里我们简单的介绍下：* **保护二极管： IO引脚上下两边两个二极管用于防止引脚外部过高、过低的电压输入，**当**引脚电压高于VDD_FT****时，上方的二极管导通，当引脚电压低于VSS时，下方的二极管导通，防止不正常电压引入芯片导致芯片烧毁 ** * **上拉、下拉电阻：控制引脚默认状态的电压，开启上拉的时候引脚默认电压为高电平，开启下拉的时候引脚默认电压为低电平** * **TTL施密特触发器：**基本原理是当输入电压高于正向阈值电压，输出为高；当输入电压低于负向阈值电压，输出为低；**IO口信号经过触发器后，模拟信号转化为0和1的数字信号 也就是高低电平 并且是TTL电平协议 这也是为什么STM32是TTL电平协议的原因** * **P-MOS管和N-MOS管**：**信号由P-MOS管和N-MOS管，依据两个MOS管的工作方式，使得GPIO具有“推挽输出”和“开漏输出”的模式 P-MOS管高电平导通，低电平关闭，下方的N-MOS低电平导通，高电平关闭** 注： **VDD_FT 代表IO口，兼容3.3V和5V，如果没有标注“FT”，就代表着不兼容5V ** 在芯片数据手册的引脚定义中，会看到**有“I/O电平”一列 有FT即为支持5V**![](https://img-blog.csdnimg.cn/20190801175317972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)### 4 GPIO的八种工作模式**剖析**：### 浮空输入模式 ![](https://img-blog.csdnimg.cn/20190801191842465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)**浮空输入模式下，I/O端口的电平信号直接进入输入数据寄存器。MCU直接读取I/O口电平，I/O的电平状态是不确定的，完全由外部输入决定；如果在该引脚悬空（在无信号输入）的情况下，读取该端口的电平是不确定的。 (**接用电压表测量其引脚电压为1点几伏，这是个不确定值**) **以用来做KEY识别 上拉输入模式 ![](https://img-blog.csdnimg.cn/20190801194218819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)** IO内部接上拉电阻，此时如果IO口外部没有信号输入或者引脚悬空，IO口默认为高电平 如果I/O口输入低电平，那么引脚就为低电平，MCU读取到的就是低电平****STM32的内部上拉是&quot;弱上拉&quot;，即通过此上拉输出的电流是很弱的，如要求大电流还是需要外部上拉。** 下拉输入模式 ![](https://img-blog.csdnimg.cn/20190801195135782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)** IO内部接下拉电阻，此时如果IO口外部没有信号输入或者引脚悬空，IO口默认为低电平 如果I/O口输入高电平，那么引脚就为高电平，MCU读取到的就是高电平** 模拟输入模式 ![](https://img-blog.csdnimg.cn/20190801200336884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)**当GPIO引脚用于ADC采集电压的输入通道时，用作&quot;模拟输入&quot;功能，此时信号不经过施密特触发器，直接直接进入ADC模块，并且输入数据寄存器为空 ，CPU不能在输入数据寄存器上读到引脚状态****当GPIO用于模拟功能时，引脚的上、下拉电阻是不起作用的，这个时候即使配置了上拉或下拉模式，也不会影响到模拟信号的输入输出****除了 ADC 和 DAC 要将 IO 配置为模拟通道之外其他外设功能一律 要配置为复用功能模式，** 开漏输出模式（带上拉或者下拉） ![](https://img-blog.csdnimg.cn/20190801205006100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)在开漏输出模式时**，只有N-MOS管工作，如果我们控制输出为0，低电平，则P-MOS管关闭，N-MOS管导通，使输出低电平，I/O端口的电平就是低电平，若控制输出为1时，高电平，则P-MOS管和N-MOS管都关闭，输出指令就不会起到作用，此时I/O端口的电平就不会由输出的高电平决定，而是由I/O端口外部的上拉或者下拉决定 如果没有上拉或者下拉 IO口就处于悬空状态****并且此时施密特触发器是打开的，即输入可用，通过输入数据寄存器GPIOx_IDR可读取I/O的实际状态。，I/O口的电平不一定是输出的电平 ** 推挽输出模式（带上拉或者下拉） ![](https://img-blog.csdnimg.cn/20190801213632139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)在推挽输出模式时**，N-MOS管和P-MOS管都工作，如果我们控制输出为0，低电平，则P-MOS管关闭，N-MOS管导通，使输出低电平，I/O端口的电平就是低电平，若控制输出为1 高电平，则P-MOS管导通N-MOS管关闭，使输出高电平，I/O端口的电平就是高电平， 外部上拉和下拉的作用是控制在没有输出时IO口电平****此时施密特触发器是打开的，即输入可用，通过输入数据寄存器GPIOx_IDR可读取I/O的实际状态。I/O口的电平一定是输出的电平 ** 复用开漏输出（带上拉或者下拉） ![](https://img-blog.csdnimg.cn/20190801214830330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)**GPIO复用为其他外设，输出数据寄存器GPIOx_ODR无效； 输出的高低电平的来源于其它外设，施密特触发器打开，输入可用，通过输入数据寄存器可获取I/O实际状态 除了输出信号的来源改变 其他与开漏输出功能相同** 复用推挽输出（带上拉或者下拉） ![](https://img-blog.csdnimg.cn/20190801215400510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)**GPIO复用为其他外设(如 I2C)，输出数据寄存器GPIOx_ODR无效； 输出的高低电平的来源于其它外设，施密特触发器打开，输入可用，通过输入数据寄存器可获取I/O实际状态 除了输出信号的来源改变 其他与开漏输出功能相同** **开漏输出和推挽输出的区别：****推挽输出：****可以输出强高低电平，连接数字器件 ****推挽结构一般是指两个三极管分别受两互补信号的控制,总是在一个三极管导通的时候另一个截止.****开漏输出：****可以输出强低电平，高电平得靠外部电阻拉高。输出端相当于三极管的集电极. 需要外接上拉电阻，才能实现输出高电平合于做电流型的驱动，其吸收电流的能力相对强(一般20ma以内)；****在使用任何一种开漏模式时，都需要接上拉电阻，否则只能输出低电平**![](https://img-blog.csdnimg.cn/20190802084009482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)**、**推挽输出电路： 其中IN端输出高电平时下面的PNP三极管截止，而上面NPN三极管导通，输出电平VS+；当IN端输出低电平时则恰恰相反，PNP三极管导通，输出和地相连，为低电平 开漏输出电路：IN端输出低电平时，三极管导通，使输出接地，IN端输出高电平时，三极管截止，所以引脚既不输出高电平，也不输出低电平，为高阻态。为正常使用时必须接上拉电阻，**在STM32中选用IO模式:*** 上拉输入、下拉输入可以用来检测外部信号；例如，按键等； * 模拟输入 ——应用ADC模拟输入，或者低功耗下省电 * 开漏输出一般应用在I2C、SMBUS通讯等需要&quot;线与&quot;功能的总线电路中。 * **推挽输出模式一般应用在输出电平为0和3.3伏而且需要高速切换开关状态的场合。**在STM32的应用中，除了必须用开漏模式的场合，我们都习惯使用推挽输出模式。 * 复用功能的推挽输出\_AF\_PP ——片内外设功能（I2C的SCL,SDA） * 复用功能的开漏输出\_AF\_OD——片内外设功能（TX1,MOSI,MISO.SCK.SS） ### F4系列与F1系列区别:本质上的区别是F4系列采用了**Cortex-M4内核 而**F1系列采用**Cortex-M3内核**F1系列(**M3**)IO口基本结构：![](https://img-blog.csdnimg.cn/20190801221426325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)F4系列(**M4**)IO口基本结构：![](https://img-blog.csdnimg.cn/20190801221500464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)F4系列设计的更加高级与人性化，他将**外部上下拉电阻转移到了输出/输入驱动器外部**，使得输出模式下也可以实现内部上拉与下拉，方便了用户的使用，增加了灵活性 GPIO的初始化(F4)------------这里我们以初始化LED为例**1.定义一个 GPIO_InitTypeDef 类型的结构体**&gt; GPIO\_InitTypeDef GPIO\_InitStructure; /*定义一个 GPIO_InitTypeDef 类型的结构体*/一共有5个参数![](https://img-blog.csdnimg.cn/20190802082555844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70) **2开启 LED 相关的 GPIO 外设时钟**&gt; RCC\_AHB1PeriphClockCmd ( RCC\_AHB1Periph_GPIOB, ENABLE); /*开启 AHB1时钟*/ **Q:为什么要设置时钟？** 任何外设都需要时钟，51单片机，stm32，430等等，因为寄存器是由D触发器组成的，往触发器里面写东西，前提条件是有时钟输入。stm32是低功耗，他将所有的门都默认设置为disable(不使能)，在你需要用哪个门的时候，开哪个门就可以，也就是说用到什么外设，只要打开对应外设的时钟就可以， 其他的没用到的可以还是disable(不使能)，这样耗能就会减少。**Q:为什么 STM32 要有多个时钟源呢？**因为首 先 STM32 本身非常复杂，外设非常的多，但是并不是所有外设都需要系统时钟这么高的频率， 比如看门狗以及 RTC 只需要几十 k 的时钟即可。同一个电路，时钟越快功耗越大，同时抗电磁 干扰能力也会越弱，所以对于较为复杂的 MCU 一般都是采取多时钟源的方法来解决这些问题。 而相对应的外设功能所使用的时钟 在stm32f4xx.h 中即可查看到**RCC_AHB1**![](https://img-blog.csdnimg.cn/20190802093032688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)**RCC_APB1**![](https://img-blog.csdnimg.cn/20190802093048325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)**3选择要控制的 GPIO 引脚**&gt; GPIO\_InitStructure.GPIO\_Pin = GPIO\_Pin\_9; /*选择Pin9引脚*/可选引脚为0-15 一组IO口有16个引脚![](https://img-blog.csdnimg.cn/2019080122332587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)**4设置所选引脚的模式**&gt; GPIO\_InitStructure.GPIO\_Mode = GPIO\_Mode\_OUT; /*设定为输出模式*/引脚的模式共有四种，分别为输入，输出，复用，和模拟模式![](https://img-blog.csdnimg.cn/2019080209031850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70) **5 设定所选引脚的输出类型**&gt; GPIO\_InitStructure.GPIO\_OType = GPIO\_OType\_PP; /*设置引脚的输出类型为推挽输出*/输出模式有两种：推挽输出和开漏输出 ![](https://img-blog.csdnimg.cn/20190802090723845.png)**只有输出模式才需要配置，输入模式下不需要配置****6 设定所选管脚的速度**&gt; GPIO\_InitStructure.GPIO\_Speed = GPIO\_Speed\_100MHz;//设定速度为100MHz 高速模式![](https://img-blog.csdnimg.cn/2019080209104520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)**7 设定所选管脚的上拉与下拉**&gt; GPIO\_InitStructure.GPIO\_PuPd = GPIO\_PuPd\_UP; /*设置引脚为上拉模式*/可设置为：上拉，下拉，与浮空![](https://img-blog.csdnimg.cn/20190802091352838.png)**8初始化GPIO**&gt; GPIO\_Init(GPIOB, &amp;GPIO\_InitStructure); //初始化所设置的引脚GPIO_Init() 是官方配置的初始化函数 **第一个参数是GPIOX 第二个参数是结构体所对应GPIO各种参数的配置** ### GPIO的初始化(F1)F4的初始化相较于F1系列有了很大的改变，在配置F1系列时，结构体只有三个参数 ** GPIO_InitTypeDef 类型的结构体**![](https://img-blog.csdnimg.cn/20190802093751960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)**所选管脚的速度**![](https://img-blog.csdnimg.cn/20190802093918542.png)**所选管脚的8种模式**![](https://img-blog.csdnimg.cn/20190802094236801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)**区别：** F1(M-3)系列管脚速度只有三种模式 并且管脚的模式配置八种模式全部都在一起定义，直接设置即可总归还是大同小异，不做过多介绍，看下下方配置即可```cvoid led_init(void)&#123; GPIO\_InitTypeDef GPIO\_InitStruct; //定义初始化结构体 RCC\_APB2PeriphClockCmd(RCC\_APB2Periph_GPIOA,ENABLE); //使能GPIOA时钟 GPIO\_InitStruct.GPIO\_Mode = GPIO\_Mode\_Out_PP; //配置模式 GPIO\_InitStruct.GPIO\_Pin = GPIO\_Pin\_0; //配置哪个IO口 GPIO\_InitStruct.GPIO\_Speed = GPIO\_Speed\_50MHz; //配置IO口速度,仅输出有效 GPIO\_Init(GPIOA,&amp;GPIO\_InitStruct); //初始化GPIOA的参数为以上结构体&#125; ![](https://img-blog.csdnimg.cn/20190726200706356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70) GPIO\_InitTypeDef GPIO\_InitStruct; //定义初始化结构体 RCC\_APB2PeriphClockCmd(RCC\_APB2Periph_GPIOA,ENABLE); //使能GPIOA时钟 GPIO\_InitStruct.GPIO\_Mode = GPIO\_Mode\_Out_PP; //配置模式 GPIO\_InitStruct.GPIO\_Pin = GPIO\_Pin\_0; //配置哪个IO口 GPIO\_InitStruct.GPIO\_Speed = GPIO\_Speed\_50MHz; //配置IO口速度,仅输出有效 GPIO\_Init(GPIOA,&amp;GPIO\_InitStruct); //初始化GPIOA的参数为以上结构体}]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Python】-将list列表写入文件并读取方法汇总]]></title>
    <url>%2Fposts%2F16224%2F</url>
    <content type="text"><![CDATA[1.writelines()直接写入 123456l=\[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;\]f=open(&quot;k.txt&quot;,&quot;w&quot;)f.writelines(l)f.close() 该方法写入直接写入列表元素 2.str转化为字符串写入 123456l=\[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,1,2,3\]f=open(&quot;k.txt&quot;,&quot;w&quot;)f.write(str(l))f.close() 该方法会将整个列表转化为字符串并写入， 3.for循环写入 12345l=\[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;\]f=open(&quot;k.txt&quot;,&quot;w&quot;)for line in l: f.write(line+&apos;\\n&apos;)f.close() 此方法的好处是，每个元素都是单词写入，可以在写入时对每个元素进行修改，并且可以换行。但注意列表中的数字是没有办法与你所要添加的字符相加的(int类型不能与str相加) 4.使用.join函数修改列表 1234l=\[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;\]str = &apos;\\n&apos;f=open(&quot;k.txt&quot;,&quot;w&quot;)f.write(str.join(l))f.close() 使用join可以很好的添加你想要添加的字符以及数字，非常的灵活，推荐使用，如果列表中存在数值类型，可以先用str转换之后再进行写入 读取数据1read 如果使用read来读取，则返回为字符串类型，并且列表只能为字符串类型(str)，不能存在数值类型，如果有数字则会报错 readline与read相同 ， 如果使用readlines来读取，则默认返回为列表类型，并且列表的一个元素为一行元素 这时便可以对数据进行很好的处理 读取列表中的数字，提供一个简单的方法 1for line in l: if &quot;0&quot; in next or &quot;1&quot; in next：]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[智能车之五电感100%入环]]></title>
    <url>%2Fposts%2F35789%2F</url>
    <content type="text"><![CDATA[写在前面： 搞了好久，试了不下五六种方案，先是摄像头+电磁加权，之后固定打角，随后又是竖直电感入环，竖直电感又搞了几种方式，总是找不到一种代码简便，又能够稳定稳定入环的方案，看了很多国一国二代码，在今天(5.16)突然想到八字电感，想去官网看看有没有类似的，但是技术报告下不下来，因为没有参考，只好自己摆放了一下电感，然后开始摸索，最后想出来一种方案，基本可以实现完美入环，不太清楚哈工大是否这样使用，但个人测试效果非常可以， 想着入环岛，那么最基本的肯定要先做到识别，对于环岛的识别，我个人的思想是分为五部分即可，以右环岛为例 1 在第一部分时，你会发现右边赛道宽度突然变宽，而左边赛道正常(可以区分环岛和十字(十字为两边发生突变)) 这时候便可以加一个标志位1， 2.在第二部分，我们可以看到左边赛道无突变，右边赛道丢线(检测不到黑点)，各位应该都有丢线标志位 这时便有环岛标志位2 3在第三部分(标志位1和标志位2成立)，我们可以看到右边赛道先是逐渐变窄，之后便是逐渐变宽，这时候可以得到标志位3 并且记录下右赛道刚开始变宽时的行位置 4.之后你会发现右边赛道再次丢线，最后一个标志位 5。当然少不了最后的V(赛道宽度发生突变) 识别其实不难，大家可以根据自己的图像来具体修改，具体识别会有不同，但有思路即可，你会发现3，4，5在一幅图像中，也可以根据这些来进行判断，(当然，今年各位应该都是电磁+摄像头，这样的话环岛识别便更为简单，电磁信号变为双倍，并且摄像头有少许标志位，便可以很简单的判断出环岛，)之后便是最重要的补线了 补线 补线便是根据1和2点根据斜率连接，最小二乘法拟合得到相应的中线 1点 ：右边界为直线，上一次左边界-这次左边界&gt;10(这一行赛道宽度-上一行赛道宽度&gt;10) 并记录下该行左边界位置，即为1点 *2点： 前面有提到过，右边界为直线，这一行左边界-上一行左边界&gt;2 记录下此时左右边界位置 右边界为2点 * 3点： 2点的左边界即为3点 4.如果为左环岛，则右边界为直道。 赛道边界法：如果不用拟合直线，可以考虑以1点作为赛道右边界，然后右边界往前依次递增(右环岛为递减) 直到2点处，也可得到不错的入环效果 具体方法是假设1点为x行y列 2点为x2行y2列 用y-y1得到列数差，x-x1得到行数差 最后列数差/行数差=每行递减值Y 然后从1点开始，往前一直到2点行每行右边界依次右移 Y 即可得到得到图像 举个例子 1点为55行 左边界为20列 (55,20) 2点为30行 右边界为70列(30,70) 那么每行递减值 = （70-20）/(55-30) = 2 这样每行位移2即可 当然还可以有一些其他处理让它更接近圆环 至于最小二乘法拟合直线相信各位都有了解，只要能成功识别1，2两点，拟合补线便是处理问题了 当然，今年由于限高，可能你的小车看不到2和3点，如果为一下特征，仍然是1点补线，但是从1点到另一边界有赛道的最后一行即可 2停止补线当车辆进入环内后，可以停止补线了，这时候按照正常寻线来跑即可 需要注意的是，这里的停止补线标志位要写好，因为小车每次入环的速度和位置是不同的，如果停止补线误判的话会有很大问题 3出环岛补线 出环岛补线 当图中的右赛道边界先减小后增大时的，改行的右边界位置即为补线位置 上一次右边界-这次右边界&gt;10(这一行赛道宽度-上一行赛道宽度&gt;10) 记录右边界位置 或者出环岛用电磁出环也可 毕竟环岛入环是要把他作为一个圆环弯道来处理，不管用什么方法、只要你最后得到的补线能够更好的接近圆环弯道，转向就会越精确,只要1，2两点能够很好识别，怎么让他更好的接近圆环处理，更好的方法需要你的聪慧去发现，同时，入环写好了，出环其实思路一样， 电磁入环 电磁入环是五电感入环 (电感可以改为8字电感) 具体方法为： 中间电感一个阀值来识别环岛，识别完成竖直差比和进环，进入后切换水平差比和寻迹，出环时标志位检测用水平电感，延时一定时间或编码器积分清标志即可。 我们可以这样想，如果是单纯水平电感遇到弯道，会流畅的转向，而在遇到环岛时，我们把竖直电感作为转向环，是不是相当于正常入弯呢 简单来说，两个不同差和比即可 Turn_Offset = (float) (LAD-RAD)/(float)(LAD+RAD+MAD)*100;//经典差和比 Turn_Offset2 = (float) (L1AD-R1AD)/(float)(L1AD+R1AD+MAD)*100;//竖直电感差和比 当然左竖直电感与与右竖直电感进行差比和 ，还有这一些处理，比如如何适应大小环，入环如何完美和出环稳定性等 这些问题还是要处理的(可修改PID参数来调节)， 当然希望大家能独立思考下， 总结：基于今年应该都是电磁+摄像头，可以说在赛道元素处理上即难了，又简单了 难是对于新手小白(博主)来说，要同时学习处理电磁和摄像头，并且多了一些元素，再加上会车，对小白不是很友好 简单是电磁+摄像头之后，一些赛道元素可以更好的处理 ，比如环岛，如果单摄像头或者单电磁入环不稳定，可以考虑两个加权，达到较稳定状态，就可以跑得不错。 总的来说可以是，电感阈值 || 摄像头环岛检测 来判断环岛 (有上帝之光摄像头环岛识别不良) 之后电磁入环还是摄像头入环就要个人考虑了 感觉有用的话，点个赞再走呗！ 本文作者： Zxiaoxuan]]></content>
      <categories>
        <category>NXP智能车</category>
      </categories>
      <tags>
        <tag>NXP智能车</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USB转串口 TTL RS-232 RS-485 COM口 UART区别]]></title>
    <url>%2Fposts%2F7030%2F</url>
    <content type="text"><![CDATA[1串口串口，即串行通信接口，与之相对应的另一种接口叫并口，并行接口。两者的区别是，传输一个字节（8个位）的数据时，串口是将8个位排好队，逐个地在1条连接线上传输，而并口则将8个位一字排开，分别在8条连接线上同时传输 ，也就是进行数据传输的接口 串口是一种物理接口形式，(硬件)通常指COM接口 ，当然这些接口有着很多标准 接口标准： 串口通信的接口标准有很多，而我们所了解的RS-232C、RS-232、RS-422A、RS-485 都是串口的标准之一 通常使用的是9 针D 形连接器，简称 DB9接口，也称之为RS-232接口，之前串口通信使用的大多都是 DB9 接口 而有的使用的是老式的DB25 针连接器，也称之为RS-422接口，这种接口目前已经很少使用 DB25 和 DB9 接头有公头和母头之分，其中带针状的接头是公头，而带孔状的接头是母头 *而DB9/DB25接口 ，就称为COM口 * 2.UART口*嵌入式里面说的串口，一般是指UART口 * UART 通用异步收发传输器（Universal Asynchronous Receiver/Transmitter)。 它将要传输的资料在串行通信与并行通信之间加以转换。作为把并行输入信号转成串行输出信号的芯片 同样它是串行通信接口 UART只有数据线收和发，并无时钟线，故为异步串行通信接口，可以实现全双工传输和接收；在嵌入式中，常用与上位机与外设通信 单片机中的UART有4个pin（VCC, GND, RX, TX）, 用的TTL电平 VCC：供电pin，一般是3.3v， GND：接地pin，板内共地时可以不单独接，板间通信时候必须接上 RX：数据接收引脚 TX：数据发送引脚 TTL电平与RS-232区别RS232电平, 它是负逻辑电平，它定义+5+12V为低电平“0”，而-12-5V为高电平“1” TTL电平（Transistor-Transistor Logic），该电平的逻辑“1”为+5V，逻辑“0”为0V，称为TTL TTL电平标准： 输出 L： &lt;0.8V ； H：&gt;2.4V。 输入 L： &lt;1.2V ； H：&gt;2.0V 需要注意的是RS-232与TTL只是一种电平标准，而COM口和UART口是物理接口，只是COM口肯定使用RS-232标准 而UART一般使用TTL标准 USB通用串行总线（英语：Universal Serial Bus，缩写：USB）是连接计算机系统与外部设备的一种串口总线标准，也是一种输入输出接口的技术规范，被广泛地应用于个人电脑和移动设备等信息通讯产品 ，随着时代的发展，USB接口已经逐渐替代了COM口，成为最主流的接口，现今已经到了USB 3.0 常见的USB接口： 电脑上的USB接口的输出电压为直流5V，输出电流不大于500毫安 并且与TTL电平不兼容，信号传输时需要电平转换电路。 USB转TTL我们知道现在电脑使用的基本都是USB接口，而单片机使用的是TTL标准，那么在嵌入式中我们需要上位机通信，怎么办呢？，这时候便需要一个转换芯片，从而使得电脑(主机)可以通过USB输出TTL电平 ，这便是USB转TTL 那么我们所已知的*CH340G CH340E PL2303 、CP2102 等等 ，都是USB转TTL串口的芯片 * 当然现在普遍使用的为**CH340G 主要是因为其安全，耐用并且便宜** 满足我们日常的正常使用 在接线时注意单片机RX接转接板TX TX接转接板RX 连接顺序为： 电脑USB口—&gt; USB转TTL—-&gt;单片机UART口 USB转串口(RS-232)我们知道单片机是UATR口 TTL电平标准，而电脑是USB口 如果我们想用电脑的USB口与单片机串口(COM口)通信，这时就需要使用MAX232之类的电平转换芯片，将单片机TTL电平转换成RS-232电平 ，并且 将USB转换为RS-232电平 这就是USB转串口 我们所说的USB转串口，就是指单片机上装了一个TTL转RS-232的转换芯片 ，并且有COM口，使得单片机可以输出RS-232电平，这样便可以通过 USB转串口(RS-232)模块连接电脑USB口，再与单片机COM口相连，双方都是RS-232电平标准，便可以来进行通信 市场出售的usb转串口线一般会有两个芯片，一个是CH340这类芯片，一个是MAX232类芯片，因为计算机的串口电平标准是RS232电平 所以通过 USB转串口(**RS-232)模块** USB经过CH340转成了TTL串口，中间那四个引脚可以引出，再经由MAX232转换为RS-232电平，9针串口引出 下方为USB转串口(**RS-232)模块** 并且MAX232芯片是 TTL电平与RS232电平的专用双向转换芯片，可以TTL转RS-232，也可以RS-232转TTL 在单片机上用作TTL转RS-232 连接顺序为： 电脑USB口—&gt;USB转串口—-&gt;单片机COM口 两个单片机以RS-232通讯协议标准串口的设备间通讯结构图如下： 电脑COM口 to 单片机COM口当然，如果电脑有COM口，这个时候便可以直接将电脑的COM口与单片机的COM口进行相连，便可以进行通信 当然在串口通信中通常 电脑的 DB9 为公头，单片机上使用的串口 DB9 为母头，通过一根直通串口线进行相连 连接顺序为： 电脑COM口—&gt;—-&gt;单片机COM口 以单片机串口与PC串口通信就应该遵循下面的连接方式：在单片机串口与上位机给出的rs232口之间，通过电平转换电路(如下面图中的Max232芯片) 实现TTL电平与RS232电平之间的转换。 电脑USB口 to 单片机USB口为了方便，很多单片机上都配备了USB转TTL芯片，直接引出usb接口，便可以实现通信 总结：最简单理解 xx转xx 就是将前面的转换为后面的 USB转TTL 就是将USB转换为 TTL电平 USB转串口 就是将USB转换为串口 ①.COM口：在台式机上常用的口，DB9/DB25接口，接口协议只有两种RS232和RS485 COM口多见于旧式电脑，用于连接鼠标，调制调解器等设备，现在已被USB取代。 ②.UART口、COM口指的是物理接口形式;TTL、RS232和RS485指的是电平逻辑标准； ③TL电平和RS232电平转换专用芯片有MAX232，TTL电平转USB芯片有CP2102、PL2303、FT230，CH340 ④ COM口 和UART口 都为串口的一种 ，即都为串行通信 UART为异步串行通信接口 ⑤UART包含TTL电平的串口和RS232电平的串口，但是我们的单片机的UART是TTL电平 ⑥ 串口按照接口划分标准分为很多种 ，如UATR RS232 同步串行接口 扩展：同步通信和异步通信： 同步通信和异步通信的区别是：时钟线的有无。同步通信有时钟线，收发双方通过统一的时钟来频率确定何时进行数据的传输，如I2C和SPI。异步通信没有时钟线，可以任意时刻开始发送字符 但只能在数据的开始和尾加入标志位来区分不同的数据帧，即加上开始位和停止位，所传送的数据以字节为单位。每个字节前加上一位起始位，每个字节的后面加上停止位，接收数据之前也要预先知道波特率的大小，传输效率比同步通信要低。如UART 但方便简单，易于操作 简单来说： 同步是指：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式。异步是指：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。 串行通信与并行通信： 串行通信就是一根数据线，数据是一位一位的依次传输 而并行通信则是8跟数据线，数据是一个字节一个字节的发送 串口形容一下就是一条车道，而并口就是有8/16个车道同一时刻能传送8/16位（一个字节/两个字节）数据]]></content>
      <categories>
        <category>嵌入式学习</category>
      </categories>
      <tags>
        <tag>嵌入式学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[智能车学习----最小二乘法求拟合曲线(中线)的斜率]]></title>
    <url>%2Fposts%2F48428%2F</url>
    <content type="text"><![CDATA[最小二乘法：最小二乘法（又称最小平方法）是一种数学优化技术。它通过最小化误差的平方和寻找数据的最佳函数匹配。利用最小二乘法可以简便地求得未知的数据，并使得这些求得的数据与实际数据之间误差的平方和为最 小，简单来说，就是通过最小化误差的平方和，使得拟合对象无限接近目标对象，这就是最小二乘的核心思想。最小二乘法还可用于曲线拟合。 在此先列举一下最小二乘家族成员。最小二乘法直线拟合，最小二乘法多项式（曲线）拟合，机器学习中线性回归的最小二乘法，系统辨识中的最小二乘辨识法，参数估计中的最小二乘法，等等 这里我们要说的是最小二乘法拟合曲线的斜率。 拟合直线作用： 在我们做一些处理的时候，得到的数据可能是一些离散的点，而我们往往希望得到一个连续的函数（也就是拟合直线）或者更加密集的离散方程与已知数据相吻合，这过程就叫做拟合， 以智能车为例把，我们平时得到的中线，可以说就是一些离散的点，它不是一条顺滑的曲线，而我们的拟合直线，则使用在中线和各种赛道元素补线上，在用中线做偏差处理时，将中线拟合一下，得到的斜率偏差则是会更加精确，在一些特殊的赛道元素，如环岛，我们可以用最小二乘法做补线处理， 概念与公式：说到最小二乘法，可能有的同学说没学过，但是我们给出公式应该同学们会说：哦！原来是他啊。 推导： 即为： 最小二乘法多项式直线拟合，就是根据给定的点，用计算的方法求出最佳的 a(斜率) 和 b（截距）。显然，关键是如何求出最佳的 a 和 b。 相信各位高中都已经学过了，下面我们给出计算中线斜率的代码 12345678910111213141516171819202122232425/************************************线性回归计算中线斜率************************************/// y = Ax+Bint regression(int startline,int endline)&#123; int i=0,SumX=0,SumY=0,SumLines = 0; float SumUp=0,SumDown=0,avrX=0,avrY=0,B,A; SumLines=endline-startline; // startline 为开始行， //endline 结束行 //SumLines for(i=startline;i&lt;endline;i++) &#123; SumX+=i; SumY+=Middle\_black\[i\]; //这里Middle\_black为存放中线的数组 &#125; avrX=SumX/SumLines; //X的平均值 avrY=SumY/SumLines; //Y的平均值 SumUp=0; SumDown=0; for(i=startline;i&lt;endline;i++) &#123; SumUp+=(Middle_black\[i\]-avrY)*(i-avrX); SumDown+=(i-avrX)*(i-avrX); &#125; if(SumDown==0) B=0; else B=(int)(SumUp/SumDown); A=(SumY-B*SumX)/SumLines; //截距 return B; //返回斜率&#125; 看代码很容易可以理解。 对于斜率的使用，个人是将他与误差结合起来使用，效果还输不错的 那么，用最小二乘法除了拟合中线斜率之外，我们还可以用斜率进行补线操作，以及用最小二乘法预估赛道边界，等等 这里我们暂时不做阐述，之后博文会更新，]]></content>
      <categories>
        <category>NXP智能车</category>
      </categories>
      <tags>
        <tag>NXP智能车</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位置式PID与增量式PID区别浅析]]></title>
    <url>%2Fposts%2F29144%2F</url>
    <content type="text"><![CDATA[1PID控制算法什么是PID PID 控制器以各种形式使用超过了 1 世纪，广泛应用在机械设备、气动设备 和电子设备.在工业应用中PID及其衍生算法是应用最广泛的算法之一，是当之无愧的万能算法 PID 实指“比例 proportional”、“积分 integral”、“微分 derivative”，这三项构 成 PID 基本要素。每一项完成不同任务，对系统功能产生不同的影响。它的结构简单，参数易 于调整，是控制系统中经常采用的控制算法。 PID：比例单元（P）、积分单元（I）和微分单元（D）组成 PID控制公式 其中：u(t)为控制器输出的控制量；（输出） e(t)为偏差信号，它等于给定量与输出量之差；（输入） KP 为比例系数；（对应参数 P） TI 为积分时间常数；（对应参数I） TD 为微分时间常数。(对应参数 D) 数字 PID 控制算法通常分为位置式 PID 控制算法和增量式 PID 控制算法。 位置式 PID 算法 : e(k): *用户设定的值（目标值） - 控制对象的当前的状态值 * *比例P : * e(k) *积分I : * ∑e(i) 误差的累加 微分D : e(k) - e(k-1) 这次误差-上次误差 也就是位置式PID是当前**系统的实际位置，与你想要达到的预期位置的偏差，**进行PID控制 因为有误差积分 ∑e(i)，一直累加，也就是当前的输出u(k)与过去的所有状态都有关系，用到了误差的累加值；（误差e会有误差累加），输出的u(k)对应的是执行机构的实际位置，，一旦控制输出出错(*控制对象的当前的状态值出现问题 *)，u(k)的大幅变化会引起系统的大幅变化 并且位置式PID在积分项达到饱和时,误差仍然会在积分作用下继续累积，一旦误差开始反向变化，系统需要一定时间从饱和区退出，所以在u(k)达到最大和最小时，要停止积分作用，并且要有积分限幅和输出限幅 所以在使用位置式PID时，一般我们直接使用PD控制 而位置式 PID 适用于执行机构不带积分部件的对象，如舵机和平衡小车的直立和**温控系统的控制** 结合代码可以很好理解 1234567891011121314151617181920212223242526272829typedef struct PID&#123; float P,I,D,limit;&#125;PID;typedef struct Error&#123; float Current_Error;//当前误差 float Last_Error;//上一次误差 float Previous_Error;//上上次误差&#125;Error;/*! * @brief 位置式PID * @since v1.0 * *sptr ：误差参数 * *pid: PID参数 * NowPlace：当前位置 * Point： 预期位置 */// 位置式PID控制float PID_Realize(Error \*sptr,PID \*pid, int32 NowPlace, float Point)&#123; int32 iError, // 当前误差 Realize; //实际输出 iError = Point - NowPlace; // 计算当前误差 sptr-&gt;Current_Error += pid-&gt;I * iError; // 误差积分 sptr-&gt;Current\_Error = sptr-&gt;Current\_Error &gt; pid-&gt;limit?pid-&gt;limit:sptr-&gt;Current_Error;//积分限幅 sptr-&gt;Current\_Error = sptr-&gt;Current\_Error &lt;-pid-&gt;limit?-pid-&gt;limit:sptr-&gt;Current_Error; Realize = pid-&gt;P * iError //比例P + sptr-&gt;Current_Error //积分I + pid-&gt;D * (iError - sptr-&gt;Last_Error); //微分D sptr-&gt;Last_Error = iError; // 更新上次误差 return Realize; // 返回实际值&#125; 增量式PID 比例P : e(k)-e(k-1) 这次误差-上次误差 积分I : e(i) 误差 *微分D : * e(k) - 2e(k-1)+e(k-2) 这次误差-2*上次误差+上上次误差 增量式PID根据公式可以很好地看出，一旦确定了 KP、TI 、TD，只要使用前后三次测量值的偏差， 即可由公式求出控制增量 而得出的控制量▲u(k)对应的是近几次位置误差的增量，而不是对应与实际位置的偏差 没有误差累加 也就是说，增量式PID中不需要累加。控制增量Δu(k)的确定仅与最近3次的采样值有关，容易通过加权处理获得比较好的控制效果，并且在系统发生问题时，增量式不会严重影响系统的工作 总结：增量型 PID，是对位置型 PID 取增量，这时控制器输出的是相邻两次采样时刻所计算的位置值之差，得到的结果是增量，即在上一次的控制量的基础上需要增加（负值意味减少）控制量。 123456789101112131415161718192021222324252627typedef struct PID&#123; float P,I,D,limit;&#125;PID;typedef struct Error&#123; float Current_Error;//当前误差 float Last_Error;//上一次误差 float Previous_Error;//上上次误差&#125;Error;/*! * @brief 增量式PID * @since v1.0 * *sptr ：误差参数 * *pid: PID参数 * NowPlace：实际值 * Point： 期望值 */// 增量式PID电机控制int32 PID_Increase(Error \*sptr, PID \*pid, int32 NowPlace, int32 Point)&#123; int32 iError, //当前误差 Increase; //最后得出的实际增量 iError = Point - NowPlace; // 计算当前误差 Increase = pid-&gt;P * (iError - sptr-&gt;Last_Error) //比例P + pid-&gt;I * iError //积分I + pid-&gt;D * (iError - 2 * sptr-&gt;Last\_Error + sptr-&gt;Previous\_Error); //微分D sptr-&gt;Previous\_Error = sptr-&gt;Last\_Error; // 更新前次误差 sptr-&gt;Last_Error = iError; // 更新上次误差 return Increase; // 返回增量&#125; 增量式与位置式区别：*1增量式算法不需要做累加，控制量增量的确定仅与最近几次偏差采样值有关，计算误差对控制 量计算的影响较小。而位置式算法要用到过去偏差的累加值，容易产生较大的累加误差。 * 2增量式算法得出的是控制量的增量，例如在阀门控制中，只输出阀门开度的变化部分，误动作 影响小，必要时还可通过逻辑判断限制或禁止本次输出，不会严重影响系统的工作。 而位置式的输出直接对应对象的输出，因此对系统影响较大。 3增量式PID控制输出的是控制量增量，并无积分作用，因此该方法适用于执行机构带积分部件的对象，如步进电机等，而位置式PID适用于执行机构不带积分部件的对象，如电液伺服阀。 4在进行PID控制时，位置式PID需要有积分限幅和输出限幅，而增量式PID只需输出限幅 位置式PID优缺点：优点：①位置式PID是一种非递推式算法，可直接控制执行机构（如平衡小车），u(k)的值和执行机构的实际位置（如小车当前角度）是一一对应的，因此在执行机构不带积分部件的对象中可以很好应用 缺点：①每次输出均与过去的状态有关，计算时要对e(k)进行累加，运算工作量大。 增量式PID优缺点：优点：①误动作时影响小，必要时可用逻辑判断的方法去掉出错数据。②手动/自动切换时冲击小，便于实现无扰动切换。当计算机故障时，仍能保持原值。③算式中不需要累加。控制增量Δu(k)的确定仅与最近3次的采样值有关。 缺点： ①积分截断效应大，有稳态误差； ②溢出的影响大。有的被控对象用增量式则不太好；]]></content>
      <categories>
        <category>NXP智能车</category>
      </categories>
      <tags>
        <tag>NXP智能车</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OTSU大津法优化算法(0.8ms/1.0ms)]]></title>
    <url>%2Fposts%2F26471%2F</url>
    <content type="text"><![CDATA[两种优化方式 1.0ms与0.8ms////////////////////大津法二值化////////////////////// /*! @brief 大津法二值化0.8ms程序 @since v1.2 *image ：图像地址 width: 图像宽 height：图像高 @author ZZX 注：河北工程大学内部使用 / //0x4D;0x18-0x1A;uint8 otsuThreshold(uint8 image, uint16 width, uint16 height){ #define GrayScale 256 int pixelCount[GrayScale] = {0};//每个灰度值所占像素个数 float pixelPro[GrayScale] = {0};//每个灰度值所占总像素比例 int i,j; int Sumpix = width * height; //总像素点 uint8 threshold = 0; uint8 data = image; //指向像素数据的指针 } ////////////////////大津法二值化////////////////////// /*! @brief 大津法二值化1.0ms程序 @since v1.2 *image ：图像地址 width: 图像宽 height：图像高 @author ZZX 注：河北工程大学内部使用 / //0x4D;0x18-0x1A;uint8 otsu1ms(uint8 *image, uint16 width, uint16 height){////////////////////大津法二值化////////////////////// /*! @brief 大津法二值化1.0ms程序 @since v1.2 *image ：图像地址 width: 图像宽 height：图像高 @author ZZX 注：河北工程大学内部使用 /////////////////////大津法二值化////////////////////// /*! @brief 大津法二值化1.0ms程序 @since v1.2 *image ：图像地址 width: 图像宽 height：图像高 @author ZZX 注：河北工程大学内部使用 /////////////////////大津法二值化////////////////////// /*! @brief 大津法二值化1.0ms程序 @since v1.2 *image ：图像地址 width: 图像宽 height：图像高 @author ZZX 注：河北工程大学内部使用 /////////////////////大津法二值化////////////////////// /*! @brief 大津法二值化1.0ms程序 @since v1.2 *image ：图像地址 width: 图像宽 height：图像高 @author ZZX 注：河北工程大学内部使用 /////////////////////大津法二值化////////////////////// /*! @brief 大津法二值化1.0ms程序 @since v1.2 *image ：图像地址 width: 图像宽 height：图像高 @author ZZX 注：河北工程大学内部使用 /]]></content>
      <categories>
        <category>NXP智能车</category>
      </categories>
      <tags>
        <tag>NXP智能车</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[智能车环岛浅析(电磁+摄像头)]]></title>
    <url>%2Fposts%2F21849%2F</url>
    <content type="text"><![CDATA[写在前面： 看到网上对于环岛的介绍微乎其微，想着写点什么，对于一些没有祖传代码和资料的同学起到一点指导和抛砖引玉的作用把，看了一些国一国二的代码，发现跟自己想的方法基本一致，所以个人认为应该能对没有思路的同学有一点启发，当然，比赛最主要的就是锻炼个人能力，条条大路通环岛，希望同学们不要被我的这种方法所局限，自己的思想无论在何时都是要有的，当然，由于本人能力不足等原因，如果有错误欢迎批评指出。 摄像头入环1识别环岛 想着入环岛，那么最基本的肯定要先做到识别，对于环岛的识别，我个人的思想是分为五部分即可，以右环岛为例 1 在第一部分时，你会发现右边赛道宽度突然变宽，而左边赛道正常(可以区分环岛和十字(十字为两边发生突变)) 这时候便可以加一个标志位1， 2.在第二部分，我们可以看到左边赛道无突变，右边赛道丢线(检测不到黑点)，各位应该都有丢线标志位 这时便有环岛标志位2 3在第三部分(标志位1和标志位2成立)，我们可以看到右边赛道先是逐渐变窄，之后便是逐渐变宽，这时候可以得到标志位3 并且记录下右赛道刚开始变宽时的行位置 4**.之后你会发现右边赛道再次丢线，最后一个标志位** 5。当然少不了最后的V(赛道宽度发生突变) 识别其实不难，大家可以根据自己的图像来具体修改，具体识别会有不同，但有思路即可，你会发现3，4，5在一幅图像中，也可以根据这些来进行判断，(当然，今年各位应该都是电磁+摄像头，这样的话环岛识别便更为简单，电磁信号变为双倍，并且摄像头有少许标志位，便可以很简单的判断出环岛，)之后便是最重要的补线了 补线 补线便是根据1和2点根据斜率连接，最小二乘法拟合得到相应的中线 1点 ：右边界为直线，上一次左边界-这次左边界&gt;10(这一行赛道宽度-上一行赛道宽度&gt;10) 并记录下该行左边界位置，即为1点 *2点： 前面有提到过，右边界为直线，这一行左边界-上一行左边界&gt;2 记录下此时左右边界位置 右边界为2点 * 3点： 2点的左边界即为3点 4.如果为左环岛，则右边界为直道。 赛道边界法：如果不用拟合直线，可以考虑以1点作为赛道右边界，然后右边界往前依次递增(右环岛为递减) 直到2点处，也可得到不错的入环效果 具体方法是假设1点为x行y列 2点为x2行y2列 用y-y1得到列数差，x-x1得到行数差 最后列数差/行数差=每行递减值Y 然后从1点开始，往前一直到2点行每行右边界依次右移 Y 即可得到得到图像 举个例子 1点为55行 左边界为20列 (55,20) 2点为30行 右边界为70列(30,70) 那么每行递减值 = （70-20）/(55-30) = 2 这样每行位移2即可 当然还可以有一些其他处理让它更接近圆环 至于最小二乘法拟合直线相信各位都有了解，只要能成功识别1，2两点，拟合补线便是处理问题了 当然，今年由于限高，可能你的小车看不到2和3点，如果为一下特征，仍然是1点补线，但是从1点到另一边界有赛道的最后一行即可 2停止补线当车辆进入环内后，可以停止补线了，这时候按照正常寻线来跑即可 需要注意的是，这里的停止补线标志位要写好，因为小车每次入环的速度和位置是不同的，如果停止补线误判的话会有很大问题 3出环岛补线 出环岛补线 当图中的右赛道边界先减小后增大时的，改行的右边界位置即为补线位置 上一次右边界-这次右边界&gt;10(这一行赛道宽度-上一行赛道宽度&gt;10) 记录右边界位置 或者出环岛用电磁出环也可 毕竟环岛入环是要把他作为一个圆环弯道来处理，不管用什么方法、只要你最后得到的补线能够更好的接近圆环弯道，转向就会越精确,只要1，2两点能够很好识别，怎么让他更好的接近圆环处理，更好的方法需要你的聪慧去发现，同时，入环写好了，出环其实思路一样， 电磁入环 电磁入环是五电感入环 (电感可以改为8字电感) 具体方法为： 中间电感一个阀值来识别环岛，识别完成竖直差比和进环，进入后切换水平差比和寻迹，出环时标志位检测用水平电感，延时一定时间或编码器积分清标志即可。 我们可以这样想，如果是单纯水平电感遇到弯道，会流畅的转向，而在遇到环岛时，我们把竖直电感作为转向环，是不是相当于正常入弯呢 简单来说，两个不同差和比即可 Turn_Offset = (float) (LAD-RAD)/(float)(LAD+RAD+MAD)*100;//经典差和比 Turn_Offset2 = (float) (L1AD-R1AD)/(float)(L1AD+R1AD+MAD)*100;//竖直电感差和比 当然左竖直电感与与右竖直电感进行差比和 ，还有这一些处理，比如如何适应大小环，入环如何完美和出环稳定性等 这些问题还是要处理的(可修改PID参数来调节)， 当然希望大家能独立思考下， 总结：基于今年应该都是电磁+摄像头，可以说在赛道元素处理上即难了，又简单了 难是对于新手小白(博主)来说，要同时学习处理电磁和摄像头，并且多了一些元素，再加上会车，对小白不是很友好 简单是电磁+摄像头之后，一些赛道元素可以更好的处理 ，比如环岛，如果单摄像头或者单电磁入环不稳定，可以考虑两个加权，达到较稳定状态，就可以跑得不错。 总的来说可以是，电感阈值 || 摄像头环岛检测 来判断环岛 (有上帝之光摄像头环岛识别不良) 之后电磁入环还是摄像头入环就要个人考虑了 感觉有用的话，点个赞再走呗！]]></content>
      <categories>
        <category>NXP智能车</category>
      </categories>
      <tags>
        <tag>NXP智能车</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C语言】C语言学习整理-putchar,printf，getchar，scanf定义及区别]]></title>
    <url>%2Fposts%2F51464%2F</url>
    <content type="text"><![CDATA[1.定义 花一点时间认真阅读，这篇文章应该会让您多理解一点东西。 1.getchargetchar函数是字符输入函数，其功能是从键盘上获取一个输入字符。 读取方式： 从stdio(输入)流中读字符，相当于getc(stdin），它从标准输入(键盘)里读取下一个字符。，返回值为用户输入的ASCⅡ码，出错返回-1，用户输入的字符被存放在键盘缓冲区中.直到输入回车键才从缓冲区依次提取字符，当用户键入回车之后,getchar会从输入流中读取第一个字符， 注意： 1.getchar只能输入一个字符。如果你输入多个字符，它只接受第一个字符。 _2._如果输入流缓冲区中没有数据，那么getchar就会处于等待状态，从而使程序窗口停留。这也是为什么getchar可以作为暂停函数的原因， 2.scanfscanf（）函数是格式输入函数，即按用户指定的格式从标准输入设备(键盘) 上把数据输入到指定地址的变量中。 读取方式： 一般格式为：scanf（格式控制，地址列表） 也就是scanf(“%?”,&amp;?); 可以读取相对于类型的数值并且存储到制定变量，并且可以读取多个数值，如数字，字符，字符串等 注意： scanf()在读取数字时会跳过空格、制表符和换行符！ 两者区别：1.scanf返回成功赋值项个数，并将数值赋值到指定参数上，而getchar只读取一个字符并返回其ascii码，并且可以赋值也可以不赋值。 123scanf(&quot;%d&quot;,&amp;a);getchar();ch = getchar(); //两者都正确 2.结束输入的方式不同 scanf遇到 回车(enter)，空格，TAB 就会结束一次输入，空格不会接收 getchar函数只以回车Enter结束输入，接受空格符。 3. scanf在一次输入结束后，不会舍弃最后的回车符（即回车符会残留在缓冲区中） getchar回车作为结束的标志，所以在敲回车时’\n’也被存入缓存 看下面的程序： 123#include &lt;stdio.h&gt;int main()&#123; char c1,c2; scanf(&quot;%c %c&quot;,&amp;c1,&amp;c2); //这里有一个空格 printf(&quot;%d %d\\n&quot;,c1,c2); scanf(&quot;%c%c&quot;,&amp;c1,&amp;c2); printf(&quot;%d %d\\n&quot;,c1,c2); return 0;&#125; 第一次输入a和b正常，没有问题，但是第二次就出现问题了， scanf单字符输入时规定只接收一个字符，所以第一次输入a b 时 ，第一个scanf(“%c %c”）之间有一个空格，所以在输入字符a之后，我们可以输入空格，enter，，scanf都会自动忽略它(那个空格会读取停止字符并释放掉)，所以第一次输入正常，但它却把回车符也作为字符对待的。在我们输入完b之后按回车(Enter)，这个回车符是放在缓冲区的，并且不会舍弃最后的回车符 第二次调用scanf(“%c%c”,&amp;c1,&amp;c2);是从缓冲区中取两个字符，首先把第一次调用scanf(“%c%c”,&amp;c1,&amp;c2);后输入的回车当作输入字符赋值给c1 ，之后把a赋值给了c2 这就在输入逻辑上造成了混乱。 我们这样改一下 1234#include &lt;stdio.h&gt;int main()&#123; char c1,c2; scanf(&quot;%c %c&quot;,&amp;c1,&amp;c2); //这里有一个空格 printf(&quot;%d %d\\n&quot;,c1,c2); scanf(&quot; %c %c&quot;,&amp;c1,&amp;c2); //这里也有了空格 printf(&quot;%d %d\\n&quot;,c1,c2); return 0;&#125; 这下就会正确了 scanf(“ %c”,&amp;c)这个空格（换成\n或者\t也可以），这样就把缓冲区中的回车当成第一个字符，读取后丢掉 可以很好理解： 空格( )即为读取一个结束字符然后丢掉，而普通的字符不受影响 用好之后可以避免很多程序BUG 当然我们也可以用getchar()来把之前的缓冲区里的回车删除掉，而不用 (空格) 这是getchar()的常用用法之一 123456#include &lt;stdio.h&gt;int main()&#123; char c1,c2; scanf(&quot;%c %c&quot;,&amp;c1,&amp;c2); //这里有一个空格 printf(&quot;%d %d\\n&quot;,c1,c2); getchar(); //吸收回车缓存 scanf(&quot;%c %c&quot;,&amp;c1,&amp;c2); //这里也有了空格 printf(&quot;%d %d\\n&quot;,c1,c2); return 0;&#125; 再来一个下方加深理解： 1234#include &lt;stdio.h&gt;char c1\[10\],c2\[10\];int main()&#123; scanf(&quot;%s&quot;,&amp;c1); printf(&quot;%s\\n&quot;,c1); scanf(&quot; %s&quot;,&amp;c2); printf(&quot;%s&quot;,c2); return 0;&#125; 若输入Hello World！的时候有空格 结果为下方： 输入完Hello World！之后按回车(Enter)直接执行完毕 因为在你输入Hello World！并且按下Enter(回车)的时候，Hello World！和Enter(回车)都会被送入到输入流缓冲区 而第一个scanf读取时遇到 空格 直接停止读取，所以c1为Hello 这时候第一个空格被释放 而第二个scanf继续从输入流缓冲区读取剩下的数据(World！)在读取完！之后有一个Enter(回车) 停止读取，直接执行Printf 程序运行完毕 4.scanf()在读取数字时会跳过空格、回车(Enter)、制表符和换行符！ getchar函数只能输入字符型,输入时遇到回车键才从缓冲区依次提取字符。 看下面的程序： 1234#include &lt;stdio.h&gt;int main()&#123; int c1,c2; scanf(&quot;%d%d&quot;,&amp;c1,&amp;c2); //没有空格 printf(&quot;%d %d\\n&quot;,c1,c2); scanf(&quot;%d%d&quot;,&amp;c1,&amp;c2); //没有空格 printf(&quot;%d %d\\n&quot;,c1,c2); return 0;&#125; 输出结果正常，因为会自动跳过空格、回车(Enter)来进行读取 技能提升：1getsgets()以Enter结束输入，但可以接受空格，会舍弃最后的回车符！并且gets()可以读取多个字符，就像%c字符与getchar()对应 而%s字符串与gets()对称 需要用getchar()吃掉回车的几种情况： 前面有scanf 后面也要用scanf()时，中间要用一个空的getchar（）吃回车； 前面有scanf，后面要用ch=getchar()接收字符时，中间要用一个空的getchar（）吃回车； 2个ch=getchar()中间需要一个空的getchar()吃回车。 putchar于printf这两个函数其实区别很明显，我们简单介绍下，明天还要交作业。。。i 1putchar1 定义 putchar(a)向终端输出一个字符。，其中a可以是被单引号）引起来的一个字符[putchar(‘e’)]，可以是介于0~127之间的一个十进制整型数（包含0和127）[putchar(23)] ，也可以是事先用char定义好的一个字符型变量 并且只能输出单个字符，于getchar()相对应 2printf()1 定义 格式化输出函数, 用于向标准输出设备按规定格式输出信息， 并且可以输出各种数据类型，还可以有参数，而putchar只能输出一个字符 1如printf(&quot;%c&quot;,&apos;A&apos;) 相当于 putchar(&apos;A&apos;); 区别：其实这两个都很容易理解了，并且区别也很明显，这里我们只做下简单讨论 *1.putchar会有返回值，并且返回值为()内参数值 *转换为的unsigned int 值 如果遇到错误或者文件结束，putchar() 返回EOF 而printf()函数返回值为字符串的长度。 1234int a=104;printf(%d&quot;,a); //printf将返回3，printf(&quot;123\\n&quot;); //printf将返回4 技能提升：puts()：只能输出字符串 功能是将字符串输出到屏幕。输出时只有遇到 ‘\0’ 也就是字符串结束标志符才会停止 并且puts()在使用完之后会自动换行 等效于printf(“%s\n”,s) puts()函数的返回值为0 习题演练：在学习完之后，就来几道题巩固一下吧！ （1） c1与c2字符型与整数型皆可， 原因： 我们学习知道getchar返回的是字符的ASCⅡ码，而c1，c2若为字符型。则分别对应相对于字符，若为整数型则为对应ASCⅡ码 在用 printf(&quot;%c %c\\n&quot;,c1,c2); putchar(c1); putchar(c2);输出的时候，字符型直接输出，而整数型的c1，c2 因为是%c和 putchar只能输出字符，会被转换为相对应ASCⅡ码值的字符输出 （2）应用printf(“%d %d\n”,c1,c2); 并且c1与c2字符型与整数型皆可 原因：%d为输出整数型，若 c1,c2为字符型，用%d会输出相对应的ASCⅡ码值，若为整数型直接输出 （3）不可以 原因： char的范围是ASCII码范围：有符号char -128 ~ 127 无符号unsigned char ：0 ~ 255 int的范围是-32768 ~ 32767 并且字符型为一个字节（无符号的为两个），一个字节转两个没问题，两个转一个就可能出现溢出问题。比如 char a=255,就会溢出，因为有符号字符表达的范围只是-128~127]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【c语言】关键字存储类型讲解(auto,extern,static,register,const]]></title>
    <url>%2Fposts%2F35548%2F</url>
    <content type="text"><![CDATA[渣渣C的学习之路用最简单的话，让你最快速明白！ C语言中，每一个变量和函数都有2个属性：数据类型和数据的存储类别。C的存储类别有4种：自动的（auto）、静态的（static）、寄存器的（register）、外部的（extern）。变量的存储类别对应变量的作用域与生命周期。 1.externextern外部声明，简单来说：你如果要在a.c中使用b.c的一个变量avg，直接使用是会报错的，这时候我们便需要用 *extern int avg; 在a.h中声明avg，这样就可以引用avg了 * 当然你要保证avg是一个全局变量，局部变量不能用extern的修饰，且局部变量在运行时才在堆栈部分分配内存。 注意事项：1.外部声明可以多次，定义只能一次 简单来说就是avg只能定义一次，但是可以有很多外部声明 1extern int a;//声明一个全局变量aint a; //定义一个全局变量aextern int a =0 ;//定义一个全局变量a 并给初值。int a =0;//定义一个全局变量a,并给初值， int a 等于 extern int a，都是定义一个可以被外部使用的全局变量，并给初值。但是注意定义只能出现在一处。不管是int a;还是extern int a=0;还是int a=0;都只能出现一次，而extern int a，extern a可以出现很多次。 2.用extern声明外部变量时，类型名可写可不写，如”extern int num;”也可以写成”extern num;”。因为它不是定义变量，可以不指定类型，只许写出外部变量名即可 3.变量如果只是用到声明，放在.h中就行了；*如果声明的同时并定义一个全局变量的话，在.h里用extern声明，并在对应的.c里定义。其它的.c文件直接include“xx.h”就行了 * // ---- Math.h —-extern “C”;// ---- Math.C —-int “C”; // ---- Add.c —- #include “Math.h” C=5;// C 可以从被调用 这样子是不是很方便！ 2.*auto *auto被解释为一个自动存储变量的关键字，也就是申明一块临时的变量内存。函数中的形参和在函数中定义的局部变量（包括符合语句中的局部变量）都属于此类。如 函数中定义变量 int a; 和 auto int a; 是等价的，关键字“auto”是默认省略的，此关键字很少使用 注意事项： 1.auto是定义局部变量，即只能在定义的范围内使用（一般就是在花括号里{}）全局变量默认说明符为extern。 2.auto变量在离开作用域是会变程序自动释放，不会发生内存溢出情况（除了包含指针的类）使用auto变量的优势是不需要考虑去变量是否被释放，比较安全。（局部变量） 3.auto不能作为函数的参数 4. auto不能直接用来声明数组 3.static*这个关键字很重要，我们需要对他很了解 * 我们分为几点来介绍他 1. 我们知道局部变量在调用完之后就会销毁，而我们有时希望函数中的局部变量的值在函数调用结束后不消失而继续保留原值，即其占用的存储单元不释放，在下一次再调用该函数时，该变量已有值（就是上一次函数调用结束时的值）。这时就应该指定该局部变量为“静态局部变量”，用关键字static进行声明。 2.static在修饰全局变量时，该变量只能在当前文件中使用，其他文件无法访问和使用，即时用extern声明也是无效的，但是可以在多个文件中定义同一个名字的变量，不会受到影响 静态函数只能在声明它的文件中可见，其他文件不能引用该函数 不同的文件可以使用相同名字的静态函数，互不影响 static避免多个文件使用了相同的变量名而导致冲突, 比如有多个文件，分别由几个人独立开发的。假定他们在各自的文件中定义相同的“全局”变量名（仅仅指在他们独自的文件中全局），当系统集成时，由于他们使用了名字一样的“全局”变量，导致有难于遇见的问题。解决这个问题方便的做法就是在各自文件中，在相同的全局变量申明前加上static修饰符。这样系统就会为他们分配不同的内存，互不影响了。 3.static修饰一个函数，则这个函数同样只能在本文件中调用，不能被其他文件调用 4.Static修饰的局部变量存放在全局数据区的静态变量区。初始化的时候自动初始化为0； 并且在程序执行期间不销毁，程序执行完成之后才销毁(在静态存储区，内存中所有字节默认都是0x00) 下面是中兴通讯2012校招笔试题的一道问答题： 1. static全局变量与普通的全局变量有什么区别 ? 全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。 全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。 这两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。 static全局变量只初使化一次，防止在其他文件单元中被引用; ** static局部变量和普通局部变量有什么区别 ？** 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。 static局部变量只被初始化一次，下一次依据上一次结果值； ** static函数与普通函数有什么区别？** static函数与普通函数作用域不同,仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static修饰的函数)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件. 4.registerregister变量表示将变量存储在CPU内部寄存器中，而不是单纯地寻址访问，这样可以提高运算速度和效率， 那么有的同学可能要问，为什么寄存器比寻址访问要快呢？我们首先要知道，CPU是不会直接和内存打交道的，他是会通过寄存器跟内存打交道，数据从内存里拿出来先放到寄存器，然后CPU 再从寄存器里读取数据来处理，处理完后同样把数据通过寄存器存放到内存里， 寄存器是内存阶层中的最顶端 简单来说习大大要处理政务了，那么他是会从各个国家部部长哪里获取信息吧，而不是直接问每个县的县长或者村长获取信息，那么这里CPU就是习大大，通过寄存器(各个国家部门部长)，来对内存进行寻址访问(各个地方的各种事务)， 正是有着各种各样各自功能的寄存器(很多部门)，负责着不同的工作处理，然后汇报给CPU(习大大)，这样程序才能正常进行(国家才能正常运转)， 这样我们可以知道，寄存器其实就是一块一块小的存储空间，只不过其存取速度要比内存快得多。进水楼台先得月嘛，它离CPU 很近，所以寄存器变量(国家大事)，也就是要优先处理啦。 注意事项：1.register只是请求寄存器变量，不一定能够成功， 我们知道寄存器是有限的(各个部门)，如果定义了很多register变量，可能会超过CPU的寄存器个数，超过容量，(各个部门政务超负载了)这时候就没有办法都变为寄存器变量了，这个数量主要看机器性能决定 2.register变量必须是能被CPU所接受的类型。 这通常意味着register变量必须是一个单个的值，并且长度应该小于或者等于整型的长度。不过，有些机器的寄存器也能存放浮点数。 (这个我们很容易理解，不是什么事都能作为国家大事的) 3.因为register变量可能不存放在内存中，所以不能用“&amp;”来获取register变量的地址。 4.用register修饰的变量只能是局部变量，不能是全局变量。CPU的寄存器资源有限，因此不可能让一个变量一直占着CPU寄存器 (领导人不可能一直只处理一件事情) 5.register修饰符暗示编译程序相应的变量将被频繁地使用，如果可能的话，应将其保存在CPU的寄存器中，所以请注意，**.register仅仅是暗示而不是命令**。 这就好比寄存器（部长）可以说明这件事比较重要，但是不能直接命令CPU(领导人)去做一件事 6.局部静态变量不能定义为寄存器变量。不能写成：register static int a, b, c; 虽然它被称作最近快的变量，但是也是比较不安全的变量，现在使用不多 5.const我对这个关键字一直抱有敬畏之心，因为之前看过一位某国企面试官对面试者提问const时的博客，就一直感觉很有文章 简单来说：我们在写程序时，如果需要让一个变量保持不变，不能被修改，那就用const来修饰 const 是 constant 的缩写，意思是“恒定不变的”！ 以下两种定义是相同的 1const int a = 6; 1int const a = 6; 用 const 定义的变量的值是不允许改变的，即不允许给它重新赋值，即使是赋相同的值也不可以,所以在定义常量的时候要先给他初始化(赋值) ，后面任何修改的操作都是错误的 const和指针12int main()&#123; const int a; int const b; const char \*c; char \*const d; const char * const e; return 0;&#125; 看上面代码， a和b是相同的 对于c来说 const在左边* 表示c所指向的内存地址不可改变，即c只能指向一个固定地址，但是地址中的值是可以修改的** 对于d来说，指针是只读的，也就是 d 本身的值不能被修改，但是它所指向的内存空间是可以被修改的。 对于e来说，不能做任何修改， 常量：固定值 变量：可以变化的量 我们知道，数组的长度不能是变量。虽然 const 定义的是只读变量，就相当于是定义一个常量。但是只读变量也是变量，所以 const 定义的变量仍然不能作为数组的长度 请注意只读这两个字，可以说是精华所在 能力提升：用 const 修饰的变量，无论是全局变量还是局部变量，生存周期都是程序运行的整个过程。全局变量的生存周期为程序运行的整个过程这个是理所当然的。而使用 const 修饰过的局部变量就有了静态特性，它的生存周期也是程序运行的整个过程。我们知道全局变量是静态的，静态的生存周期就是程序运行的整个过程。但是用const修饰过的局部变量只是有了静态特性，并没有说它变成了静态变量。 我们知道，局部变量存储在栈中，静态变量存储在静态存储区中，而经过 const 修饰过的变量存储在内存中的“只读数据段”中。只读数据段中存放着常量和只读变量等不可修改的量。 有兴趣同学可以参考 《单片机的内存分配》 来学习一下 都看到这儿了，点个赞再走呗！]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【STM32】STM32 LCD12864 串行通信模式 (从原理让你理解)]]></title>
    <url>%2Fposts%2F690%2F</url>
    <content type="text"><![CDATA[lcd12864简介带中文字库的128X64是一种具有4位/8位并行、2线或3线串行多种接口方式，内部含有国标一级、二级简体中文字库的点阵图形液晶显示模块；其显示分辨率为128×64，内置8192个16*16点汉字，和128个16*8点ASCII字符集。利用该模块灵活的接口方式和简单、方便的操作指令，可构成全中文人机交互图形界面。可以显示8×4行16×16点阵的汉字。也可完成图形显示。低电压低功耗是其又一显著特点。由该模块构成的液晶显示方案与同类型的图形点阵液晶显示模块相比，不论硬件电路结构或显示程序都要简洁得多，且该模块的价格也略低于相同点阵的图形液晶模块。 注： 我们所用的LCD屏的命名，基本都是按照其分辨率来进行命名的 比如lcd1602 就是分辨率为16×2 lcd128128 就是分辨率为128×128 lcd12864基本特性参数（1）低电源电压（VDD：+3.0–+5.5V） （2）显示分辨率：128×64点 （3）内置汉字字库，提供8192个16×16点阵汉字（简繁体可选） （4）内置128个16×8点阵字符 （5）2MHZ时钟频率 （6）显示方式：STN、半透、正显 （7）驱动方式：1/32DUTY，1/5BIAS （8）视角方向：6点 （9）背光方式：侧部高亮白色LED，功耗仅为普通LED的1/5—1/10 （10）通讯方式：串行、并口可选 （11）内置DC-DC转换电路，无需外加负压 （12）无需片选信号，简化软件设计 （13）工作温度：0℃-+55℃，存储温度：-20℃-+60℃ lcd12864引脚图及功能 我们所用的为串口通信模式，所以仅介绍下串行所用管脚 引脚： 1 VSS 电源负极 2 VDD 电源正极 *4 CS 片选引脚 高电位可接受数据，低电位锁存 * 5 SID 串行数据输入端 *6 CLK 串行同步时钟 * 可选引脚： 3 V0 调节屏幕亮度 15 PSB 低电平有效 其中低电平为串口方式 ** 如果只用串口通信模式 **可以将PSB引脚飞线与地线相连 即固定低电平 17 RESET 复位引脚 低电平可使LCD复位 19 A LCD背光源的电源 20 K LCD背光源的地 如果需要背光 可以将19引脚与LCD2引脚电源正极相连，20引脚与LCD1引脚电源地相连 串行模式下传输过程 1.首先CS片选一直为高电平期间,LCD可接受数据或指令, 2.随后，单片机要给出数据传输起始位，这里是以5个连续的“1”作数据起始位，如模块接收到连续的5个“1”，则内部传输被重置并且串行传输将被同步。 3.紧接的两个位指定传输方向（RW，用于选择数据的传输方向 ，1是读数据，0是写数据）以及传输性质（RS，用于选择内部数据寄存器或指令寄存器，0是命令寄存器，1是数据寄存器） **最后的第8位固定为“0”。 到此第一个字节 /数据传输起始位**发送完成。 4.在接收到起始位及“RW”和“RS”的第1个字节后，之后便开始传输指令或者数据，在传输过程中会进行拆分处理，该字节将被分为2个字节来传输或接收。 5.你想发送的数据或指令的高4位，被放在发送的第2个字节串行数据的高4位，其低4位则置为“0”；数据或指令的低4位被放在第3个字节的高4位，其低4位也置为“0”，如此完成一个字节指令或数据的传送。 (D7-D0) 比如说你想发送的数据为“A” 对应16进制0x41 对应二进制 0100 0001‬ 那么发送的顺序就是： 1 先发送0xFA (11111 010) 五个1 RW=0 RS=1 ， 2 发送0100 0000 高四位为“A”对应的高四位 低4位补0 3发送0001‬ 0000 高四位为“A”对应的低四位 低4位补0 到此一个字节发送完成 所以写指令之前，必须先发送 11111 000 （即0xF8）写数据之前 必须先发送 11111 010 （即0xFA） 而如何实现字符的拆分呢？ 参考：《C语言运算符与操作符的用法全面汇总(非常有用)》 将字符“A”的低四位清零 保留高四位 可以做“A”&amp;240( 0xf0) ** 0100 0001‬——————“A”的二进制数** ** 1111 0000‬——————240的二进制数** ** ——————** ** 0001 0000 保留了“A”的高四位** 将字符“A”的低四位变为高四位 可以用&lt;&lt;(左移运算符) A&lt;&lt;4 ** 0100 0001‬——————“A”的二进制数 ** ** 0001 0000 ‬——————保留了“A”的低四位** 6 完成一个字节数据的发送需要24个时钟周期 因为1个字节实际是发送了3个字节 (3x8) 7.只有在时钟线SCLK拉低时，数据线SID上的数据才允许变化，在时钟线SCLK高电平时，SID上的数据必须保持稳定(不能变化) 这点与IIC是相同的 LCD内部资源/显示原理** LCD的控制芯片为ST7920 ，ST7920有丰富的内部资源，并且内部的ROM已经固化存储了中文字库，半角英文/数字字符** 也就是自带中文字库 ST7920的内部资源： 提供8 位，4 位并行接口及串行接口可选 自动电源启动复位功能 内部自建振荡源 1、ST7920 内部固化了8192 个16×16 点阵的中文字型在CGROM(2M 位中文字型ROM)里。2、固化有126 个16*8 点阵的半角英文/数字字符(ASCII)在HCGROM里。 3、提供4个16×16点阵自造字符的存储空间CGRAM(字形产生RAM)。4、提供128×64的点阵绘图共1024个字节的存储空间GDRAM(点阵绘图RAM)。5、提供1个16×15点阵图标的存储空间IRAM（ICON RAM） *6、64×16 位字符显示RAM *（DDRAM 最多16 字符×4 行) 那么在LCD上显示字符或者汉字是怎么实现的呢： LCD显示原理： 作为字符显示，在控制器内有个供写入字符代码的缓存器DDRAM ，你只要将要显示的中文字符编码或其他字符编码写入DDRAM(显示数据)，也就是串行模式下发送一个字节数据，硬件将依照编码自动从CGROM(2M 中文字型ROM) **HCGROM(16K ASCII码ROM) CGRAM(自定义字形RAM**）三种字形中自动辨别选择对应的是那种字形的哪个字符/汉字编码，再将要显示的字符/汉字编码显示在屏幕上。 也就是字符显示是通过将字符显示编码写入字符显示RAM(DDRAM )实现的 模块内部的RAM提供64×16的显示空间 ，最多可以显示4行8字(32个汉字)或64个ASCII码字符的显示 一个汉字2个字节 DDRAM一共有32个字符显示区域，当然，字符显示的RAM的地址与32个字符显示区域有着一一对应的关系 字符显示时，DDRAM地址与液晶屏的位置： 通过写入不同的地址，就可以实现字符显示的不同位置 LCD控制指令LCD12864提供了两套控制命令，分别为基本指令和扩展指令 ，涉及到了LCD的清屏，开关，显示字符位置等等 其实也就是向LCD写入特殊字符而已 ，根据RS和RW可以判断指令方式 下面我们介绍几个常用的： *1清屏 * 清除屏幕字符 ，也就是对整块屏幕写入空字符 并且将游标移到开始位置 在使用清屏时，需要加上一定的延时等待液晶稳定 RS RW D7 D6 D5 D4 D3 D2 D1 D0 0 0 0000 0001 2显示状态开关 其中第6位置1打开显示，第7位与第8位对应游标相关设置 一般配置为 0X0C //显示器开，光标关闭，不反白 RS RW D7 D6 D5 D4 D3 D2 D1 D0 0 0 0 0 0 0 1 1/0 1/0 1/0 3功能设定 DL = 0/1 : 4/8位数据 我们是使用8位 所以为1 RE=1时，使用扩充指令集，RE=0时，使用基本指令集，我们正常使用基本指令集 所以RE需要为0 一般配置为 0X30 // 基本指令集 8bit数据流 RS RW D7 D6 D5 D4 D3 D2 D1 D0 0 0 0 0 1 1/0 任意 1/0 任意 任意 4游标功能设置 进入点设定 ： 是表示在写入或者读取的时候，游标相对于上一个位置的移位 不设置即默认对地址加1(移1位) 如果你想要字符之间有空隙 可以修改移位 游标的位置移动设置，写入相对应的数据即可改变游标位置，实现LCD界面的书写， 32个字符显示区域对应32个地址 5读取BF忙标志和地址 忙标志BF: BF标志提供内部工作状况，BF=1表示模块内部正在进行操作，此时模块不接受指令和数据. BF=0 模块为准备接受状态，可以接受指令和数据 6读/写数据 就是进行数据的读写， 写数据： RS RW D7 D6 D5 D4 D3 D2 D1 D0 1 0 8bit数据 读数据： RS RW D7 D6 D5 D4 D3 D2 D1 D0 1 1 8bit数据 7 CGRAM(自定义字形RAM)设置 设定该地址即可自定义字形编码，在显示图片时会先将图片编码写入这里，然后再读它进行显示 LCD初始化 我们把它分为6步分别讲解 1.在开电之后，首先要等待40ms以上，等待液晶自检，使LCD系统复位完成 2. 之后便是功能的设定 选择基本指令集或者扩充指令集 随后延时等待100us以上 3. 功能设定2 选择8bit数据流 或者 4bit数据流 随后延时37us以上 4. 开关显示 是否打开显示开关 随后延时100us以上 5.清屏 清空RAM并初始化光标位置 随后延时10us以上 进入模式选择 也就是设定*游标相对于上一个位置的移位 默认为地址自动+1 * 之后初始化完成，可以对LCD进行数据的写入或读取 当然第二步与第三布写入数据是相同的，可以只写一次然后延时137us以上也可 LCD图片显示 LCD12864在地址的排列上是分为上、下半屏来显示的，上半屏横向的列地址（X）是0－7(00h-07h)，下半屏的列地址是8－15(08h-0fh)。而每个一地址都可写入两个字节的内容，它们是按高位在前低位在后排列的。垂直方向上的地址（Y）上半屏是0－31(00h-1fh)，下半屏的Y地址仍是0－31(00h-1fh) 也就是一幅图片写入时垂直坐标Y要写64次 (上下屏) 水平横向坐标X要写8次 在每两个字节写入后时候就要重新设置垂直地址，再设置水平地址(连续写入两个字节确定X,Y地址) 然后再写图片的正常编码 这样便可以实现一幅图像的写入 简单说就是对每个位置写入图片的相对于位置的编码 图片显示的步骤 1切换到扩充指令2 关闭绘图显示功能 3 先将垂直的坐标(Y)写入CGRAM地址4 再将水平的位元组坐标(X)写入CGRAM地址5 将高位字节**D15－D8写入RAM中6 将低位字节D7－D0写入到RAM中** 重复3-6步，完成图片各个部分的写入 先写上半屏，再写下半屏 7 打开绘图显示功能 8切换回基本指令 其实也就是先打开CGRAM(自定义字形RAM） 然后把定义好的图片编码写入CGRAM 然后再对DDRAM正常写入该图片编码， 这时硬件将依照编码从CGRAM(自定义字形RAM）读取之前写入的图片编码，然后显示该图片 具体看代码即可 注意事项：用带中文字库的128X64显示模块时应注意以下几点： PS： 图片显示之后需要加上延时，否则会持续写入，不会有图片显示 ** 图片写入CGRAM(自定义字形RAM)时必须要先写垂直地址坐标，再写水平地址坐标** ①欲在某一个位置显示中文字符时，应先设定显示字符位置，即先设定显示地址，再写入中文字符编码。 ②显示ASCII字符过程与显示中文字符过程相同。不过在显示连续字符时，只须设定一次显示地址，由模块自动对地址加1指向下一个字符位置，否则，显示的字符中将会有一个空ASCII字符位置。 ③当字符编码为2字节时，应先写入高位字节，再写入低位字节。 ④模块在接收指令前，向处理器必须先确认模块内部处于非忙状态，即读取BF标志时BF需为“0”，方可接受新的指令。如果在送出一个指令前不检查BF标志，则在前一个指令和这个指令中间必须延迟一段较长的时间，即等待前一个指令确定执行完成。指令执行的时间请参考指令表中的指令执行时间说明。 ⑤“RE”为基本指令集与扩充指令集的选择控制位。当变更“RE”后，以后的指令集将维持在最后的状态，除非再次变更“RE”位，否则使用相同指令集时，无需每次均重设“RE”位。 到此，LCD的串行通信就讲的差不多了，可以结合着代码篇博客，学习完对应相关原理，然后查看相对应代码，可以更好地理解 如果需要查看代码请移步到下一篇博客：《STM32驱动 LCD12864程序代码(串行方式)》]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【STM32】STM32驱动 LCD12864程序代码(串行方式)]]></title>
    <url>%2Fposts%2F34132%2F</url>
    <content type="text"><![CDATA[引言：这里我们只讲解接线和代码实现，具体的原理在上一篇博客中已经讲解，如果想了解具体原理可以查看上一篇博客 《STM32 LCD12864 串行通信模式 (从原理让你理解)》 下方代码的实现也是基于上一篇的讲解顺序来的 设备： STM32F407ZGT6 引脚接线： VSS——GND VDD——VCC(5V or 3.3V) V0 亮度调节 不接 CS ——接VCC，持续高电平，一直选通。 SID ——接PE1 SCLK ——接PE0 PSB——接GND 串行模式 或者飞线与1脚相连 BLA——VCC(5V or 3.3V) 或者飞线与2脚相连 BLK——接GND 或者飞线与1脚相连 剩余引脚不接，留空 这样我们最少只会用到4根线 VCC电源 GND地线 SID串行输入 SCLK 时钟 便可以实现串行通信 代码实现：LCD写入一个字节：123456789101112131415161718192021222324252627282930313233343536373839404142#define WRITE\_CMD 0xF8//写命令 #define WRITE\_DAT 0xFA//写数据/*! * @brief LCD串行发送一个字节 * @since v1.0 * @param byte 写入字节 * @author Z小旋 */void SendByte(u8 byte)&#123; u8 i; for(i = 0;i &lt; 8;i++) &#123; if((byte &lt;&lt; i) &amp; 0x80) //0x80(1000 0000) 只会保留最高位 &#123; SID = 1; // 引脚输出高电平，代表发送1 &#125; else &#123; SID = 0; // 引脚输出低电平，代表发送0 &#125; /*或 SID = (Dbyte &lt;&lt; i) &amp; 0x80; 上面那样为了方便理解 */ SCLK = 0; //时钟线置低 允许SID变化 delay_us(5); //延时使数据写入 SCLK = 1; //拉高时钟，让从机读SID &#125; &#125;/*! * @brief LCD写指令 * @since v1.0 * @param Cmd 要写入的指令 * @author Z小旋 */void Lcd_WriteCmd(u8 Cmd )&#123; delay_ms(1); //由于我们没有写LCD正忙的检测，所以直接延时1ms，使每次写入数据或指令间隔大于1ms 便可不用写忙状态检测 SendByte(WRITE_CMD); //11111,RW(0),RS(0),0 SendByte(0xf0&amp;Cmd); //高四位 SendByte(Cmd&lt;&lt;4); //低四位(先执行&lt;&lt;)&#125;/*! * @brief LCD写数据 * @since v1.0 * @param Dat 要写入的数据 * @author Z小旋 */void Lcd_WriteData(u8 Dat )&#123; delay_ms(1); //由于我们没有写LCD正忙的检测，所以直接延时1ms，使每次写入数据或指令间隔大于1ms 便可不用写忙状态检测 SendByte(WRITE_DAT); //11111,RW(0),RS(1),0 SendByte(0xf0&amp;Dat); //高四位 SendByte(Dat&lt;&lt;4); //低四位(先执行&lt;&lt;)&#125; 向LCD发送一个字节，也就是SID引脚相对于高低电平 高电平=1 低电平=0 同时时钟线变化，使得数据可以读取和发送 结合第一篇原理介绍即可理解。 关于&amp;运算与&lt;&lt; 参看 《C语言运算符与操作符的用法全面汇总(非常有用)》 LCD初始化：这里为了方便移植，将GPIO的初始化与LCD初始化分为两个，使用时根据自己的引脚只修改GPIO初始化即可 宏定义和GPIO初始化： 12345678910111213141516171819202122#define WRITE\_CMD 0xF8//写命令 #define WRITE\_DAT 0xFA//写数据//接口(SID: PE1 SCLK: PE0) #define SID PEout(1)#define SCLK PEout(0)/*! * @brief GPIO_init * @since v1.0 * @param None * @author Z小旋 * 使用时自行修改这里的初始化即可 */void lcd\_GPIO\_init()&#123; GPIO\_InitTypeDef GPIO\_InitStructure; RCC\_AHB1PeriphClockCmd(RCC\_AHB1Periph_GPIOE, ENABLE);//使能GPIOE时钟 //GPIOE0,E1初始化设置 GPIO\_InitStructure.GPIO\_Pin = GPIO\_Pin\_0 | GPIO\_Pin\_1; GPIO\_InitStructure.GPIO\_Mode = GPIO\_Mode\_OUT;//普通输出模式 GPIO\_InitStructure.GPIO\_OType = GPIO\_OType\_PP;//推挽输出 GPIO\_InitStructure.GPIO\_Speed = GPIO\_Speed\_100MHz;//100MHz GPIO\_InitStructure.GPIO\_PuPd = GPIO\_PuPd\_NOPULL;//无上拉 GPIO\_Init(GPIOE, &amp;GPIO\_InitStructure);//初始化 SID=1; SCLK=1;&#125; 根据不同的型号和管脚修改对应初始化即可 LCD初始化： 1234567891011121314/*! * @brief LCD初始化 * @since v1.0 * @param None * @author Z小旋 */void Lcd_Init(void)&#123; delay_ms(50); //等待液晶自检（延时&gt;40ms） Lcd_WriteCmd(0x30); //功能设定:选择基本指令集 ，选择8bit数据流 delay_ms(1);//延时&gt;137us Lcd_WriteCmd(0x0c); //开显示 delay_ms(1); //延时&gt;100us Lcd_WriteCmd(0x01); //清除显示，并且设定地址指针为00H delay_ms(30); //延时&gt;10ms Lcd_WriteCmd(0x06); //每次地址自动+1，初始化完成&#125; LCD写入字符或汉字：1234567891011121314151617181920/* 字符显示RAM地址 4行8列 */uint8\_t LCD\_addr\[4\]\[8\]=&#123; &#123;0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87&#125;, //第一行 &#123;0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97&#125;, //第二行 &#123;0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F&#125;, //第三行 &#123;0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F&#125; //第四行 &#125;;/*! * @brief 显示字符或汉字 * @since v1.0 * @param x: row(0~3) * @param y: line(0~7) * @param str: 要显示的字符或汉字 * @author Z小旋 */void LCD\_Display\_Words(uint8\_t x,uint8\_t y,uint8_t*str)&#123; Lcd\_WriteCmd(LCD\_addr\[x\]\[y\]); //写初始光标位置 while(*str&gt;0) &#123; Lcd_WriteData(*str); //写数据 str++; &#125;&#125; 首先写入DDRAM对应初始游标位置，然后在该位置写入字符串 写一个字节之后，DDRAM对应游标地址就自动+1到下一个游标位置继续写，直到字符串空为止 LCD清屏：12345678910/*! * @brief 清屏函数 * @since v1.0 * @param None * @author Z小旋 */void LCD_Clear(void) &#123; Lcd_WriteCmd(0x01); //清屏指令 delay_ms(2); //延时以待液晶稳定【至少1.6ms】 &#125; LCD显示图片：123456789101112131415161718192021222324/*! * @brief 显示图片 * @since v1.0 * @param *pic 图片地址 * @author */void LCD\_Display\_Picture(uint8_t *img) &#123; uint8_t x,y,i; Lcd_WriteCmd(0x34); //切换到扩充指令 Lcd_WriteCmd(0x34); //关闭图形显示 for(i = 0; i &lt; 1; i++) //上下屏写入 &#123; for(y=0;y&lt;32;y++) //垂直Y写32次 &#123; for(x=0;x&lt;8;x++) //横向X写8次 &#123; Lcd_WriteCmd(0x80 + y); //行地址 Lcd_WriteCmd(0x80 + x+i); //列地址 Lcd_WriteData(*img ++); //写高位字节数据 D15－D8 Lcd_WriteData(*img ++); //写低位字节数据 D7－D0 &#125; &#125; &#125; Lcd_WriteCmd(0x36);//打开图形显示 Lcd_WriteCmd(0x30); //切换回基本指令 &#125; 具体原理可以结合 LCD图片显示 部分查看 这里要注意 在显示一幅图片之后，要加上2s左右延时，否则不会有图片显示 这里再把显示步骤放在下面，方便理解 图片显示的步骤 1切换到扩充指令2 关闭绘图显示功能 3 先将垂直的坐标(Y)写入CGRAM地址4 再将水平的位元组坐标(X)写入CGRAM地址5 将高位字节D15－D8写入RAM中6 将低位字节D7－D0写入到RAM中 重复3-6步，完成图片各个部分的写入 先写上半屏，再写下半屏 7 打开绘图显示功能 8切换回基本指令 使用图片取模软件时要注意 图片取模方式：横向取模，字节正序 到此基本的功能都已经实现了，我把完整的工程代码放到下面，有需要的可以自行下载查看 弄到百度云了，CSDN下载还要钱。。。 链接: https://pan.baidu.com/s/1_OabL-e2mgZebKjjFnW1Ow 提取码: tfxw github： https://github.com/ZXiaoxuan/STM32-LCD12864/tree/ZXiaoxuan 至此，LCD12864完毕， PS: 代码没有任何问题，直接修改GPIO初始化部分即可，如果亮不了，先自行检查，还有查看评论区，看下自己是否有相同问题(供电，接线，F1与F4GPIO初始化不同…等等)，不行就在评论区留言,我看到都会回复帮您解决]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像处理二之----摄像头二值化算法汇总+代码]]></title>
    <url>%2Fposts%2F28885%2F</url>
    <content type="text"><![CDATA[上一节中我们讲解了什么是二值化，并且讲到了二值化的一般方法，那么每种算法究竟是怎么样对图像经行二值化处理的呢？，算法的原理是什么呢，怎么样用代码实现，这节我们分享下。1.otsu（最大类间方差法、大津法） 最大类间方差法是由日本学者大津于1979年提出的,是一种自适应的阈值确定的方法,又叫大津法,简称OTSU。它是按图像的灰度特性,将图像分成背景和目标2部分。背景和目标之间的类间方差越大,说明构成图像的2部分的差别越大,当部分目标错分为背景或部分背景错分为目标都会导致2部分差别变小。因此,使类间方差最大的分割意味着错分概率最小。 阈值将原图象分成前景，背景两个图象。 当取最佳阈值时，背景应该与前景差别最大，关键在于如何选择衡量差别的标准 而在otsu算法中这个衡量差别的标准就是最大类间方差（英文简称otsu，这也就是这个算法名字的来源） 对于图像I(x,y),前景(即目标)和背景的分割阈值记作T,前景图像占整幅图像的比例记为ω0,其平均灰度μ0;背景图像占整幅图像的比例为ω1,其平均灰度为μ1。图像的总平均灰度记为μ,类间方差记为g。M×N = 像素总数,图像中像素的灰度值小于阈值T的像素个数记作N0,像素灰度大于阈值T的像素个数记作N1 ,则有: 前景图像占比 ω0=N0/ M×N (1) 背景图像占比 ω1=N1/ M×N (2) 前景像素+背景像素 N0+N1=M×N (3) 背景图像+前景图像占比 ω0+ω1=1 （4) 0~M灰度区间的灰度累计值 (5) 类间方差值 (6) 将式(5)代入式(6),得到等价公式: (7) 或 采用遍历的方法得到使类间方差最大的阈值T,即为所求。 代码实现：c代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152w0为背景像素点占整幅图像的比例u0为w0平均灰度w1为前景像素点占整幅图像的比例u1为w1平均灰度u为整幅图像的平均灰度类间方差公式 g = w1 * w2 * (u1 - u2) ^ 2int otsuThreshold(int *image, int col, int row)&#123; #define GrayScale 256 int width = col; int height = row; int pixelCount\[GrayScale\] = &#123;0&#125;; //每个灰度值所占像素个数 float pixelPro\[GrayScale\] = &#123;0&#125;;//每个灰度值所占总像素比例 int i, j, pixelSum = width * height; //总像素 int threshold = 0; int* data = image; //指向像素数据的指针 //统计灰度级中每个像素在整幅图像中的个数 for (i = 0; i &lt; height; i++) &#123; for (j = 0; j &lt; width; j++) &#123; pixelCount\[(int)data\[i * width + j\]\]++; //将像素值作为计数数组的下标 &#125; &#125; //遍历灰度级\[0,255\] float w0, w1, u0tmp, u1tmp, u0, u1, u, deltaTmp, deltaMax = 0; for (i = 0; i &lt; GrayScale; i++) // i作为阈值 &#123; w0 = w1 = u0tmp = u1tmp = u0 = u1 = u = deltaTmp = 0; for (j = 0; j &lt; GrayScale; j++) &#123; if (j &lt;= i) //背景部分 &#123; pixelPro\[i\] = (float)pixelCount\[i\] / pixelSum; //计算每个像素在整幅图像中的比例 w0 += pixelPro\[j\];//背景像素点占整个图像的比例 u0tmp += j * pixelPro\[j\]; &#125; else //前景部分 &#123; pixelPro\[i\] = (float)pixelCount\[i\] / pixelSum; //计算每个像素在整幅图像中的比例 w1 += pixelPro\[j\];//前景像素点占整个图像的比例 u1tmp += j * pixelPro\[j\]; &#125; &#125; u0 = u0tmp / w0;//背景平均灰度μ0 u1 = u1tmp / w1;//前景平均灰度μ1 deltaTmp = (float)(w0 \*w1\* pow((u0 - u1), 2)); //类间方差公式 g = w1 * w2 * (u1 - u2) ^ 2 if (deltaTmp &gt; deltaMax) &#123; deltaMax = deltaTmp; threshold = i; &#125; &#125; return threshold; &#125; MATALB代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465close all;clear all;clc;input = imread(&apos;R.png&apos;);%读图input = rgb2gray(input);%灰度转换L = 256;%给定灰度级\[ni, li\] = imhist(input,L); %ni-各灰度等级出现的次数；li-对应的各灰度等级% figure,plot(xi,ni);%显示绝对直方图统计% title(&apos;绝对直方图统计&apos;)\[M,N\] = size(input);%获取图像大小MN = M*N;%像素点总数%%Step1 计算归一化直方图pi = ni/MN; %pi-统计各灰度级出现的概率figure,plot(li,pi);%显示相对直方图统计title(&apos;相对直方图统计&apos;)%%Step2 计算像素被分到C1中的概率P1(k)sum = 0;%用来存储各灰度级概率和P1 = zeros(L,1);%用来存储累积概率和for k = 1:L sum = sum +pi(k,1); P1(k,1) = sum;%累加概率end%%Step3 计算像素至K级的累积均值m(k)sum1 = 0;%用来存储灰度均值m = zeros(L,1);%用来存储累计均值for k = 1:L sum1 = sum1+k*pi(k,1); m(k,1) = sum1;%累积均值end%%Step4 计算全局灰度均值mgmg = sum1;%%Step5 计算类间方差sigmaB2 sigmaB2 = zeros(L,1);for k = 1:L if(P1(k,1) == 0) sigmaB2(k,1) = 0; %为了防止出现NaN else sigmaB2(k,1) = ((mg\*P1(k,1)-m(k,1))^2)/(P1(k,1)\*(1-P1(k,1))); endend%%Step6 得到最大类间方差以及阈值\[MsigmaB2,T\] = max(sigmaB2);%获取最大类间方差MsigmaB2，以及所在位置（即阈值）output = zeros(M,N);%定义二值化输出图像for i = 1:M for j = 1:N if input(i,j)&gt;T output(i,j) = 1; else output(i,j)=0; end endendfigure,imshow(output);%显示结果%%Step7 可分性度量etasigmaG2 = 0;%全局方差for k = 1:L sigmaG2 = sigmaG2+(k-mg)^2*pi(k,1);endeta = MsigmaB2/sigmaG2; 或者直接调用MATALB函数 12345I=imread(&apos;D:\\Images\\pic_loc\\1870405130305041503.jpg&apos;);a=rgb2gray(I);level = graythresh(a);a=im2bw(a,level);imshow(a,\[\]); 缺陷:OSTU算法在处理光照不均匀的图像的时候，效果会明显不好，因为利用的是全局像素信息。 2.灰度平局值法： ** 1、描述:即使用整幅图像的灰度平均值作为二值化的阈值，一般该方法可作为其他方法的初始猜想值。** 原理： 代码实现： 1234567 public static int GetMeanThreshold(int* HistGram) &#123; int Sum = 0, Amount = 0; for (int Y = 0; Y &lt; 256; Y++) &#123; Amount += HistGram\[Y\]; Sum += Y * HistGram\[Y\]; &#125; return Sum / Amount; &#125; 缺点：同样受光线影响较大，但是方法简单，处理快 3.双峰法介绍：如果图像灰度直方图呈明显的双峰状，则选取双峰间的最低谷出作为图像分割的阈值所在。，如下图，以T为阈值进行二值化分，可以将目标和背景分割开。 在一些简单的图像中，物体的灰度分布比较有规律，背景与各个目标在图像的直方图各自形成一个波峰，即区域与波峰一一对应，每两个波峰之间形成一个波谷。那么，选择双峰之间的波谷所代表的灰度值T作为阈值，即可实现两个区域的分割。如下图所示。 代码实现：12345678910111213141516171819202122232425262728int GetIntermodesThreshold(int* HistGram) &#123; int Y, Iter = 0, Index; double* HistGramC = new double\[256\]; // 基于精度问题，一定要用浮点数来处理，否则得不到正确的结果 double* HistGramCC = new double\[256\]; // 求均值的过程会破坏前面的数据，因此需要两份数据 for (Y = 0; Y &lt; 256; Y++) &#123; HistGramC\[Y\] = HistGram\[Y\]; HistGramCC\[Y\] = HistGram\[Y\]; &#125; // 通过三点求均值来平滑直方图 while (IsDimodal(HistGramCC) == false) // 判断是否已经是双峰的图像了 &#123; HistGramCC\[0\] = (HistGramC\[0\] + HistGramC\[0\] + HistGramC\[1\]) / 3; // 第一点 for (Y = 1; Y &lt; 255; Y++) HistGramCC\[Y\] = (HistGramC\[Y - 1\] + HistGramC\[Y\] + HistGramC\[Y + 1\]) / 3; // 中间的点 HistGramCC\[255\] = (HistGramC\[254\] + HistGramC\[255\] + HistGramC\[255\]) / 3; // 最后一点 memcpy(HistGramCC, HistGramC, 256 * sizeof(double)); // 备份数据，为下一次迭代做准备 Iter++; if (Iter &gt;= 10000) return -1; // 似乎直方图无法平滑为双峰的，返回错误代码 &#125;// 阈值为两峰值的平均值 int* Peak = new int\[2\]; for (Y = 1, Index = 0; Y &lt; 255; Y++) if (HistGramCC\[Y - 1\] &lt; HistGramCC\[Y\] &amp;&amp; HistGramCC\[Y + 1\] &lt; HistGramCC\[Y\]) Peak\[Index++\] = Y - 1; return ((Peak\[0\] + Peak\[1\]) / 2); &#125; bool IsDimodal(double* HistGram) // 检测直方图是否为双峰的 &#123; // 对直方图的峰进行计数，只有峰数位2才为双峰 int Count = 0; for (int Y = 1; Y &lt; 255; Y++) &#123; if (HistGram\[Y - 1\] &lt; HistGram\[Y\] &amp;&amp; HistGram\[Y + 1\] &lt; HistGram\[Y\]) &#123; Count++; if (Count &gt; 2) return false; &#125; &#125; if (Count == 2) return true; else return false; &#125; Python代码：12345678910111213#coding:utf-8import cv2import numpy as npfrom matplotlib import pyplot as pltimage = cv2.imread(&quot;E:/python/cv/2ModeMethod/test.jpg&quot;)gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)plt.subplot(131), plt.imshow(image, &quot;gray&quot;)plt.title(&quot;source image&quot;), plt.xticks(\[\]), plt.yticks(\[\])plt.subplot(132), plt.hist(image.ravel(), 256)plt.title(&quot;Histogram&quot;), plt.xticks(\[\]), plt.yticks(\[\])ret1, th1 = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY)plt.subplot(133), plt.imshow(th1, &quot;gray&quot;)plt.title(&quot;2-Mode Method&quot;), plt.xticks(\[\]), plt.yticks(\[\])plt.show() 缺点：当不同区域（即目标）之间的灰度分布有一定的重叠时，双峰法的效果就很差，也就是说，图像为双峰时才能用双峰法 上述代码已经给出判断双峰图的代码 4最佳迭代法迭代法图像二值化的算法思想是：首先，初始化一个阈值Th，然后按照某种策略通过迭代不断更新这一阈值，直到满足给定的约束条件为止。 迭代法是基于逼近的思想，迭代阈值的获取步骤可以归纳如下： （1）求出图象的最大灰度值和最小灰度值，分别记为gl和gu，令初始阈值为： ![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMwLmNuYmxvZ3MuY29tL2Jsb2cvMzQ5MjkzLzIwMTMwOS8wNzExMDA1OS01ODQ5YmYzM2IwYjE0NTRkODk0NjkwZGIzODU1YTIwMi54LXBuZw?x-oss-process=image/format,png) (2) 根据阈值T0将图象分割为前景和背景，分别求出两者的平均灰度值Ab和Af: (3) 令 ![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMwLmNuYmxvZ3MuY29tL2Jsb2cvMzQ5MjkzLzIwMTMwOS8wNzExMDcxMS04MDIwZGIyNDRmMTY0OGUyYTM3MjUyM2FmNDkxYzY5Ny54LXBuZw?x-oss-process=image/format,png)如果Tk=Tk+1,则取Tk为所求得的阈值，否则，转2继续迭代 MATALB代码实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&gt;&gt; clear all%读入图像I=imread(&apos;D:\\Administrator\\My Pictures\\Lenagray.bmp&apos;);%计算灰度的最小值和最大值tmin=min(I(:));tmax=max(I(:));%设定初始阈值th=(tmin+tmax)/2;%定义开关变量，用于控制循环次数ok=true;%迭代法计算阈值while ok g1=I&gt;=th; g2=I&lt;=th; u1=mean(I(g1)); u2=mean(I(g2)); thnew=(u1+u2)/2; %设定两次阈值的比较，当满足小于1时，停止循环 ok=abs(th-thnew)&gt;=1; th=thnew;endth=abs(floor(th));%阈值分割J=im2bw(I,th/255);%结果显示figure(1);imshow(I);title(&apos;原始图像&apos;);figure(2);str=\[&apos;迭代分割：阈值Th=&apos;,num2str(th)\];imshow(J);title(str); 代码实现：123456789101112131415161718192021222324 public static int GetIterativeBestThreshold(int\[\] HistGram) &#123; int X, Iter = 0; int MeanValueOne, MeanValueTwo, SumOne, SumTwo, SumIntegralOne, SumIntegralTwo; int MinValue, MaxValue; int Threshold, NewThreshold; for (MinValue = 0; MinValue &lt; 256 &amp;&amp; HistGram\[MinValue\] == 0; MinValue++) ; for (MaxValue = 255; MaxValue &gt; MinValue &amp;&amp; HistGram\[MinValue\] == 0; MaxValue--) ; if (MaxValue == MinValue) return MaxValue; // 图像中只有一个颜色 if (MinValue + 1 == MaxValue) return MinValue; // 图像中只有二个颜色 Threshold = MinValue; NewThreshold = (MaxValue + MinValue) &gt;&gt; 1; while (Threshold != NewThreshold) // 当前后两次迭代的获得阈值相同时，结束迭代 &#123; SumOne = 0; SumIntegralOne = 0; SumTwo = 0; SumIntegralTwo = 0; Threshold = NewThreshold; for (X = MinValue; X &lt;= Threshold; X++) //根据阈值将图像分割成目标和背景两部分，求出两部分的平均灰度值 &#123; SumIntegralOne += HistGram\[X\] * X; SumOne += HistGram\[X\]; &#125; MeanValueOne = SumIntegralOne / SumOne; for (X = Threshold + 1; X &lt;= MaxValue; X++) &#123; SumIntegralTwo += HistGram\[X\] * X; SumTwo += HistGram\[X\]; &#125; MeanValueTwo = SumIntegralTwo / SumTwo; NewThreshold = (MeanValueOne + MeanValueTwo) &gt;&gt; 1; //求出新的阈值 Iter++; if (Iter &gt;= 1000) return -1; &#125; return Threshold; &#125; 5百分比阈值（P-Tile法）p-tile算法是一种基于灰度直方图统计的的自动阈值选择算法，该算法需要基于一定的先验条件—背景与目标所占的面积比P%。该算法选择阈值的原则是，依次累积灰度直方图，直到该累积值大于或等于前景图像（目标）所占面积，此时的灰度级即为所求的阈值 代码实现：123456789 //HistGram灰度图像的直方图 //Tile背景在图像中所占的面积百分比 int GetPTileThreshold(int* HistGram, int Tile) &#123; int Y, Amount = 0, Sum = 0; for (Y = 0; Y &lt; 256; Y++) Amount += HistGram\[Y\]; // 像素总数 for (Y = 0; Y &lt; 256; Y++) &#123; Sum = Sum + HistGram\[Y\]; if (Sum &gt;= Amount * Tile / 100) return Y; &#125; return -1; &#125; 缺点：该方法简单高效，但是对于先验概率难于估计的图像却无能为力。。条件很苛刻，大部分情况下都用不上6.Niblack二值化算法Niblack二值化算法是比较简单的局部阈值方法，阈值的计算公式是T = m + k*v，其中m为以该像素点为中心的区域的平均灰度值，v是该区域的标准差，k是一个修正系数 它根据以像素点为中心的邻域内的点的情况为此像素计算阈值。下面是每个像素阈值的计算公式，m是均值，s是标准差 MATALB代码：123456789101112131415161718192021222324function g=segNiBlack(f,w2,k)% segmentation method using Niblack thresholding method% input: w2 is the half width of the window w = 2*w2 + 1;window = ones(w, w);% compute sum of pixels in WxW windowsp = conv2(f, window, &apos;same&apos;);% convert to meann = w^2; % number of pixels in windowm = sp / n;% compute the stdif k ~= 0 % compute sum of pixels squared in WxW window sp2 = conv2(f.^2, window, &apos;same&apos;); % convert to std var = (n*sp2 - sp.^2) / n / (n-1); s = sqrt(var); % compute Niblack threshold t = m + k * s;else t = m;endg=f&lt;t; end C代码：123456789101112131415161718192021222324252627282930313233void NiBlack(BYTE \*image\_in, BYTE \*image\_out, int xsize, int ysize)&#123;/*////////////////////////////////////////////////////////////////////// 作者：杨魁//参数列表：//image_in 输入图像的指针//image_out 输出图像的指针//xsize 图像的宽//ysize 图像的高////////////////////////////////////////////////////////////////////*/ int sum = 0;int i, j, h, k;;//用于循环int Average = 0;//平均值int num = 0;//用于自加int w\_size = 7;//窗口大小为2\*w\_size+1int Area = (2 \* w\_size + 1)*(2 * w\_size + 1);int \*d = (int \*)malloc(sizeof(int)*Area);//数组空间int T = 0;//阈值int S = 0;//标准差 for (j = w\_size; j &lt; ysize - w\_size; j++)&#123; for (i = w\_size; i &lt; xsize - w\_size; i++) &#123; sum = 0; num = 0; for (h = 0; h &lt; 2 * w_size + 1; h++) &#123; for (k = 0; k &lt; 2 * w_size + 1; k++) &#123; d\[num++\] = GetGray(image\_in, xsize, i + w\_size - k, j + w_size - h); //求area领域内的像素值 &#125; &#125; for (h = 0; h &lt;Area; h++) &#123; sum += d\[h\];//求总和 &#125; Average = sum / Area; sum = 0; for (h = 0; h &lt; Area; h++) &#123; sum += (d\[h\] * d\[h\]); &#125; S = sqrt((float)sum); S = S / Area; T = Average + 0.05*S;//确定阈值 *(image\_out + j \*xsize + i) = \*(image\_in + j *xsize + i) &gt; T ? 255 : 0; &#125;&#125;free(d); C1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/// &lt;summary&gt; /// 快速的二维数组元素局部窗口求和程序 /// &lt;/summary&gt; /// &lt;param name=&quot;array&quot;&gt; 输入二维数组&lt;/param&gt; /// &lt;param name=&quot;winR&quot;&gt;窗口半径&lt;/param&gt; /// &lt;returns&gt;输出结果&lt;/returns&gt; /// &lt;summary&gt; public static int\[,\] LocalSum_Fast(byte\[,\] array, int winR) &#123; int width = array.GetLength(0); int height = array.GetLength(1); int\[,\] temp = new int\[width, height\];//保存中间结果的数组 int\[,\] sum = new int\[width, height\]; //不考虑边界情况， //水平方向：winR行至width-winR行， //垂直方向：winR列至width-winR列 //对起始行winR在垂直方向求线性和 for (int x = winR; x &lt; width - winR; x++) &#123; for (int k = -winR; k &lt;= winR ; k++) &#123; temp\[x, winR\] += array\[x, winR + k\]; &#125; &#125; //从winR+1行至末尾行height-winR，依次基于前一行的求和结果进行计算。 for (int y = winR + 1; y &lt; height - winR; y++) &#123; for (int x = winR; x &lt; width - winR; x++) &#123; temp\[x, y\] = temp\[x, y - 1\] + array\[x, y + winR\] - array\[x, y - 1 - winR\]; &#125; &#125; //基于保存的垂直方向求和结果，进行水平方向求和 //对起始列winR在水平方向求线性和 for (int y = winR; y &lt; height - winR; y++) &#123; for (int k = -winR; k &lt;= winR ; k++) &#123; sum\[winR, y\] += temp\[winR + k, y\]; &#125; &#125; //从winR+1列至末尾列height-winR，依次基于前一列的求和结果进行计算。 for (int x = winR + 1; x &lt; width - winR; x++) &#123; for (int y = winR; y &lt; height - winR; y++) &#123; sum\[x, y\] = sum\[x - 1, y\] + temp\[x + winR, y\] - temp\[x - winR - 1, y\]; &#125; &#125; //运算完成，输出求和结果。 return sum; &#125; 7.bernsen二值化bernsen算法的中心思想： 先人为设定两个值S与TT(Bemsen最初设S为15，TT设为128)，计算以图像中任意像素尸为中心的大小为k×k窗口内的所有像素的最大值M与最小值N，两者的均值T，如果朋M-N大于S，则当前P的阈值为T；若小于S，则表示该窗口所在区域灰度级灰度级差别较小，那么窗口在目标区或在背景区，再判断T与TT的关系，若T&gt;TT则当前点灰度值为255，否则当前点灰度值为0。 改进的bernsen算法： 1.消除个别灰度特异点，设采用的阈值为T1。 T1的取值满足： A为图像的总像素个数 代码实现： 12345678910111213141516171819202122int getThreshBernsen(IplImage *src) &#123; uchar num\[256\]; int w = src-&gt;width; int h = src-&gt;height; int s = src-&gt;widthStep; int T1 = 0; int pix = 0; int a = w * h; memset(num, 0, 256); //统计灰度值的个数 for(int i=0; i&lt;=255; i++) &#123; for(int j=1; j&lt;= h; j++) &#123; for(int m=1; m&lt;= w; m++) &#123; if(((uchar*)src-&gt;imageData + j*s)\[m\] == i) &#123; num\[i\] = num\[i\] + 1; &#125; &#125; &#125; &#125; for(int i=255; i&gt;=0; i--) &#123; pix = pix + num\[i\]; if(pix &gt;= (0.1*a)) &#123; T1 = i; break; &#125; &#125; cout &lt;&lt; T1 &lt;&lt; endl; return T1; &#125; 二值化的方法有很多，基于每个人来说都会有着适合自己的方法，这里我们只介绍上述几种主流方法，正常使用已经足以，方法不在于多，而在于精，可能你用一种方法就很完美，也可能要不断修改，找到最适合的，图像处理好才是王道。参考： ttps://www.cnblogs.com/Imageshop/p/3307308.htmlhttps://blog.csdn.net/liuzhuomei0911/article/details/51440305https://blog.csdn.net/jinzhichaoshuiping/article/details/51480520https://www.cnblogs.com/naniJser/archive/2012/12/12/2814324.htmlhttps://blog.csdn.net/wu\_lian\_nan/article/details/69371720https://blog.csdn.net/zyzhangyue/article/details/45841121 还有一些参考较少的文献，这里就不罗列了，写这个用到参考文献实在太多，抱歉抱歉 整理实属不易，点个赞再走呗！]]></content>
      <categories>
        <category>NXP智能车</category>
      </categories>
      <tags>
        <tag>NXP智能车</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python天气预报查询]]></title>
    <url>%2Fposts%2F29156%2F</url>
    <content type="text"><![CDATA[功能： 实现城市天气预报查询，并提供未来四天查询 两个网站接口，直接返回数据，之后对数据进行读取和处理，很简单的小程序 效果图：代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import urllib.requestimport gzipimport jsonprint('------天气查询------')def get_weather_data() : city_name = input('请输入要查询的城市名称：') url1 = 'http://wthrcdn.etouch.cn/weather_mini?city='+urllib.parse.quote(city_name) url2 = 'http://wthrcdn.etouch.cn/weather_mini?citykey=101010100' #网址1只需要输入城市名，网址2需要输入城市代码 #print(url1) weather_data = urllib.request.urlopen(url1).read() #读取网页数据 weather_data = gzip.decompress(weather_data).decode('utf-8') #解压网页数据 weather_dict = json.loads(weather_data) #将json数据转换为dict数据 return weather_dictdef show_weather(weather_data): weather_dict = weather_data #将json数据转换为dict数据 if weather_dict.get('desc') == 'invilad-citykey': print('你输入的城市名有误，或者天气中心未收录你所在城市') elif weather_dict.get('desc') =='OK': forecast = weather_dict.get('data').get('forecast') print('城市：',weather_dict.get('data').get('city')) print('温度：',weather_dict.get('data').get('wendu')+'℃ ') print('感冒：',weather_dict.get('data').get('ganmao')) print('风向：',forecast[0].get('fengxiang')) print('风级：',forecast[0].get('fengli')) print('高温：',forecast[0].get('high')) print('低温：',forecast[0].get('low')) print('天气：',forecast[0].get('type')) print('日期：',forecast[0].get('date')) print('*******************************') four_day_forecast =input('是否要显示未来四天天气，是/否：') if four_day_forecast == '是' or 'Y' or 'y': for i in range(1,5): print('日期：',forecast[i].get('date')) print('风向：',forecast[i].get('fengxiang')) print('风级：',forecast[i].get('fengli')) print('高温：',forecast[i].get('high')) print('低温：',forecast[i].get('low')) print('天气：',forecast[i].get('type')) print('--------------------------') print('***********************************')show_weather(get_weather_data())]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像处理一之-摄像头二值化处理-(什么是二值化)]]></title>
    <url>%2Fposts%2F57165%2F</url>
    <content type="text"><![CDATA[图像二值化 binary image什么是二值化：** 二值化是图像分割的一种最简单的方法。二值化可以把灰度图像转换成二值图像。把大于某个临界灰度值(阈值)**的像素灰度设为灰度极大值(255)，把小于这个值的像素灰度设为灰度极小值（0），从而实现二值化， 简单来说：设定一个阈值valve，对于视频信号矩阵中的每一行，从左至右比较各像素值和阈值的大小，若图像灰度值大于或等于阈值，则判定该像素对应的255；反之，小于阈值的灰度值则为0。就是将图像上的像素点的灰度值设置为0或255，也就是将整个图像呈现出明显的黑白效果。二值化的作用：简单通俗的说：二值化的所用就是将图像分成黑和白，更加有利于做图像处理判别。也就是我们说的黑白图像 在了解了这些之后，我们看下二值化的方法： 根据阈值选取的不同，二值化的算法分为固定阈值和自适应阈值(动态阈值)。 比较常用的二值化方法则有：双峰法、P参数法、迭代法和OTSU法等 固定阈值和自适应阈值：这个就很简单理解了，固定阈值就是设置一个固定的阈值，进行二值化处理，而现在大部分二值化算法用的都是自适应阈值(动态阈值)，很容易理解：固定阈值的二值化呢，，一个阈值往往只对应一类图像，如果图像的光照变暗了，或者其他因素改变了，那个单阈值情况的二值化效果会大大的折扣。自适应二值化其实就是一种根据图片的灰度直方图，得到一个适合本图像的二值化阈值。 硬件二值化和软件二值化:硬件二值化的摄像头，是二值化的过程由逻辑芯片直接处理，就是内部自带二值化，它输出的就是二值化后的值了，，所得的图像即为黑白。给单片机节约二值化处理时间，从而不需要进行二值化处理。—-软件二值化就是摄像头没有自带二值化，需要自己做二值化处理 附最简单二值化代码，其他算法之后讲解 123456789101112131415Void image_binaryzation()&#123;for(int i=0;i&lt;Row;i++)&#123; for(int j=0;j&lt;Col;j++) &#123;if(Image\[i\]\[j\] &gt;= Threshold) Image_new\[i\]\[j\]=1;else Image_new\[i\]\[j\]=0; &#125;&#125;&#125; 其中 Row是对应采集到的行数，Col是列数，Image[i][j]是摄像头采集未二值化的数据存放的数组，Image_new[i][j]是新建的存放二值化后的数组，Threshold是阈值（前面有阈值的讲解）。整理不易，点个赞再走呗！]]></content>
      <categories>
        <category>NXP智能车</category>
      </categories>
      <tags>
        <tag>NXP智能车</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于K60/K66/LPC的HC-SR04超声波测距(附带代码)]]></title>
    <url>%2Fposts%2F50635%2F</url>
    <content type="text"><![CDATA[基于K60/K66/LPC的HC-SR04超声波测距(附带代码)最近在搞超声波，把自己走过的一些坑，和经验分享一下，互相学习，让初学者少走一些弯路，K60代码网上找了一些，结果没有能用的，没办法，自己看讲解，用PIT计时测试成功，在K60和K66上测试可以使用，测距也比较准确，希望能有些帮助 1HC-SR04超声波测距原理准备 ：引出4个排针，连接到单片机的vcc(5V)，io口，io口，gnd，用到2个io口， 1.给脉冲触发引脚（Trig）输入一个持续时间&gt;10us的高电平 2.输入方波后，模块会自动发射8个40KHz的声波，与此同时回波引脚（ECOH）端的电平会由0变为1； (输出一个高电平)（此时应该启动定时器计时） .3.当超声波返回被模块接收到时，接收端的电平会由1变为0(变为低电平)；该高电平的持续时间即为超声波往返的时间，（这时停止定时器计数）， 4.在单片机里面通过定时器计算Echo高电平的持续时间即可算出超声波往返的距离。 5.测距公式：距离=（高电平时间*声速）/2； 2.调试经验1注意超声波要接的是5V，不是3.3V，使用下载器时一般都是3.3V供电，这就导致在线调试没有数据，应该给板子供上电，下载器不供电，超声波接到5V电源口，并且检测下是不是5V. 2.测距时不要距离太近，会导致数据不准确 3.超声波代码要尽量精简，不要繁琐，假设你代码过于繁琐，因为超声波测距时间非常短（us单位）可能这次电平已经发生变化，但是你的MCU在经行其他代码运行，可能就检测不到这次信号。 4.要考虑各种因素影响测距稳定，比如高电平检测是否准确，温度原因等，超声波测距的性能与被测物表面材料有很大关系，如毛料、布料对超声波 的反射率很小，会严重影响测量结果。 5.io口任意两个即可，注意不要占用到之前本来使用的，否则会出问题，还有PIT1如果使用，就初始化PIT2进行计时，一个PIT做一种工作 6 测量时间间隔在60MS左右最好 7 测距等待一定的时间，如果超时后依然没有数据返回，就放弃，而进行下一次测量。 超声波最大测距4米，反射路径8米，声速度331米/秒） 8/331=0.02416 //24MS 话不多说直接上代码⬇ 12345678910111213141516171819202122232425262728293031323334#include "MK60_PIT.h" #define TRIG D9 //超声波发送端#define ECHG E12 //超声波接收端int Distance = 0; //测量距离gpio_init(TRIG,GPO,0); //初始化发送端gpio_init(ECHG,GPI,0); //初始化接收端 /* * @file distance * @brief 超声波测距 * @author Z小旋 * @version v1.0 * @date 2019-1-17*/void distance(void)&#123; uint32 Time = 0; gpio_set(TRIG,1); //产生触发脉冲 pit_delay_us(pit1,20); gpio_set(TRIG,0); //产生一个20us的高电平脉冲 while(gpio_get (ECHG) == 0); //等待电平变高，低电平一直等待 pit_time_start (pit1); //开始计时 while(gpio_get(ECHG) == 1) //等待电平变低，高电平一直等待 &#123; Time++; systick_delay(1); if(Time&gt;240000) break; //24MS还没有检测到 &#125;; timevar = pit_time_get(pit1); //停止计时，获取计时时间 //timevar = timevar * 340 /2/10; Distance = timevar*(331.4+0.607*10)/2000; //加上温度补偿 // DELAY_MS(60); //延时60MS，测距更精确，可以不用,2.27号：有反映说加上之后测距不精确，注释之后就好了，自行测试&#125; 上面代码测距误差在10mm以内，满足正常使用，直接调用函数即可下面这个是使用外部触发中断进行的，附上完整代码，直接复制使用即可，如果没有对应的库，完整例程在下方下载，弄到百度云了，CSDN下载还要钱。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include "headfile.h"#define TRIG A14 //定义超声波触发引脚端口#define ECHO A13 //定义超声波回响引脚端口 /* * @brief 超声波测距 * @author Z小旋 * @version v1.0*/uint8 flag_mode = 0;//当前运行状态 0：采集结束 1：正在采集 uint32 dis_time;//定义时间变量 单位微秒uint32 distance;//定义距离变量 单位毫米int main(void)&#123; gpio_init (TRIG,GPO,0); //触发引脚初始化 新生板A28 port_init (ECHO, IRQ_FALLING | PF | ALT1 | PULLUP ); //接收引脚初始化 新生板E9 //port_init (ECHO_PIN, IRQ_RISING | PF | ALT1 | PULLUP ); set_irq_priority(PORTA_IRQn,3);//设置优先级 越低优先级越高 enable_irq(PORTA_IRQn);//开中断 PIN_INT0_IRQn - PIN_INT7_IRQn EnableInterrupts; //这里是while循环，使用时请封装成函数并在中断中调用，不宜调用过快，否则会很占系统时序 while(1) &#123; if(!flag_mode) &#123; flag_mode = 1; gpio_set(TRIG, 1); pit_delay_us(pit1,15); gpio_set(TRIG, 0); while(!gpio_get(ECHO)); //检测到接收引脚为高电平则开始计时 pit_time_start (pit1); //开始计时 dis_time = 0; //时间清零 &#125; //超时检测 if(20000 &lt;= pit_time_get(pit1)) //如果等待20ms之后还未接收到回响信号则 认为前方无障碍物 &#123; dis_time = 0; //时间清零 distance = 1000; flag_mode = 0; //采集结束 &#125; &#125;&#125;//-------------------------------------------------------------------------------------------------------------------// @brief PROTA中断执行函数// @return void // @since v1.0// Sample usage: 当A口启用中断功能且发生中断的时候会自动执行该函数//-------------------------------------------------------------------------------------------------------------------void PORTA_IRQHandler(void)&#123; //清除中断标志第一种方法直接操作寄存器，每一位对应一个引脚 PORTA_FLAG_CLR(A13); if(flag_mode) &#123; dis_time = pit_time_get(pit1); //获取时间 distance = (int16)(dis_time*(331.4+0.607*10)/20000); //加上温度补偿 flag_mode = 0; &#125;&#125; 链接: https://pan.baidu.com/s/1YP8SuujxxRzOxO2cm_KWIQ 提取码: btyv 整理不易，都看到这儿了，点个赞再走呗]]></content>
      <categories>
        <category>NXP智能车</category>
      </categories>
      <tags>
        <tag>NXP智能车</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中变量在内存的存储与地址变化详解(深浅拷贝，值/引用传递、可变不可变数据类型)]]></title>
    <url>%2Fposts%2F33774%2F</url>
    <content type="text"><![CDATA[学习Python首先我们要知道Python变量保存的是值的引用 也可以说：变量是对内存及其地址的抽象 Python：一切变量都是对象 变量的存储，采用了引用语义的方式，存储的只是一个变量的值所在的内存地址，而不是这个变量的值本身见下图采用这种方式：变量所需的存储空间大小一致，因为变量只是保存了一个引用。也被称为对象语义和指针语义。变量的每一次初始化，都开辟了一个新的空间，将新内容的地址赋值给变量 值语义：有些语言采用的不是这种方式，它们把变量的值直接保存在变量的存储区里，这种方式被我们称为值语义，例如C语言，采用这种存储方式，每一个变量在内存中所占的空间就要根据变量实际的大小而定，比如 c中 int 一般为2个字节 而char为一个字节 这张图帮助你更好理解⬇ *预备知识一—-id函数 id函数：你可以通过python的内置函数 id() 来查看对象的身份(identity)，这个所谓的身份其实就是 对象 的内存地址就是获取对象在内存中的地址 *预备知识二—-对于变量的赋值 ==我们把不同的值赋给变量时候，变量指向的地址发生变化，但是相同的值地址不发生变化。==👆对于变量进行赋值时，每一次的赋值都会产生一个新的空间地址，将新内容的地址赋值给变量 *预备知识三—-复杂的数据类型，列表，元组，字典等修改与赋值对于这些复杂数据类型，如果修改其中某一项元素的值，或者添加几个元素，不会改变其本身的地址，只会改变其内部元素的地址引用，但是如果对其进行重新赋值操作时，就会给列表重新赋予一个地址，来覆盖之前的地址这时列表地址会发生改变 话题引入这里我们不妨举个例子上图一个是直接用引用复制“=”进行复制另一个是用分片复制[:]进行复制修改list1之后list2跟list1相同，但是list3却没发生变化 在我们创建list1的时候，Python已经了开辟list1的地址，并且分别指向了其中的值，而我们用“=”进行复制时，只是会给现存的对象添加一个新的引用，并不会在内存中生成新的对象这里list1和list2指向的是同一个地址，相当于创建快捷方式一样，多了一个指向该列表地址的引用 但是分片[:]复制是不同的，他会创建一个新的对象，list3跟list1和list2的值相同，但是地址是不同的，相当于复制了一份新的，copy()函数和分片相同 通过上面我们可以知道： Python支持相同的值的不同对象，相当于内存中对于同值的对象保存了多份 但是上面只是对于可变数据类型适用，对于不可变数据类型，内存中只能有一个相同值的对象 当然，具体也要看有没有产生新的对象，如果产生新的对象，则改变的那个列表会指向新的地址 12345678910111213def func(val1): print('val1: &#123;&#125;, id: &#123;&#125;'.format(val1, id(val1))) # val1: [1, 2, 3], id: 43499976 val2 = val1 print('val2: &#123;&#125;, id: &#123;&#125;'.format(val2, id(val2))) # val2: [1, 2, 3], id: 43499976 val2.append(4) print('val2: &#123;&#125;, id: &#123;&#125;'.format(val2, id(val2))) # val2: [1, 2, 3, 4], id: 43499976 val2 = val2 + [5] print('val2: &#123;&#125;, id: &#123;&#125;'.format(val2, id(val2))) # val2: [1, 2, 3, 4, 5], id: 43500296 a = [1, 2, 3]print('a: &#123;&#125;, id: &#123;&#125;'.format(a, id(a))) # a: [1, 2, 3], id: 43499976func(a)print('a: &#123;&#125;, id: &#123;&#125;'.format(a, id(a))) # a: [1, 2, 3, 4], id: 43499976 ==可变数据类型于不可变数据类型==可变数据类型：列表list和字典dict不可变数据类型：整型int、浮点型float、字符串型string和元组tuple 同学们会有疑问，可变数据类型于不可变数据类型差别在哪里呢？这两者最本质的区别在于：，是指内存中的那块内容（值）是否可以被改变 （1）不可变数据类型，不允许变量的值发生变化，如果改变了变量的值，相当于是新建了一个对象，而对于相同的值的对象，在内存中则只有一个对象，就是不可变数据类型引用的地址的值不可改变 改变对象的值，其实是引用了不同的对象 ⬇ （2）可变数据类型，允许变量的值发生变化，即如果对变量进行append、+=等这种操作后，只是改变了变量的值，而不会新建一个对象，变量引用的对象的地址不会改变，只是对应地址的内容改变或者地址发生了扩充，所以对于相同的值的不同对象，会存在多份，即每个对象都有自己的地址 这样就可以理解预备知识三的变化了 ==浅拷贝和深拷贝==copy.copy() 浅拷贝；copy.deepcopy() 深拷贝 浅拷贝：不管多么复杂的数据结构，浅拷贝都只会copy一层。 深拷贝:深拷贝会完全复制原变量相关的所有数据,直到最后一层，在内存中生成一套完全一样的内容,,在这个过程中我们对这两个变量中的一个进行任意修改都不会影响其他变量 1234567891011121314&gt;&gt;&gt; import copy&gt;&gt;&gt; list1=[1,2,3]&gt;&gt;&gt; list2=[4,5,list1]&gt;&gt;&gt; list2[4, 5, [1, 2, 3]]&gt;&gt;&gt;list3 = list2.copy() #list3浅拷贝&gt;&gt;&gt;list4 = list2.deepcpoy() #list4深拷贝&gt;&gt;&gt;list1 = [6,6,6]&gt;&gt;&gt;list2&gt;&gt;&gt;[4, 5, [6, 6, 6]]&gt;&gt;&gt;list3&gt;&gt;&gt;[4, 5, [6, 6, 6]]&gt;&gt;&gt;list4&gt;&gt;&gt;[4, 5, [1, 2, 3]] 可以看到，list3只复制了list2列表的一层，在修改list1之后，list3也发生了变化图片给出具体分析1浅拷贝 浅拷贝 只拷贝父对象(一层)，不会拷贝对象的内部的可变子对象(多层)。，浅拷贝是指拷贝的只是原子对象元素的引用，换句话说，浅拷贝产生的对象(k1,k2,k3) 本身是新的，但是它的内容不是新的，只是对原==子对象==的一个==引用==。2深拷贝深拷贝就是在内存中重新开辟一块空间，不管数据结构多么复杂，只要遇到可能发生改变的数据类型，就重新开辟一块内存空间把内容复制下来，直到最后一层3引用复制（赋值拷贝） “=”多了几个变量指向同一个地址， 当我们使用下面的操作的时候，会产生浅拷贝的效果： 使用切片[:]操作使用工厂函数（如list/dir/set）使用copy模块中的copy()函数 * 引用传递与值传递：可变对象为引用传递，不可变对象为值传递。（函数传值） 1，值传递： 简单来说 **==对于函数输入的参数对象，函数执行中首先生成对象的一个副本，并在执行过程中对副本进行操作。执行结束后对象不发生改变==即在堆栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。（被调函数新开辟内存空间存放的是实参的副本值）** 值传递不会改变原来函数的值， 1234567891011def Change(b): b += 2 传递进来的为不可变对象，为值传递 相当于相同值的一个副本 print(id(b)) print (b) returna = 2print(id(a)) Change(a)print (a)print(id(a)) 输出为 12345140724617470832 a本来地址140724617470896 值传递b的地址4 在函数中为42 a本身还是2140724617470832 a地址也没有改变 2，引用传递：当传递列表或者字典时，如果改变引用的值，就修改了原始的对象。（被调函数新开辟内存空间存放的是实参的地址） 12345678def Change(str1): str1[1] ="changed " 此处修改就是直接修改string的值 returnstring = ['hello world',2,3]print (string)Change(string) print (string) 输出为：可以看到列表最后发生了变化 注意： 在函数调用中无法直接修改整个列表或字典的值 如果这样做，就是相当于也是相当于创建副本的值传递 这是网上很多帖子没有提到的 12345678def Change(str1): str1 =[6,7] //直接修改整个列表，也是相当于创建副本的值传递 returnstring = ['hello world',2,3]print (string)Change(string) print (string) 输出： 12[&apos;hello world&apos;, 2, 3][&apos;hello world&apos;, 2, 3] string没有发生变化 整理不易，都看这儿了，点个赞再走呗！]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Python ord()和chr()返回ASCII码和Unicode码的看法]]></title>
    <url>%2Fposts%2F38082%2F</url>
    <content type="text"><![CDATA[刚开始学这两个函数的时候，看到书上说的是返回Unicode码，但是自己去百度之后，发现很多人都说返回是ASCII码为什么会这样呢？ 那么为了不误解 ，我们先介绍下Unicode码和ASCII码 ASCII美国(国家)信息交换标准(代)码，一种使用7个或8个二进制位进行编码的方案，最多可以给256个字符(包括字母、数字、标点符号、控制字符及其他符号)分配(或指定)数值 Unicode（万国码）如果有一种编码，将世界上所有的符号都纳入其中，无论是英文、日文、还是中文等，大家都使用这个编码表，就不会出现编码不匹配现象。每个符号对应一个唯一的编码，乱码问题就不存在了。这就是Unicode编码 简单来说：Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。区别：ASCII:不支持中文，1个英文占1个字节Unicode(万国码，支持所有国家的文字显示)：支持中文，但是每个英文和中文都占2个字节 那么为什么会出现有的说ASCII有的说Unicode码的呢？ 划重点 ==因为Python的诞生比Unicode标准发布的时间还要早，所以最早的Python只支持ASCII编码，普通的字符串’ABC’在Python内部都是ASCII编码的。，但是在Unicode标准发布以后 新版的Python，就开始逐渐基于Unicode码了== 所以这是为什么会说ord()返回会出现不同的原因 这是Python2的时候介绍⬇ ord() 函数是 chr() 函数（对于8位的ASCII字符串）或 unichr() 函数（对于Unicode对象）的配对函数，它以一个字符（长度为1的字符串）作为参数，返回对应的 ASCII 数值，或者 Unicode 数值 但是在Python3之后unichr函数取消了 因为Python3中的chr()不仅仅支持Ascii的转换，直接支持了更为适用的Unicode转换 ==但是Unicode码的0-127和ASCII码还是一样的==，所以不用担心ASCII不能用的问题 ==127-255的扩展ASCII码和Unicode是不同的 这点要注意==** 问题到这里就差不多了，还有一些更深入的我们就不说了，总之时代在发展，Python也在不断改版，努力学习才不会落伍，]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C语言】运算符与操作符的用法全面汇总(非常有用)]]></title>
    <url>%2Fposts%2F17949%2F</url>
    <content type="text"><![CDATA[一篇对初学者十分友好的文章。 一．‘-&gt;’的用法“-&gt;”是一个整体，它是用于指向结构体子数据的指针，用来取子数据。换种说法，如果我们在C语言中定义了一个结构体，然后申明一个指针指向这个结构体，那么我们要用指针取出结构体中的数据，就要用到“-&gt;”。 p=p-&gt;next ，意思是将p指向的一个结构体实例中的子数据next赋值给p。 -&gt;的作法就是在引用结构体中的变量！​​扩展资料： 在C语言中，结构体(struct)指的是一种数据结构，是C语言中聚合数据类型(aggregate data type)的一类。结构体可以被声明为变量、指针或数组等，用以实现较复杂的数据结构。结构体同时也是一些元素的集合，这些元素称为结构体的成员(member)，且这些成员可以为不同的类型，成员一般用名字访问。 二.‘[ ]’的用法数组的下标，定义数组以用于数组操作比如int a[6];就是定义一个一维数组,这个数组名叫做 a ,共有6个元素同理int b[6][6]就是定义一个二维数组,这个数组共有6*6个元素 三 ‘.’的用法用在一般结构体变量中，直接调用结构体中的某个成员 如： student.name 扩展资料： 成员运算符（·）和指向结构体成员运算符（-&gt;）的区别： 两者都是用来引用结构体变量的成员，但它们的应用环境是完全不一样，前者是用在一般结构体变量中，而后者是与指向结构体变量的指针连用，例如：有定义 1234567891011struct student &#123; long num; float score;&#125;; struct student stud, *ptr=&amp;stud; 则stud.num、stud.score、ptr-&gt;num等都是正确的引用方式，但ptr.num、stud-&gt;num就是不允许的，其实ptr-&gt;num相当于(*ptr).num，只是为了更为直观而专门提供了这-&gt;运算符。 最后指出，这两者都具有最高优先级，按自左向右的方向结合。 四 ‘！’的用法 ！为逻辑运算符 “非”，用来改变条件的逻辑状态，如果条件为真则改变为假 其运算规则为，1 如果a的值为0，则运算结果为1;2 如果a的值非0，则运算结果为0。 举例： a!=9 就是a不等于9 五 ‘逻辑与&amp;&amp;和逻辑或||’的用法&amp;&amp;(与) 和|| (或)都是逻辑表达式里常用的，一般用法是 if（表达式1 || 表达式2） 或者 if（表达式1 &amp;&amp; 表达式2） || 表示 或 只要有一个非0，整个表达式就为真，就满足if判定的条件例如 if(1 || 0) ;1为真 0为假 此判断条件为真 &amp;&amp; 表示 且 if括号内的表达式都为真 才能满足if判定的条件 才会执行if{}里的语句 六.自增运算符++，自减运算符–’的用法如果单独写 自增运算符为一个语句，二者没有区别++i; 和 i++; 都是让i+1赋值给i 但是++和–在变量前后的时候，则是会有不同 ++在前 例如: ++a; 说明: ++在前时，b会先自加1，然后才赋值给a 举例: int a, b = 1; a = ++b; //b增加至2，a得到的值为2 ++在后 例如: a++; 说明: ++在后时，b赋值给a，再进行自加 举例: int a, b = 1; a = b++; //b增加至2，a得到的值为1 在操作数之前的操作符(++b)在变量值在被使用之前增加它的值；在操作数之后的操作符(b++)在变量值被使用之后才增加的值。 扩展资料： ++a 与 a++ 不能被赋值 ，因为他们本身只是拷贝了变量的值，并不是变量本身，你无法向一个值进行赋值 int a = 1; ++a = 5; 这样子是错误的！ 七.取地址运算符 &amp;和指针运算符*取地址运算符 &amp; &amp; 是一元运算符，返回操作数的内存地址。例如，如果 var 是一个整型变量，则 &amp;var 是它的地址。该运算符与其他一元运算符具有相同的优先级，在运算时它是从右向左顺序进行的。 您可以把 &amp; 运算符读作“取地址运算符”，这意味着，&amp;var 读作”var 的地址”。 和指针运算符* * 运算在C语言中，有两种作用：1 用作乘法，为双目运算符，形式为ab, 就是计算数学中的a乘以b。2 用作取值运算，为*单目运算符**，根据后续操作数(必须为指针)类型，取其指向的值。 所谓的指针，本质上就是地址。 指针变量的值，就是地址的值，当取值运算时就是到对应的内存地址上，依照指针类型进行取值。 八.长度运算符sizeof’的用法sizeof操作符计算的是变量（类型）所占空间的大小，是按字节来计算 sizeof是运算符，不是函数 该运算符在编译阶段就已经起作用了。它以字节为单位返回其操作数的大小。它的操作数可以是数据对象也可以是一个类型。如果是类型那么操作数需要用圆括号括起来。 如：sizeof(int)=4; sizeof(char) 等于1 sizeof以byte为单位返回操作数的大小 扩展资料： (0)sizeof是运算符，不是函数； (1)sizeof不能求得void类型的长度； (2)sizeof能求得void类型的指针的长度； (3)sizeof能求得静态分配内存的数组的长度! (4)sizeof不能求得动态分配的内存的大小! (5)sizeof不能对不完整的数组求长度； (6)当表达式作为sizeof的操作数时，它返回表达式的计算结果的类型大小，但是它不对表达式求值！ (7)sizeof可以对函数调用求大小，并且求得的大小等于返回类型的大小，但是不执行函数体！ (8)sizeof求得的结构体(及其对象)的大小并不等于各个数据成员对象的大小之和！ (9)sizeof不能用于求结构体的位域成员的大小，但是可以求得包含位域成员的结构体的大小！ 九.算术运算符+=*/% 和关系运算符&gt;&lt;=这些都很简单，应该不用过多介绍 操作符 功能 &gt; 大于 &gt;= 大于等于 &lt; 小于 &lt;= 小于等于 != 不等于 == 等于 操作符 功能 += 相加之后赋值 -= 相减之后赋值 *= 相乘之后赋值 /= 相除之后赋值 %= 取余之后赋值 &gt;&gt;= 右移之后赋值 &lt;&lt;= 左移之后赋值 丨= 按位或之后赋值 ^= 按位与 扩展资料： 单目运算符 双目运算符 三目运算符 单目就是这个运算符只对一个变量进行操作 举例：int a=1;a++;（第二句“a++”则只对a一个变量进行了操作） 双目就是这个运算符对两个变量进行操作 举例：int a=1,b=2,c;c=a+b;(第二句“c=a+b”则是对a,b两个变量进行了操作) 三目就是这个运算符对三个变量进行操作 十.?表达式条件1 ? 表达式2 : 表达式3 是否满足条件1，如果满足则执行操作2，否则执行操作3。 条件运算符是C语言中唯一的一个三目运算符，其求值规则为：如果表达式1的值为真，则以表达式2 的值作为整个条件表达式的值，否则以表达式3的值作为整个条件表达式的值。条件表达式通常用于赋值语句之中。 我们可以把想成这样 求两个数中最大的一个 12345678if(a&gt;b)&#123; max = a;&#125;else&#123; max = b;&#125; 而用？表达式 max = (a&gt;b) ? a : b; 如a&gt;b为真，则把a赋予max，否则把b 赋予max。 是不是很节约代码，又显的高级 十一.位操作符与位移操作符C语言提供了六种位运算| 位运算符 | 含义 | 举例 ||–|–|–|| &amp;（and） | 按位与 | a&amp;b || | ( or ) |按位或 | a|b ||^ （ xor ） |按位异或 | a^b || ~ ( not ) |按位取反 | ~a ||&lt;&lt; ( shi ) | 左移 | a&lt;&lt;1 ||&gt;&gt; ( shr ) |右移 | a&gt;&gt;1 | 11.1按位“与”&amp;（双目运算符）：仅当两个操作数都为1时，结果为1，否则为0。参与运算的数以补码方式出现。因为计算机是以补码形式存储数据的 例：9&amp;5=1 0000 1001————- 9的补码 &amp; 0000 0101————- 5的补码 ———- 0000 0001————- 1的补码 应用： a、通常将某些位清零或保留某些位。例如：将a的高八位清零，保留低八位，可做a&amp;255运算。 &nbsp;&nbsp;&nbsp;&nbsp;00000000 11111111—————— 255的二进制数 &nbsp;&nbsp;&nbsp;&nbsp;00000000 00100000—————— a的二进制数 &nbsp;&nbsp;&nbsp;&nbsp; ———- &nbsp;&nbsp;&nbsp;v00000000 11111111 将字符“A”的低四位清零 保留高四位 可以做“A”&amp;240( 0xf0) &nbsp;&nbsp;&nbsp; 0100 0001‬——————“A”的二进制数&nbsp;&nbsp; 1111 0000‬——————240的二进制数 &nbsp;&nbsp;&nbsp;&nbsp; ———- &nbsp;&nbsp;&nbsp;0001 0000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; 保留了“A”的高四位 b、取某数的指定位。例如：设a=1000 1110,要取出a中第二位的1，则可以用 a &amp; 0000 0010 实现。 11.2 按位“或”|（双目运算符）：仅当两个操作数都为0时，结果为0，否则为1。 例：9|5=13 &nbsp;&nbsp;&nbsp;&nbsp;0000 1001————- 9的补码 &nbsp;&nbsp;&nbsp;&nbsp;| 0000 0101————- 5的补码 &nbsp;&nbsp;&nbsp;&nbsp; ———- &nbsp;&nbsp;&nbsp;&nbsp;0000 1101————- 13的补码 &nbsp; 应用：常用来将源操作数某些位置1。例如：设a=0100 0001,将低四位全部置1，则可以用 a | 0000 1111 实现。 11.3 按位“异或”^（双目运算符）：参加运算的两个运算量，如果两个数的相应位的值不同，则该位的结果值为1，否则为0。即：0 ^ 0 =0；0 ^ 1 =1；1 ^ 0 =1；1 ^ 1 =0 例： 9^5=12 &nbsp; &nbsp;&nbsp;&nbsp; 0000 1001————- 9的补码 &nbsp; &nbsp;&nbsp;&nbsp; ^ 0000 0101————- 5的补码 &nbsp; &nbsp;&nbsp;&nbsp; ———- &nbsp; &nbsp;&nbsp;&nbsp; 0000 1101————- 12的补码 应用： &nbsp; a、特定位置取反。例如：设a=1001,将第2位取反，则可以用 a ^1011 实现。 &nbsp; b、不引入第三变量，交换两个数的值。 &nbsp; 例：a=1,b=2,交换两个数的值 &nbsp; &nbsp; a=a^b; &nbsp; &nbsp; b=a^b;&nbsp; &nbsp; a=a^b; 11.4按位取反”运算符~ 按位取反的意思就是每一位取反，0变1，1变0 所以: ~100 的二进制表示为：1001 1011 所以等号左边=1001 1011 11.5、移位操作符 1 左移运算 &lt;&lt;（丢弃最高位，0补最低位）:把一个数的所有位都向左移动若干位。 例如：int i=1；i=i&lt;&lt;2; //这表示将i里的值左移两位。 分析：1的2进制是000…0001(这里1前面0的个数和int的位数有关,32位机器,gcc里有31个0),左移2位之后变成000… 0100,也就是10进制的4,所以说左移1位相当于乘以2,那么左移n位就是乘以2的n次方了（注：有符号数不完全适用） 2 右移运算 &gt;&gt;:把一个数的所有位都向右移动若干位。 例如：int i = 0x80000000; i = i &gt;&gt; 1; //i的值不会变成0x40000000,而会变成0xc0000000 &nbsp; 分析：符号位向右移动后,正数的话补0,负数补1,也就是汇编语言中的算术右移。同样当移动的位数超过类型的长度时,会取余数,然后移动余数个位。 十二.‘逗号运算符’的用法 操作符 功能 exp1，exp2,…expN 从左往右依次执行，整个表达式结果是最后一个表达式的结果 1234567void main(）&#123; int a,s,d; s=2; d=3; a=12+(s+2,d+4);&#125; 先算括号内的值：s+2=4，d+4=7；括号内应为（4,7），括号内取值只取最后一个，如果没有括号则取第一个；a=12+7=19。 十三.define和constdefine和const的区别： **const 定义的常数是变量，也带类型， #define 定义的只是个常数，不带类型； define是在编译的预处理阶段起作用，而const是在 编译、运行的时候起作用； define只是简单的字符串替换，没有类型检查。而const有对应的数据类型，是要进行判断的，可以避免一些低级的错误； const变量存放在内存的静态区域中，在程序运行过程中const变量只有一个拷贝，而#define 所定义的宏变量却有多个拷贝，所消耗的内存要比const变量的大得多； 用define可以定义一些简单的函数，const是不可以定义函数的； define可以用来防止头文件重复引用，而const不能；** const不足的地方，是与生俱来的，const不能重定义，而#define可以通过#undef取消某个符号的定义，再重新定义；在编译时， 编译器通常不为const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。 补充附录：补充附录：①**32**个关键字及其含义： auto 声明自动变量 一般不使用 double 声明双精度变量或函数 int 声明整型变量或函数 struct 声明结构体变量或函数 break 跳出当前循环 else 条件语句否定分支（与 if 连用） long 声明长整型变量或函数 switch 用于开关语句 case 开关语句分支 enum 声明枚举类型 register 声明积存器变量 typedef 用以给数据类型取别名（当然还有其他作用） char 声明字符型变量或函数 extern 声明变量是在其他文件正声明（也可以看做是引用变量） return 子程序返回语句（可以带参数，也看不带参数） union 声明联合数据类型 const 声明只读变量 float 声明浮点型变量或函数 short 声明短整型变量或函数 unsigned 声明无符号类型变量或函数 continue 结束当前循环，开始下一轮循环 for： 一种循环语句(可意会不可言传） signed 生命有符号类型变量或函数 void 声明函数无返回值或无参数，声明无类型指针（基本上就这三个作用） default 开关语句中的“其他”分支 goto 无条件跳转语句 sizeof 计算数据类型长度 volatile 说明变量在程序执行中可被隐含地改变 do 循环语句的循环体 while 循环语句的循环条件 static 声明静态变量 if 条件语句 ②剩余格式控制符: %d 整形 %f 浮点型(实型) %lf 双精度 %hd 短整型 %ld 长整型 %u 无符号输出 %- 左对齐 %m 按m个字宽输出 %s 输出字符串 %0 空位补0 %x 十六进制格式输出 %o 八进制格式输出 %e 指数形式输出 %g 智能输出(%f || %e 选择最优输出方案) %c 输出字符 %p 十六进制形式输出变量地址 %.n 保留小数点后n位or截取字符串前n位 ③u8，u16，u32 u8是unsigned char u16是unsigned short u32是unsigned int 同理 uint8 uint16 uint32 也一样]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言形参跟实参详解]]></title>
    <url>%2Fposts%2F38664%2F</url>
    <content type="text"><![CDATA[形参与实参今天我们来说下c语言形参与实参的区别，形参跟实参理解的话也很简单，但是好多同学关于这个知识点都是一知半解，没有真正的去透彻，一问都知道，但在真正引用的时候还会出现很多问题，而百度的时候又会说看不懂，所以我们今天来做一个比较全面的介绍 我们今天讲解以简单明了易看懂为基础 1.形参和实参是什么简单来说，形式参数（形参）就是形式上的参数，没有确定值，而实际参数(实参)是实际存在的，已经确定的参数，常量，变量，表达式，都是实参， 最简单的例子 12345678int a=2; 这里的A有了实际的值 为实参int change(int b，int c); **c和b就是形参**。 这里的c和b可以是任意一个值传递，为形参int main()&#123; change(1,2); 这样就是把实参值传递给形参,1和2就是实参&#125; 这样我们能有一个简单的认识 2.形参和实参的区别 形参 实参 形参变量只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。因此，形参只有在函数内部有效。函数调用结束返回主调函数后则不能再使用该形参变量 实参定义后就会分配内存 形参出现在函数定义中，在整个函数体内都可以使用， 离开该函数则不能使用 实参出现在主调函数中，进入被调函数后，实参变量也不能使用 形参没有确定的值 实参在值传递给形参的时候，必须要有确定的数值 3.形参与实参知识点 3.1实参的值不随形参的变化而变化 在C语言中，数据传送是单向的，即只能把实参的值值传递给形参，但形参的变化不会改变实参的值，我们可以简单理解，就相当于把实参的值 复制给了另一个数（形参），而另一个数的改变不会改变原来数（实参）的值，正规来说：他们在内存中位于不同的位置，形参将实参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不会改变。。 ** 3.2.实参传递给形参的参数个数类型和顺序都应相同，否则会系统强制转换，出现数据丢失或者“类型不匹配”的错误比如 12345678float a=5.34;void number(int b); int main()&#123; number(a); //这样就会出现丢精度现象&#125; 3.3如果实参是数组名，那么形参传递的之就是地址的值 123456int a[5];void add(int *b);int main()&#123; add(a);//这样就是把数组a的首地址做为形参传递&#125; 在C里面 是无法做到形参改变 实参值同步改变的。如果要用函数改变实参的值，可以用指针作为参数来改变通过直接改变地址存储值来改变实参]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言结构体学习整理(结构体初始化，结构体指针)]]></title>
    <url>%2Fposts%2F48664%2F</url>
    <content type="text"><![CDATA[渣渣c的c语言学习之路1.关于c语言的结构体:首先我们为什么要用到结构体，我们都已经学了很多int char ..等类型还学到了同类型元素构成的数组，以及取上述类型的指针，在一些小应用可以灵活使用，然而，在我们实际应用中，每一种变量进行一次声明，再结合起来显然是不太实际的，类如一位学生的信息管理，他可能有，姓名（char），学号（int）成绩（float）等多种数据。如果把这些数据分别单独定义，就会特别松散、复杂，难以规划，因此我们需要==把一些相关的变量组合起来，以一个整体形式对对象进行描述==，这就是结构体的好处。2首先我们要了解一些小知识 2.1==只有结构体变量才分配地址，而结构体的定义是不分配空间的==。2.2结构体中各成员的定义和之前的变量定义一样，但在定义时也不分配空间。2.3*结构体变量的声明需要在主函数之上或者主函数中声明，如果在主函数之下则会报错*2.4c语言中的结构体不能直接进行强制转换，只有结构体指针才能进行强制转换**2.5相同类型的成员是可以定义在同一类型下的列如 1234567struct Student&#123; int number,age；//int型学号和年龄 char name[20],sex;//char类型姓名和性别 float score;&#125;； 最后的==分号==不要忘了 有的编译器会自动加上，因此有的同学就会不注意。3关于结构体变量的定义和引用 在编译时，结构体的定义并不分配存储空间，对结构体变量才按其数据结构分配相应的存储空间 123456789101112 struct Book &#123; char title[20];//一个字符串表示的titile 题目 char author[20];//一个字符串表示的author作者 float value;//价格表示 &#125;;//这里只是声明 结构体的定义 struct Book book1,book2;//结构体变量的定义 分配空间book1.value;//引用结构体变量 ==定义结构体变量以后，系统就会为其分配内存单元==，比如book1和book2在内存中占44个字节（20+20+4）具体的长度你可以在你的编译器中使用sizeof关键字分别求出来。列如当然，要注意一点：用sizeof关键字求结构体长度时，返回的最大基本类型所占字节的整数倍 比方说我们上面求得的为44 为 float(4个字节)的整数倍，但是我们把title修改为title[22]; 这时正常长度为46 ，但是你会发现实际求得的为48，(4的整数倍) 这就涉及到结构体的存储： 1结构体整体空间是占用空间最大的成员（的类型）所占字节数的整数倍。 2.结构体的每个成员相对结构体首地址的偏移量(offset)都是最大基本类型成员字节大小的整数倍，如果不是编译器会自动补齐， 关于这个我们简单介绍下： 1.偏移量—-偏移量指的是结构体变量中成员的地址和结构体变量首地址的差。即偏移字节数，结构体大小等于最后一个成员的偏移量加上他的大小，第一个成员的偏移量为0， 12345678struct S1&#123; char a; int b; double c;&#125;; 这里char a 偏移量为1 之后为int b 因为偏移量1不为int(4)的整数倍，所以会自动补齐，而在 double c 时，偏移量为8 是double(8)的整数倍，所以不用自动补齐 最后求得结构体得大小为 16 具体看下图：通过上面的代码同学们应该会有一个简单的认知4结构体变量的初始化 结构体的初始化有很多需要注意的地方，这里我们说明下首先是几种初始化的方法ps：在对结构体变量初始化时，要对结构体成员一一赋值，不能跳过前面成员变量，而直接给后面成员赋初值，但是可以只赋值前面几个，对与后面未赋值的变量，如果是数值型，则会自动赋值为0,对于字符型，会自动赋初值为NULL，即‘\0’4.1定义时直接赋值 1234567891011121314struct Student&#123; char name[20]; char sex; int number;&#125;stu1=&#123;"zhaozixuan",'M',12345&#125;;//或者struct Student&#123; char name[20]; char sex; int number;&#125;；struct Student stu1=&#123;"zhaozixuan",'M',12345&#125;; 注意字符为‘ ’ 字符串为””4.2定义结构体之后逐个赋值 12345stu1.name="王伟"；stu1.sex='M';stu1.number=12305;//也可用strcpy函数进行赋值strcpy(stu1.name,"王伟"); 4.3定义之后任意赋值 12345struct Student stu1=&#123; .name="Wang", .number=12345, .sex='W', &#125;;//可以对任意变量赋值 这样写的好处时不用按照顺序来进行初始化，而且可以对你想要赋值的变量直接进行赋值，而不想赋值的变量可以不用赋值 需要注意的是如果在定义结构体变量的时候没有初始化，那么后面就不能全部一起初始化了； 等下结构体数组初始化时我们还会有一个讲解 这里我们顺带提一下typedef说明结构体类型 这里的BOOK就相当于struct book的一个别名一样，用它来定义结构体变量非常简便主要也是考二级要用到，所以我们简单介绍下5结构体变量的引用（输出和输入） 5.1结构体变量的赋值用scanf赋值和printf输出时跟其他变量操作一样但是有几点需要注意(1) .是运算符，在所有运算符优先级中最高(2)如果结构体的成员本身是一个结构体，则需要继续用.运算符，直到最低一级的成员。 1234567891011121314struct Student&#123; char name[20]; char sex; int number; struct Date &#123; int year; int month; int day; &#125;birthday;&#125;stu1;printf("%d",stu1.birthday);//这样子是错误的，因为birthday也是一个结构体变量scanf("%d",&amp;stu1.birthday.month);//正确 (3)可以引用接头体变量成员的地址，也可以引用结构体变量的地址： printf(“%o”, student);(输出student的首地址)(%o 按八进制输出)6结构体数组及其初始化(重点) 这里我们简单说下，具有相同类型的结构体变量组成数组就是结构体数组 结构体数组与结构体变量区别只是将结构体变量替换为数组 1234567891011121314struct Student&#123; char name[20]; char sex; int number;&#125;stu1[5]=&#123; &#123;"zhaozixuan",'M',12345&#125;, &#123;"houxiaohong",'M',12306&#125;, &#123;"qxiaoxin",'W',12546&#125;, &#123;"wangwei",'M',14679&#125;, &#123;"yulongjiao",'W',17857&#125;&#125;;stu1[3].name[3]//表示stu1的第三个结构变量中姓名的第五个字符//若初始化时已经是结构体数组全部元素[]中的数可以不写如stu1[]= 注意结构体数组要在定义时就直接初始化，如果先定义再赋初值是错误的 比如： 123456struct Student stu1；stu1[3]=&#123; &#123;"zhaozixuan",'M',12345&#125;, &#123;"houxiaohong",'M',12306&#125;, &#123;"qxiaoxin",'W',12546&#125; &#125;; 这样子是错误的， 这里我在写的时候遇到一些问题，还是结构体数组初始化的问题，折腾了下解决了，给大家分享下对于数组初始化时比如 12char str[20];str="I love you";/* 这样会修改数组的地址，但是数组的地址分配之后是不允许改变的 */ 在第一条语句中 str就已经被定义成数组而在C99标准中不允许将字符串(实际上是一个指针变量) 赋值给数组，所以如果我们直接赋值是错误的 那么怎么弄呢这里提供3种方法 1.定义数组时直接定义char str[20]=”I love you”; 2.用strcpy或者memset函数进行复制char str[20];strcpy(str,”I love you”);再用到memset函数时，出现了一些问题对于memcset函数简单介绍下 memsetvoid memset(void s,int c,size_t n)作用：将已开辟内存空间s的首n个字节的值设为值c。** 12char str[20];memset(str,'a',20); 如果是字符类型数组的话，memset可以随便用，但是对于其他类型的数组，一般只用来清0或者填-1，如果是填充其他数据就会出错 12int str[10];memset(str,1,sizeof(str));//这样是错误的 这里我们说下这个错误， 首先我们要知道memset在进行赋值时，是按字节为单位来进行赋值的，每次填充的数据长度为一个字节，而对于其他类型的变量，比如int，占4个字节 所以sizeof(str)=40； 而用memset赋值时，将会对指向str地址的前40个字节进行赋值0x01（00000001） 的操作，把0x00000000赋值4次0x01操作变为0x01010101（00000001000000010000000100000001） 相当于给“前10个int”进行了赋值0x01010101的操作 对应十进制的16843009所以会出很大的错误 这里请务必要注意，但是如果是清零一个数组用memset还是很方便的简单使用的话同学们用strcmp函数就行 3用指针（注意内存分配）char *str；str=”I love you”; 这两句话的本质是，在内存中开辟一段内存空间，把”I love you”放进这段内存空间，然后把这段内存空间的地址交给str，由于str是变量，所以给它赋值是合法的。 请注意，在我们进行数组初始化的时候如果定义的数组过长，而我们只初始化了一部分数据，对于未初始化的数据如果是数值型，则会自动赋值为0,对于字符型，会自动赋初值为NULL，即‘\0’ 即不足的元素补以默认值这里我们在4小节中也提到了比如 1int str[10]=&#123;1&#125;;//这里只是把str的第一个元素赋值为1，其他元素默认为0 7结构体与指针 我们知道，指针指向的是变量所占内存的首地址，在结构体中，指针指向的是结构体变量的起始地址，当然也可指向结构体变量的元素 这里我们分为三部分 7.1指向结构体变量的指针 定义形式一般为 struct 结构体名* 指针名； 比如： struct Student* p； 123456789101112struct Student&#123; char cName[20]; int number; char csex; &#125;student1;struct Student*p;p=&amp;student1;//若为结构体数组则struct Student stu1[5];struct Student*p;p=stu1;//因为stu1为结构体数组而p=stu1直接是指向stu1的首地址，就不用再加&amp;符 用结构体指针变量访问结构体变量成员有以下两种方式：(*p).cName //这里的括号不能少，在5.1中有提到p-&gt;cName 简单来说以下三种形式是等价的 1234p-&gt;cName(*p).cName student1.cNamep-&gt;cName //可以进行正常的运算 p-&gt;number++; 是将结构体变量中number的值进行运算，然后再加一，这里要注意下，等下在7.2中会有比较 7.2指向结构体数组的指针 7.1中我们已经提到结构体数组指针的命名，这里我们仅对一些知识点做下介绍这里我们接着来说结构体数组指针在我们想要用指针访问结构体数组的第n个数据时可以用 1234struct Student stu1[5];struct Student*p;p=stu[n];(++p).number//是指向了结构体数组下一个元素的地址 7.3结构体成员是指针类型变量比如 123456struct Student&#123; char* Name;//这样防止名字长短不一造成空间的浪费 int number; char csex; &#125;student1; 在使用时可以很好地防止内存被浪费，但是注意在引用时一定要给指针变量分配地址，如果你不分配地址，结果可能是对的，但是Name会被分配到任意的一的地址，结构体不为字符串分配任何内存存储空间具有不确定性，这样就存在潜在的危险， 12345678struct Student&#123; char* Name; int number; char csex; &#125;stu，*stu；stu.name=(char*)malloc(sizeof(char));//内存初始化 这里我们说一下，同学们看书的时候一般不会看到，如果我们定义了结构体指针变量，他没有指向一个结构体，那么这个结构体指针也是要分配内存初始化的，他所对应的指针类型结构体成员也要相应初始化分配内存 12345678struct Student&#123; char* Name; int number; char csex; &#125;stu,*stu;stu = (struct student*)malloc(sizeof(struct student));./*结构体指针初始化*/ stu-&gt;name = (char*)malloc(sizeof(char));/*结构体指针的成员指针同样需要初始化*/ 7.4二叉树遍历算法二叉树的二叉链表类型定义如下： typedef struct btnode { datatype data; struct btnode lchild,rchild; }；这里我们仅仅提出以下，因为涉及到链表，感兴趣的同学可以去学习下（二级要用），7.5结构体作为函数参数 首先我们要注意的一点，使用结构体变量作为函数参数的时候，采取的是值传递的方式，将结构体所占内存单元的内容全部传递给形参，并且形参必须也要是同类型的结构体变量，在使用时，会自动创建一个结构体变量作为原变量的副本，并且也需要占内存，并且在调用期间如果修改（形参）结构体中成员的值，修改值是无效的， 而如果用指针作为实参，传递给函数的形参，这时候传递的是结构体的地址，形参所指向的地址就是结构体变量的地址，这时候进行修改的话是可以修改的，这正是指针的精华所在 在这里我们再提供几种互换两个结构体的方法 123456789101112131415161718192021222324252627struct Student&#123; char cName[20]; int number; char csex; &#125;student1,student2;struct Student student1=&#123;"Wang",12345,'W'&#125;;struct Student student2=&#123;"Zhao",54321,'M'&#125;; struct Student*stu1=&amp;student1;struct Student*stu2=&amp;student2;struct Student *student3;student3=stu1;stu1=stu2;stu2=student3;//互换地址2对于同类型结构体直接互换值就行struct stu student3;student3=student1;student1=student2;student2=student3;//这里也可以写成应strcmp函数互换3用memcpy()函数进行互换4比较笨的方法： 用for循环互换 最后提下memset清空结构体 1234567891011121314151617struct Student&#123; char cName[20]; int number; char csex; &#125;stu1;一般情况下，清空str的方法： str.cName[0]='\0'; str.csex='0'; str.number=0; 但是我们用memset就非常方便： memset(&amp;str,0,sizeof(struct Student)); 如果是数组： struct Student stu[10]; 就是 memset(stu,0,sizeof(struct Student)*10); 整理不易，点个赞再走呗！]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[J-Link仿真器与JTAG和SWD下载与接线介绍]]></title>
    <url>%2Fposts%2F4e6e0a9a%2F</url>
    <content type="text"><![CDATA[这篇文章我们简单的介绍下J-Link仿真器，与常用的两种下载方式，以及在MDK和IAR下配置他们的方法，给大家一个简单的认知，关于深入地学习之后会更新 1.JTAG​JTAG诞生于上世纪80年代，JTAG（Joint Test Action Group，联合测试行动小组）是一种国际标准测试协议（IEEE 1149.1兼容），主要用于芯片内部测试。现在多数的高级器件都支持JTAG协议，如ARM、DSP、FPGA器件等，如DSP,FPGA器件等。标准的JTAG接口是4线：TMS、TCK、TDI、TDO，分别为模式选择、时钟、数据输入和数据输出线。 JTAG今天被用来主要的三大功能：1.下载器，即下载软件到FLASH里。 DEBUG(调试)，最重要的东西，多少嵌入式同学的找BUG救星 边界扫描，可以访问芯片内部的信号逻辑状态，还有芯片引脚的状态等等。 JTAG引脚：JTAG发展到现在已经有脚了，通常四个脚：TDI，TDO，TMS，TCK，当然还有个复位脚TRST。对于芯片上的JTAG的脚实际上是专用的。 TDI：测试数据输入，数据通过TDI输入JTAG口； TDO：测试数据输出，数据通过TDO从JTAG口输出； TMS：测试模式选择，用来设置JTAG口处于某种特定的测试模式； TCK：测试时钟输入； GND ： 就是地线啦 VCC : 供电的电源线 可选引脚： RESET:仿真器输出至目标CPU的系统复位信号；使得仿真器能够在连接器件前对器件进行复位， TRST：测试复位，输入引脚，低电平有效，是可选引脚。 本篇文章主要是为了让大家了解与认识，同学们只需要记住它是一个测试协议，让我们烧录芯片的一个协议方式即可。并且绝大多数芯片都支持JTAG协议，使用十分广泛 ， 2.SWDSWD是ARM公司提出的另一种调试接口，相对于JTAG接口，使用更少的信号和接口，与JTAG的20个引脚相比，SWD只需要4个（或者5个）引脚，较少的引脚与简便的接线使得SWD模式也备受欢迎，并且这几年SWD下载速度也有了显著的提高，在一些较小的PCB上可以使用它，所用面积小，并且较为简便，数据不易丢失 SWD引脚：Vref：目标表参考电压信号，用于检测目标板是否供电，直接与目标板VDD相连，并不向外提供输出电压； GND: 公共地信号； SWDIO:串行数据输入信号，作为仿真信号的双向数据信号线，建议上拉； SWCLK：串行时钟输入，作为仿真信号的时钟信号线，建议下拉； 可选择引脚： SWO：串行数据输出，CPU调试接口可通过SWO输出一些调试信息，可选引脚。 RESET:仿真器输出至目标CPU的系统复位信号；使得仿真器能够在连接器件前对器件进行复位，是可选引脚， JTag和SWD模式引脚定义 在我们使用的20pin的J-Link上 TMS == SWDIOTCLK == SWCLK ​​​​​​​​​​​​ 关于SWD同学们记住它是不同于SWD的一种下载方式，并且接线简便，所用引脚少即可 J-Link仿真器J-Link是SEGGER公司为支持仿真ARM内核芯片推出的JTAG仿真器。配合IAR EWAR，ADS，KEIL，WINARM，RealView等集成开发环境支持所有ARM7/ARM9/ARM11，Cortex M0/M1/M3/M4， Cortex A5/A8/A9等内核芯片的仿真，与IAR，Keil等编译环境无缝连接，操作方便、连接方便、简单易学，是学习开发ARM最好最实用的开发工具。 LINK仿真器目前已经升级到V9.1版本，其仿真速度和功能远非简易的并口WIGGLER调试器可比。J-LINK支持ARM7/ARM9/ARM11，Cortex M0/M1/M3/M4， Cortex A4/A8/A9等内核芯片，支持ADS、IAR、KEIL开发环境 简单来说： J-Link是一个JTAG协议转换盒，它通过USB传输，在仿真器内部转换成JTAG协议，实现了了一个从软件到硬件转换的工作。使用者只需要一个USB接口，便可以实现JTAG下载， 在以前JTAG协议都是用20pin的转接头(上图)，但是随着时代的发展，很多电脑都不在配备并口的，取而代之的是越来越多的USB接口，这就随之而诞生了J-Link仿真器，只需要一个USB接口，使用者就可以实现芯片的烧录与调试，极大地方便了工作并简便了电脑接口 也就是J-Link仿真器就是一个USB到JTAG的转换盒，连接端为电脑的USB接口，而到芯片内部则会转换为jtag协议，就是一个转换小黑盒 目前普遍在售的为V9版本 当然了作为要支持仿真ARM内核的仿真器 J-Link不止支持JTAG 同样支持SWD下载 SWD下载方式接线： 可自行用杜邦线连接或做转接板 ​​​​​​ IAR与MDK配置两种下载方式在连接上芯片之后，可以先查看是否找到芯片​​​​IAR:打开工程文件，在项目文件-右键-Options​​ 找到J-Link/J-Trace - Connection -选择下载模式 MDK: 首先确定下载方式正确 然后Settings​​ 之后可以修改下载方式与下载速度，注意下方为USB 模式 ​​]]></content>
      <categories>
        <category>嵌入式学习</category>
      </categories>
      <tags>
        <tag>嵌入式学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单片机的内存分配(变量的存储位置)详解]]></title>
    <url>%2Fposts%2F5da490ab%2F</url>
    <content type="text"><![CDATA[对于初学者而言，对单片机的内存分配往往最让人头疼，很多人学了单片机几年 都不知道单片机内部的内存使用情况是如何分配的。要了解 ROM、RAM启动，首先 需要对 链接器 Linker 如何分配内存有一定的了解。 通常，对于栈生长方向向下的单片机，其内存一般模型是： 一个进程运行时，所占用的内存，可以分为如下几个部分：1、栈区（stack）：由编译器自动分配释放，存放函数的参数值，局部变量的值等。2、堆区（heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS释放。3、全局变量、静态变量：初始化的全局变量和静态变量放在一块区域，未初始化的全局变量和和未初始化的静态变量在相邻的的另一块区域。程序结束后由系统自动释放。4、文字常量：常量字符串就是存放在这里的，程序结束后由系统释放。5、程序代码：存放函数体的二进制代码。 同时，单片机内存被总分为flash(rom)和sram（ram），flash里面的数据掉电可保存，sram中的数据掉电就丢失，sram的执行速度要快于flash，flash容量大于sram 上方的最低内存地址，最高地址，都是在flash和sram中 我们正常下载程序都是下载存储进flash里面，这也是为什么断电可保存的原因 单片机的程序存储分为code(代码存储区)、RO-data(只读数据存储区)、RW-data(读写数据存储区) 和 ZI-data(零初始化数据区) Flash 存储 code和RO-data Sram 存储 RW-data 和ZI-data 在使用MDK编译时可以看到 Code为程序代码部分 = 程序代码区(code) RO-data 表示 程序定义的常量 = 文字常量区 RW-data 表示 已初始化的全局变量 = 栈区（stack）堆区（heap）全局区（静态区）（static） ZI-data 表示 未初始化的全局变量]]></content>
      <categories>
        <category>嵌入式学习</category>
      </categories>
      <tags>
        <tag>嵌入式学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#上位机开发]]></title>
    <url>%2Fposts%2F43905%2F</url>
    <content type="text"><![CDATA[等待更新，有时间会写下]]></content>
      <categories>
        <category>C#上位机</category>
      </categories>
      <tags>
        <tag>C#上位机</tag>
      </tags>
  </entry>
</search>
