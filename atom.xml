<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Z小旋</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zxiaoxuan.cn/"/>
  <updated>2019-09-30T13:42:28.836Z</updated>
  <id>http://zxiaoxuan.cn/</id>
  
  <author>
    <name>Zxiaoxuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于MT9V032的障碍识别功能</title>
    <link href="http://zxiaoxuan.cn/posts/31100/"/>
    <id>http://zxiaoxuan.cn/posts/31100/</id>
    <published>2019-09-29T07:44:48.998Z</published>
    <updated>2019-09-30T13:42:28.836Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>今天在翻以前的一些云存储文件，看到了之前搞过的一个障碍识别的视频，感觉还挺有意思的，就想着写一下，把整个代码流程搞顺点，那么先简单的介绍下摄像头和芯片把</p></blockquote><a id="more"></a><h3 id="摄像头："><a href="#摄像头：" class="headerlink" title="摄像头："></a>摄像头：</h3><p>本质是一种半导体芯片，其表面包含有几十万到几百万的光电二极管。光电二极管受到光照射时，就会产生电荷   目前我们使用的是CMOS摄像头</p><p><img src="https://img-blog.csdnimg.cn/20190929145602569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>网上找的图，先将就着看</p><p>一个摄像头硬件上包括五个部分：，<strong>镜头(Lens) ，对焦马达，红外滤光片(IR cutfilter)，图像传感器(Image Sensor) 和挠性印刷电路板(FPCB)。</strong></p><h3 id="镜头-Lens"><a href="#镜头-Lens" class="headerlink" title="镜头(Lens)"></a>镜头(Lens)</h3><p>它的主要作用就是收集外部的光线，将光线汇聚到图像传感器上  ，传递为<strong>光信号</strong>，镜头的好坏决定了你摄像头图像的清晰度与成像质量<br><img src="https://img-blog.csdnimg.cn/20190929145913438.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="对焦马达"><a href="#对焦马达" class="headerlink" title="对焦马达"></a>对焦马达</h2><p>这个咱不是太懂，到时候学习了再介绍把</p><h2 id="红外滤波片"><a href="#红外滤波片" class="headerlink" title="红外滤波片"></a>红外滤波片</h2><p>红外滤波片的主要作用是滤除不能被人眼观察不到的紫外光和红外光，是位于镜头和图像传感器之间的部件<br><img src="https://img-blog.csdnimg.cn/20190929150557590.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>因为目前大部分的图像传感器都是基于RGB三原色成像的，而最原始的RAW文件数据每个像素点，只有三种颜色要么是红，要么是蓝，要么是绿(rgb三原色)，最后经过图像传感器处理之后得到我们所看到的彩色图片，但是图像传感器并不能区分与过滤紫外光和红外光，在读取镜头传递过来的光信号时，就会导致读取的数据不准确，处理之后的图像与真实颜色会有很大差距，图像色彩的还原度就会变得很差，因此需要红外滤波片来解决这个问题</p><h2 id="图像传感器"><a href="#图像传感器" class="headerlink" title="图像传感器"></a>图像传感器</h2><p><img src="https://img-blog.csdnimg.cn/2019092915155829.png" alt="在这里插入图片描述"><br>摄像头的核心部件，你可以理解为单片机的MCU   将镜头传递的光信号处理，转换为电信号，再通过内部的DA转换为数字信号，图像的像素，对焦成像，等等功能都取决于它，传感器的每个pixel只能感光R光或者B光或者G光，因此每个像素此时存贮的是单色的，我们称之为RAW  DATA数据</p><p>我们目前使用都是CMOS图像传感器  其性能远远优于线性CCD摄像头</p><h2 id="印刷电路板-FPCB"><a href="#印刷电路板-FPCB" class="headerlink" title="印刷电路板(FPCB)"></a>印刷电路板(FPCB)</h2><p>PCB负责将摄像头的其他组件与主处理器连接起来，完成整个摄像头功能的连接与实现，并将图像传单器得到的信号通过数据总线传输出去，完成图像的数据读取与显示功能</p><p>关于CMOS摄像头硬件原理与数据处理这里我们就不说了，比较复杂，有想去的可自行百度，</p><p>之后还是先看下视频效果把，代码和讲解之后有时间会更新</p><p>因为使用的MT9V032是一款纯裸摄像头，图像读取,二值化等等都需要自己去写底层，可能讲起来有点难度，最近实在是没时间去写了，之后有时间会更新，或者加入<strong>智能车实验室</strong>啊，可以学到更多东西呀</p><iframe src="http://player.bilibili.com/player.html?aid=69378028&cid=120243545&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;今天在翻以前的一些云存储文件，看到了之前搞过的一个障碍识别的视频，感觉还挺有意思的，就想着写一下，把整个代码流程搞顺点，那么先简单的介绍下摄像头和芯片把&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="NXP智能车" scheme="http://zxiaoxuan.cn/categories/NXP%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    
      <category term="NXP智能车" scheme="http://zxiaoxuan.cn/tags/NXP%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【c语言】宏</title>
    <link href="http://zxiaoxuan.cn/posts/62824/"/>
    <id>http://zxiaoxuan.cn/posts/62824/</id>
    <published>2019-09-28T14:57:59.964Z</published>
    <updated>2019-09-28T15:03:54.005Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>c语言宏的简单认识，列举了C语言目前已有的预处理分类</p></blockquote><a id="more"></a><h2 id="什么是宏？"><a href="#什么是宏？" class="headerlink" title="什么是宏？"></a>什么是宏？</h2><p>宏是学习任何语言所不可缺少的，优秀的宏定义可以使得代码变得很简洁且高效，有效地提高编程效率。</p><p>宏是一种预处理指令，它提供了一种机制，可以用来替换源代码中的字符串，解释器或编译器在遇到宏时会自动进行这一模式替换</p><p>C语言有简单的宏系统，由编译器或汇编器的预处理器实现。C的宏预处理器的工作只是简单的文本搜索和替换，</p><p>C语言的宏非常简单，我们只需要做好宏定义，其余交给<strong>编译器预处理</strong>即可</p><h2 id="C语言的宏-预处理功能-有以下几类："><a href="#C语言的宏-预处理功能-有以下几类：" class="headerlink" title="C语言的宏(预处理功能)有以下几类："></a>C语言的宏(预处理功能)有以下几类：</h2><ol><li>宏定义 </li><li>包含头文件的宏 </li><li>条件编译宏 </li><li>预定义宏</li></ol><h3 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h3><p>c程序提供的预处理功能之一。包括带参数的宏定义和不带参数的宏定义。具体是指用一个指定的标志符来进行简单的字符串替换或者进行阐述替换。形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  标志符[（参数表）] 字符串</span></span><br></pre></td></tr></table></figure><p>其中“#”表示这是一条预处理命令(在 C 语言中凡是以“#”开头的均为预处理命令)“define”为宏定义命令,“标识符”为所定义的宏名, “字符串”可以是常数、表达式、格式串等。符号常量的定义就是一种无参宏定义</p><p>常见使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//宏定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//取消宏</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> SIZE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普通宏</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.1415926</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//带参数的宏</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) ((a)&gt;(b)? (a),(b))</span></span><br></pre></td></tr></table></figure><p>其实宏定义就是一个简单的字符串替换，将前面的字符串替换成后面的字符串。</p><p>当然要注意，<strong>#define宏定义的作用仅仅是替换</strong>，它只是一个简单的替换,<br>比如下方代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>   m(a,b)  a*3+b*4</span></span><br><span class="line"></span><br><span class="line">c = m(<span class="number">5</span>+<span class="number">6</span>,<span class="number">2</span>+<span class="number">4</span>)</span><br><span class="line"><span class="comment">//C的结果等于41</span></span><br></pre></td></tr></table></figure><p>这里的宏定义仅仅是将a换为5+6  而不是11 将b换位2+4 而不是6<br>因此顺序应该是  5+6<em>3+2+4</em>4 = 41</p><p>如果想要实际的预期结果 则需要</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>   m(a,b)  a*3+b*4</span></span><br><span class="line"></span><br><span class="line">c = m((<span class="number">5</span>+<span class="number">6</span>),(<span class="number">2</span>+<span class="number">4</span>))  <span class="comment">//应该使用括号将其包围</span></span><br><span class="line"><span class="comment">//C的结果等于57</span></span><br></pre></td></tr></table></figure><p>再比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> point (int*);</span></span><br><span class="line"></span><br><span class="line">point a,b;</span><br></pre></td></tr></table></figure><p>本意是a和b都是int型指针，但是实际上变成int* a,b;</p><p>a是int型指针，而b是int型变量。</p><p>这点要尤为注意</p><p><strong>宏连接：</strong></p><p>C语言中，使用两个#即可将两个字符连接成为一个</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A1 printf(<span class="meta-string">"print A1\r\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A2 printf(<span class="meta-string">"print A2\r\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A(NAME) A##NAME</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会打印：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print A1</span><br></pre></td></tr></table></figure><p>在该例子中，调用宏A(1)时，NAME为1。A##NAME这个符号连接，即将A和1连接成了一个符号A1，然后执行宏A1的内容。最终打印出来了print A1</p><p>还有就是</p><p><strong>无法通过宏展开的方式创建预处理器命令</strong>。即使宏的展开结果会生成形式上有效的命令，但预处理器不会执行它</p><p>你所要知道的小知识：</p><ol><li>定义宏不占用内存，只有在使用时才分配内存</li><li>宏定义不存在类型问题，它的参数也是无类型的</li><li><strong>字符串” “中不能使用宏定义</strong></li><li>预处理是在编译之前的处理，而编译工作的任务之一就是语法检查，预处理不做语法检查</li><li>宏替换在预处理阶段进行，函数调用在编译后程序运行时进行，并且分配内存。预处理在编译之前，因此宏替换不分配内存</li><li><strong>宏定义前面的替换必须是C语言合法的用户标识符</strong>     如 #define 0a  25   就是错误的</li><li><strong>重复定义的宏只有最后一个是有效的</strong></li><li>宏定义不是C语句，不必在行未加“；”号，如果加了连“；”号一起进行置换；</li></ol><h2 id="包含头文件的宏"><a href="#包含头文件的宏" class="headerlink" title="包含头文件的宏"></a>包含头文件的宏</h2><p>用一个<code>include</code>表示，引入的头文件有两种区别</p><p>一种是C语言自带的头文件,用 <code>&lt;&gt;</code>来表示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>编译的时候会在编译器的<code>bin</code>目录下面查找  </p><p>另一种是用户自定义头文件，用<code>&quot;&quot;</code>来表示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"LED.h"</span></span></span><br></pre></td></tr></table></figure><p>编译时从对应自定义文件路径查找</p><p>当然 ，C语言自带头文件也可以使用 <code>&quot;&quot;</code>   这个我们讲解下：</p><ul><li><code>“”</code>先在自定义路径查找有无该头文件，有则包含该目录下的头文件，没有则到系统指定的目录下找该头文件</li><li><code>&lt;&gt;</code>直接到系统指定的目录下查找该文件</li></ul><p>也就是说使用双引号比使用尖括号多了一个查找路径</p><p>#include 引入头文件的本质就是<strong>源码替换</strong>，预处理的时候将那些.h文件中的代码替换到头文件引入的位置进行编译   比如printf就会从stdio.h中寻找对应源码，之后进行替换，再替换以后的结果再交给编译器处理，进行编译。</p><h2 id="条件编译宏"><a href="#条件编译宏" class="headerlink" title="条件编译宏"></a>条件编译宏</h2><p>c语言中条件编译相关的预编译指令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>            定义一个预处理宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span>            取消宏的定义</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>                   编译预处理中的条件命令，相当于C语法中的<span class="meta-keyword">if</span>语句</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>              判断某个宏是否被定义，若已定义，执行随后的语句</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span>            与#<span class="meta-keyword">ifdef</span>相反，判断某个宏是否未被定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span>                若#<span class="meta-keyword">if</span>, #<span class="meta-keyword">ifdef</span>, #<span class="meta-keyword">ifndef</span>或前面的#<span class="meta-keyword">elif</span>条件不满足，则执行#<span class="meta-keyword">elif</span>之后的语句，相当于C语法中的<span class="meta-keyword">else</span>-<span class="meta-keyword">if</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>              与#<span class="meta-keyword">if</span>, #<span class="meta-keyword">ifdef</span>, #<span class="meta-keyword">ifndef</span>对应, 若这些条件不满足，则执行#<span class="meta-keyword">else</span>之后的语句，相当于C语法中的<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>             #<span class="meta-keyword">if</span>, #<span class="meta-keyword">ifdef</span>, #<span class="meta-keyword">ifndef</span>这些条件命令的结束标志.</span></span><br><span class="line">defined         　与<span class="meta">#<span class="meta-keyword">if</span>, #<span class="meta-keyword">elif</span>配合使用，判断某个宏是否被定义</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span>            编译程序时如果遇到#<span class="meta-keyword">error</span>就会生成一个编译错误提示信息并停止编译</span></span><br></pre></td></tr></table></figure><p>举个简单的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  ZZX</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  ZZX</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"定义了Z小旋"</span>); </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"没有定义Z小旋"</span>); </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>上面的代码就会输出定义Z小旋   而不满足条件的代码就不会编译</p><p>我们经常使用条件编译来定义头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _DataCollect_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _DataCollect_H_</span></span><br><span class="line"></span><br><span class="line">#代码块</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>条件编译再我们正常程序的编写中是非常见的，你可以使用条件编译完成模块不同功能的设置，比如你想要用一套代码编译一个产品的两个功能，使用条件编译，一个#ifndef  即可完成两个不同代码块的切换，决定编译的时候生成的是哪个功能的代码。</p><h3 id="总览图"><a href="#总览图" class="headerlink" title="总览图"></a>总览图</h3><p><img src="https://img-blog.csdnimg.cn/20190928212046526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h2><table><thead><tr><th>宏名称</th><th>功能</th></tr></thead><tbody><tr><td>_<em>LINE_</em></td><td>正在编译的文件的行号</td></tr><tr><td>_<em>FILE_</em></td><td>正在编译的文件的名字</td></tr><tr><td>_DATE_</td><td>编译时刻的日期字符串</td></tr><tr><td>_TIME_</td><td>编译时刻的时间字符串</td></tr><tr><td>_STDC_</td><td>判断该程序是否为标准的c程序</td></tr></tbody></table><p>标准的预定义宏都是用一两个下划线字符开头和结尾，<strong>这类宏不能被#undef所取消也不能被编程人员重新定义和修改</strong>     ，常用来说明文件信息等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Date : %s\n"</span>, __DATE__);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Time : %s\n"</span>, __TIME__);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"File : %s\n"</span>, __FILE__);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Line : %d\n"</span>, __LINE__);</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Date : Sep <span class="number">28</span> <span class="number">2019</span></span><br><span class="line">Time : <span class="number">21</span>:<span class="number">46</span>:<span class="number">50</span></span><br><span class="line">File : C:\Users\<span class="number">48013</span>\Desktop\小学弟的渣渣c\预定义宏.c</span><br><span class="line">Line : <span class="number">6</span></span><br></pre></td></tr></table></figure><p>剩余部分宏：</p><table><thead><tr><th>宏名称</th><th>功能</th></tr></thead><tbody><tr><td>_<em>STDC_VERSION_</em></td><td>表示ISO C的版本</td></tr><tr><td>_<em>STDC_HOSTED_</em></td><td>如果值为1的话，表示目标环境有完成的标准C库</td></tr><tr><td>_<em>BYTE_ORDER_</em></td><td>表示当前环境的字节序</td></tr><tr><td>_<em>LP64_</em></td><td>表示当前环境是不是64位，如果该值为1，则环境为64位环境</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;c语言宏的简单认识，列举了C语言目前已有的预处理分类&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C语言" scheme="http://zxiaoxuan.cn/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C语言" scheme="http://zxiaoxuan.cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【STM32】HAL库 STM32CubeMX教程八---定时器输入捕获</title>
    <link href="http://zxiaoxuan.cn/posts/18833/"/>
    <id>http://zxiaoxuan.cn/posts/18833/</id>
    <published>2019-09-25T16:00:00.000Z</published>
    <updated>2019-09-30T13:48:33.772Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>本系列教程将<strong>外设原理，HAL库与STM32CubeMX结合在一起讲解</strong>，使您可以更快速的学会各个模块的使用</p><p><strong>所用工具：</strong></p><p>1、芯片： STM32F407ZET6/STM32F103ZET6</p><p>2、STM32CubeMx软件</p><p>3、IDE： MDK-Keil软件</p><p>4、STM32F1xx/STM32F4xxHAL库 </p><p>5</p><p><strong>知识概括：</strong></p><p>通过本篇博客您将学到：</p><p>SMT32定时器输入捕获</p><p> 测量PWM频率和占空比</p><h1 id="输入捕获"><a href="#输入捕获" class="headerlink" title="输入捕获"></a>输入捕获</h1><h3 id="输入捕获概念"><a href="#输入捕获概念" class="headerlink" title="输入捕获概念"></a><strong>输入捕获概念</strong></h3><p>输入捕获模式可以用来测量脉冲宽度或者测量频率。STM32的定时器，除了TIM6、TIM7，其他的定时器都有输入捕获的功能。</p><p>具体请参看<a href="https://blog.csdn.net/as480133937/article/details/99201209" target="_blank" rel="noopener">《【STM32】HAL库 STM32CubeMX教程六—-定时器中断》</a></p><h3 id="输入捕获的工作原理"><a href="#输入捕获的工作原理" class="headerlink" title="输入捕获的工作原理"></a>输入捕获的工作原理</h3><p><img src="https://img-blog.csdnimg.cn/20190813094532466.png" alt></p><p>①先设置输入捕获为上升沿检测，</p><p>②记录发生上升沿时TIMx_CNT(计数器)的值</p><p>③配置捕获信号为下降沿捕获，当下降沿到来的时候发生捕获</p><p>④记录此时的TIMx_CN(计数器)T的值</p><p>⑤前后两次TIMx_CNT(计数器)的值之差就是高电平的脉宽。同时根据TIM的计数频率，我们就能知道高电平脉宽的准确时间。</p><p>简单说：</p><p><strong>当你设置的捕获开始的时候，cpu会将计数寄存器的值复制到捕获比较寄存器中并开始计数，当再次捕捉到电平变化时，这是计数寄存器中的值减去刚才复制的值就是这段电平的持续时间，你可以设置上升沿捕获、下降沿捕获、或者上升沿下降沿都捕获，</strong></p><h3 id="输入捕获的工作流程-对应CubeMx的四个选项"><a href="#输入捕获的工作流程-对应CubeMx的四个选项" class="headerlink" title="输入捕获的工作流程(对应CubeMx的四个选项)"></a>输入捕获的工作流程(对应CubeMx的四个选项)</h3><p><img src="https://img-blog.csdn.net/20180419215648175" alt></p><h3 id="设置输入捕获滤波器"><a href="#设置输入捕获滤波器" class="headerlink" title="设置输入捕获滤波器"></a>设置输入捕获滤波器</h3><p>STM32在很多功能中都提供了滤波器，滤波器的功能简单来说就是<strong>多次检测视为一次有效，达到滤波效果，</strong></p><p>数字滤波器由一个事件计数器组成，假设我们是检测高电平，滤波N次，那么记录到N个事件后计数器会产生一个输出的跳变。也就是说连续N次采样检测，如果都是高电平，则说明这是一个有效的电平信号，这样便可以过滤掉那些因为某些而干扰产生的一些信号        </p><p><strong>输入捕获滤波器IC1F[3:0]，这个用于设置采样频率和数字滤波器长度</strong>。其中：fCK_INT是定时器的输入频率，fDTS是根据TIMx_CR1的CKD[1:0]的设置来确定的。</p><h3 id="设置输入捕获极性"><a href="#设置输入捕获极性" class="headerlink" title="设置输入捕获极性"></a>设置输入捕获极性</h3><p><strong>设置具体为那种</strong>捕获事件</p><p><strong>可以设置上升沿捕获、下降沿捕获、或者上升沿下降沿都捕获</strong></p><h3 id="设置输入捕获映射关系"><a href="#设置输入捕获映射关系" class="headerlink" title="设置输入捕获映射关系"></a>设置输入捕获映射关系</h3><p>STM32为了更好的优化使用，TIMx_CH1通道1捕捉到的信号可以传输到IC1，TIMx_CH1捕捉到的信号也可以连接到IC2，TIMx_CH2捕捉到的信号也可以连接到IC2，也可以连接到IC2</p><p><img src="https://img-blog.csdnimg.cn/20190813111456218.png" alt></p><h3 id><a href="#" class="headerlink" title=" "></a> </h3><h3 id="设置输入捕获分频器"><a href="#设置输入捕获分频器" class="headerlink" title="设置输入捕获分频器"></a>设置输入捕获分频器</h3><p>设置<strong>每N个事件触发一次捕获**</strong>，可以设置为1/2/4/8次检测到电平变化才触发捕获**</p><h3 id="溢出时间计算："><a href="#溢出时间计算：" class="headerlink" title="溢出时间计算："></a>溢出时间计算：</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTIwNzU3Ni8yMDE4MDUvMTIwNzU3Ni0yMDE4MDUxMzE2MzY1OTkxOC04NzQ4NDYxNTIucG5n" alt></p><p>t1时刻检测到高电平，发生中断，在中断里将计数值置0，开始记溢出次数N，</p><p>其中每计数0xFFFF次溢出一次，直到t2时刻跳变回低电平，</p><p>获取最后一次溢出时到t2时刻的计数值TIM5CH1_CAPTURE_VAL</p><p>则 ** 高电平时间 = 溢出次数<em>65535+TIM5CH1_CAPTURE_VAL     us*</em> ；根据定时器初始化时的频率即可计算出溢出总次数所占用的时间，即为高电平时间。</p><p>如果计数器值为 <strong>32 bit</strong>  那么最大为0xFFFFFFFF      </p><p><strong>高电平时间：</strong></p><pre><code>![](https://img-blog.csdnimg.cn/20190813172958716.png)</code></pre><h3 id="输入捕获的工作框图"><a href="#输入捕获的工作框图" class="headerlink" title="输入捕获的工作框图"></a>输入捕获的工作框图</h3><p><img src="https://img-blog.csdn.net/20180419213733338" alt></p><h3 id="工程创建"><a href="#工程创建" class="headerlink" title="工程创建"></a>工程创建</h3><p><strong>设置RCC</strong></p><p><strong>设置高速外部时钟HSE 选择外部时钟源</strong></p><p><img src="https://img-blog.csdnimg.cn/20190810145615696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p><strong>2设置时钟</strong></p><p><img src="https://img-blog.csdnimg.cn/2019081117400555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p>*<em>我的是  外部晶振为8MHz *</em></p><ul><li><p>*<em>1选择外部时钟HSE 8MHz   *</em></p></li><li><p><strong>2PLL锁相环倍频72倍</strong></p></li><li><p><strong>3系统时钟来源选择为PLL</strong></p></li><li><p><strong>4设置APB1分频器为 /2</strong></p></li><li><p><strong>5 这时候定时器的时钟频率为72Mhz</strong></p></li></ul><p><strong>32的时钟树框图</strong>  如果不懂的话请看<a href="https://blog.csdn.net/as480133937/article/details/98845509" target="_blank" rel="noopener">《【STM32】系统时钟RCC详解(超详细，超全面)》</a></p><p><strong>3定时器配置</strong></p><p><img src="https://img-blog.csdnimg.cn/20190813120324793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p>这里我们选择TIM5的通道1</p><ul><li><p>预分频系数为71   计数时钟频率就是 72MHz/(71+1) = 1MHz        此时<strong>1us</strong>计数一次</p></li><li><p>自动加载值设置为32bit最大值  0xFFFFFFFF          </p></li><li><p><strong>上升沿捕获</strong></p></li><li><p>不分频</p></li><li><p>滤波值为8</p></li></ul><p><strong>同时在NVIC一栏使能TIM5的中断</strong></p><p><strong>对应引脚设置下拉电阻</strong>，保证没有信号输入的时候电平稳定</p><p><img src="https://img-blog.csdnimg.cn/20190813152340197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p><strong>4项目文件设置</strong></p><p><img src="https://img-blog.csdnimg.cn/20190811193124463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt>          </p><ul><li><p>1 设置项目名称</p></li><li><p>2 设置存储路径</p></li><li><p>3 选择所用IDE</p></li></ul><p>   <img src="https://img-blog.csdnimg.cn/2019080921100765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p><strong>5创建工程文件</strong></p><p>然后点击*<em>GENERATE CODE  *</em>创建工程</p><h3 id="配置下载工具"><a href="#配置下载工具" class="headerlink" title="配置下载工具"></a>配置下载工具</h3><p>新建的工程所有配置都是默认的  我们需要自行选择下载模式，勾选上下载后复位运行</p><h3 id="-1"><a href="#-1" class="headerlink" title></a><img src="https://img-blog.csdnimg.cn/20190809172359875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></h3><h3 id="例程实现："><a href="#例程实现：" class="headerlink" title="例程实现："></a>例程实现：</h3><p>定义变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/* USER CODE BEGIN 0 */    uint32\_t capture\_Buf\[3\] = &#123;0&#125;;   //存放计数值    uint8\_t capture\_Cnt = 0;    //状态标志位    uint32\_t high\_time;   //高电平时间/* USER CODE END 0 */</span><br></pre></td></tr></table></figure><p>在 while(1)中的用户代码区 3，写入TIM2 CH1通道的输入捕获控制和数据处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">while (1)</span><br><span class="line">&#123;    /* USER CODE END WHILE */</span><br><span class="line"></span><br><span class="line">    /* USER CODE BEGIN 3 */</span><br><span class="line">  switch (capture_Cnt)&#123;case 0:</span><br><span class="line">capture_Cnt++;</span><br><span class="line">\_\_HAL\_TIM\_SET\_CAPTUREPOLARITY(&amp;htim5, TIM\_CHANNEL\_1, TIM\_INPUTCHANNELPOLARITY\_RISING);</span><br><span class="line">HAL\_TIM\_IC\_Start\_IT(&amp;htim5, TIM\_CHANNEL\_1);//启动输入捕获       或者: \_\_HAL\_TIM_ENABLE(&amp;htim5);</span><br><span class="line">break;case 3:</span><br><span class="line">high\_time = capture\_Buf\[1\]- capture_Buf\[0\];    //高电平时间</span><br><span class="line">HAL\_UART\_Transmit(&amp;huart1, (uint8\_t *)high\_time, 1, 0xffff);   //发送高电平时间</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HAL_Delay(1000);   //延时1S</span><br><span class="line">capture_Cnt = 0;  //清空标志位</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;/* USER CODE END 3 */</span><br></pre></td></tr></table></figure><p>在main函数下方添加中断回调函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/* USER CODE BEGIN 4 */void HAL\_TIM\_IC\_CaptureCallback(TIM\_HandleTypeDef *htim)&#123;</span><br><span class="line">if(TIM5 == htim-&gt;Instance)</span><br><span class="line">&#123;switch(capture_Cnt)&#123;case 1:</span><br><span class="line">capture\_Buf\[0\] = HAL\_TIM\_ReadCapturedValue(&amp;htim5,TIM\_CHANNEL_1);//获取当前的捕获值.</span><br><span class="line">\_\_HAL\_TIM\_SET\_CAPTUREPOLARITY(&amp;htim5,TIM\_CHANNEL\_1,TIM\_ICPOLARITY\_FALLING);  //设置为下降沿捕获</span><br><span class="line">capture_Cnt++;break;case 2:</span><br><span class="line">capture\_Buf\[1\] = HAL\_TIM\_ReadCapturedValue(&amp;htim5,TIM\_CHANNEL_1);//获取当前的捕获值.</span><br><span class="line">HAL\_TIM\_IC\_Stop\_IT(&amp;htim5,TIM\_CHANNEL\_1); //停止捕获   或者: \_\_HAL\_TIM_DISABLE(&amp;htim5);</span><br><span class="line">capture_Cnt++;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;/* USER CODE END 4 */</span><br></pre></td></tr></table></figure><p>具体流程：</p><p>1.设置TIM5 CH1为输入捕获功能；  </p><p>2.设置上升沿捕获； </p><p>3.使能TIM2 CH1捕获功能；  </p><p>4.捕获到上升沿后，定时器当前计数值存入capture_buf[0]，改为捕获下降沿；   </p><p> 5.捕获到下降沿后，定时器当前计数值存入存入capture_buf[1]，关闭TIM2 CH1捕获功能；  capture_Cnt=3；</p><ol start="6"><li>高电平时间： capture_buf[1] - capture_buf[0]        发送到上位机  重新启动输入捕获</li></ol><p><strong>__HAL_TIM_SET_COUNTER(&amp;TIM5_Handler,0);</strong>   //设置计数寄存器的值变为0</p><p><strong>HAL_TIM_PWM_Start</strong>()              函数用于使能定时器某一通道的PWM输出。</p><p><strong>HAL_TIM_IC_Start_IT</strong>()                  函数用于使能定时器某一通道的输入捕获功能，并使能相应的中断</p><p><strong>HAL_TIM_IC_Stop_IT</strong>()                 函数和开启功能相反，是关闭定时器某一通道的输入捕获功能和相应中断</p><p><strong>__HAL_TIM_SET_CAPTUREPOLARITY</strong>不是函数，而是底层操作的一个宏定义</p><p>在stm32f4xx_hal_tim.h文件中可以找到。其作用是修改定时器某一通道的输入捕获极性</p><p><img src="https://img-blog.csdnimg.cn/20190813171232499.png" alt></p><p>其中有两个函数，第一个为清除<strong>清除原来的捕获极性</strong>，第二个为设置<strong>通道捕捉极性</strong></p><p><strong>等价于：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIM\_RESET\_CAPTUREPOLARITY(&amp;TIM5\_Handler,TIM\_CHANNEL\_1);   //一定要先清除原来的捕获极性！！TIM\_SET\_CAPTUREPOLARITY(&amp;TIM5\_Handler,TIM\_CHANNEL\_1,TIM\_ICPOLARITY\_FALLING);//定时器5通道1设置为下降沿捕获（重设捕获极性）</span><br></pre></td></tr></table></figure><p><strong>在修改定时器某一通道的输入捕获极性时，一定要先清除该通道之前捕获极性</strong></p><p><strong>__HAL_TIM_GET_COMPARE</strong>也是一个宏定义。 <br>在stm32f4xx_hal_tim.h文件中可以找到。其作用是获取定时器某一通道的捕获/比较寄存器值</p><p><img src="https://img-blog.csdnimg.cn/20190813171323391.png" alt></p><p><strong>等价于 ：  HAL_TIM_ReadCapturedValue(&amp;htim5,TIM_CHANNEL_1);</strong></p><p>  两者都是直接读取对应CCRx寄存器的值</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt;本系列教程将&lt;strong&gt;外设原理，HAL库与STM32CubeMX结合在一起讲解&lt;/strong&gt;，使您可以更快速的学会各个模块
      
    
    </summary>
    
      <category term="STM32" scheme="http://zxiaoxuan.cn/categories/STM32/"/>
    
    
      <category term="STM32" scheme="http://zxiaoxuan.cn/tags/STM32/"/>
    
  </entry>
  
  <entry>
    <title>【STM32】系统时钟RCC详解(超详细，超全面)</title>
    <link href="http://zxiaoxuan.cn/posts/52363/"/>
    <id>http://zxiaoxuan.cn/posts/52363/</id>
    <published>2019-09-22T13:30:53.663Z</published>
    <updated>2019-09-23T00:40:15.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1什么是时钟"><a href="#1什么是时钟" class="headerlink" title="1什么是时钟"></a>1什么是时钟</h2><p><strong>时钟是单片机运行的基础，时钟信号推动单片机内各个部分执行相应的指令。</strong>时钟系统就是CPU的脉搏，决定cpu速率，像人的心跳一样 只有有了心跳，人才能做其他的事情，而单片机有了时钟，才能够运行执行指令，才能够做其他的处理 (点灯，串口，ADC)，时钟的重要性不言而喻。</p><p><strong>为什么 STM32 要有多个时钟源呢？</strong></p><p>STM32本身十分复杂，外设非常多  但我们实际使用的时候只会用到有限的几个外设，使用任何外设都需要时钟才能启动，但并不是所有的外设都需要系统时钟那么高的频率，为了兼容不同速度的设备，有些高速，有些低速，如果都用高速时钟，势必造成浪费   并且，同一个电路，时钟越快功耗越快，同时抗电磁干扰能力也就越弱，所以较为复杂的MCU都是采用多时钟源的方法来解决这些问题。所以便有了STM32的时钟系统和时钟树</p><h3 id="总括："><a href="#总括：" class="headerlink" title="总括："></a>总括：</h3><ul><li><p>STM32时钟系统主要的目的就是<strong>给相对独立的外设模块提供时钟</strong>，也是为了<strong>降低整个芯片的耗能</strong>。</p></li><li><p>系统时钟，是处理器运行时间基准（每一条机器指令一个时钟周期）</p></li><li><p><strong>时钟是单片机运行的基础，时钟信号推动单片机内各个部分执行相应的指令。</strong></p></li><li><p><strong>一个单片机内提供多个不同的系统时钟，可以适应更多的应用场合。</strong></p></li><li><p><strong>不同的功能模块会有不同的时钟上限，因此提供不同的时钟，也能在一个单片机内放置更多的功能模块。<br>对不同模块的时钟增加开启和关闭功能，可以降低单片机的功耗</strong></p></li><li><p>STM32为了低功耗，他将所有的外设时钟都设置为disable(不使能)，用到什么外设，只要打开对应外设的时钟就可以， 其他的没用到的可以还是disable(不使能)，这样耗能就会减少。  这就是为什么<strong>不管你配置什么功能都需要先打开对应的时钟</strong>的原因</p></li></ul><h1 id="STM32的时钟系统框图"><a href="#STM32的时钟系统框图" class="headerlink" title="STM32的时钟系统框图"></a>STM32的时钟系统框图</h1><p><img src="https://img-blog.csdnimg.cn/2019080810214187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p>===</p><p>乍一看很吓人，但其实很好理解，我们看*<em>系统时钟SYSCLK 的左边  系统时钟有很多种选择，而左边的部分就是设置系统时钟使用那个时钟源，   *</em></p><p><strong>系统时钟SYSCLK 的右边，则是系统时钟通过AHB预分频器，给相对应的外设设置相对应的时钟频率</strong></p><p><strong>从左到右可以简单理解为  各个时钟源—&gt;系统时钟来源的设置—&gt;各个外设时钟的设置</strong></p><h1 id="时钟系统"><a href="#时钟系统" class="headerlink" title="时钟系统"></a>时钟系统</h1><h3 id="1各个时钟源-左边的部分"><a href="#1各个时钟源-左边的部分" class="headerlink" title="1各个时钟源    (左边的部分)"></a><strong>1各个时钟源    (左边的部分)</strong></h3><p>STM32 有<strong>4个</strong>独立时钟源:HSI、HSE、LSI、LSE。<br>①、HSI是高速内部时钟，RC振荡器，频率为8MHz，精度不高。<br>②、HSE是高速外部时钟，可接石英/陶瓷谐振器，或者接外部时钟源，频率范围为<strong>4MHz~16MHz</strong>。<br>③、LSI是低速内部时钟，RC振荡器，频率为40kHz，提供低功耗时钟。　<br>④、LSE是低速外部时钟，接频率为32.768kHz的石英晶体。</p><p><strong>其中LSI是作为IWDGCLK(独立看门狗)时钟源和RTC时钟源</strong> *<em>而独立使用 *</em></p><p><strong>而HSI高速内部时钟 HSE高速外部时钟 LSI低速内部时钟  这三个经过分频或者倍频 作为系统时钟来使用</strong></p><p>PLL为锁相环倍频输出，其时钟输入源可选择为<strong>HSI/2、HSE或者HSE/2</strong>。倍频可选择为<strong>2~16</strong>倍，但是其输出频率最大不得超过72MHz。  <strong>通过倍频之后作为系统时钟的时钟源</strong></p><p><strong>举个例子：</strong>Keil编写程序是默认的时钟为72Mhz，其实是这么来的：外部晶振(<strong>HSE</strong>)提供的8MHz（与电路板上的晶振的相关）通过<strong>PLLXTPRE分频器</strong>后，进入<strong>PLLSRC选择开关</strong>，进而通过<strong>PLLMUL锁相环</strong>进行倍频（x9）后，为系统提供72MHz的系统时钟（SYSCLK）。之后是AHB预分频器对时钟信号进行分频，然后为低速外设提供时钟。</p><p>或者<strong>内部RC振荡器(HSI) 为</strong>8MHz  /2 为4MHz 进入<strong>PLLSRC选择开关</strong>，通过<strong>PLLMUL锁相环</strong>进行倍频（x16）后 为72MHz</p><h3 id><a href="#" class="headerlink" title=" "></a> </h3><p>PS:  网上有很多人说是5个时钟源，这种说法有点问题，学习之后就会发现PLL并不是自己产生的时钟源，而是通过其他三个时钟源倍频得到的时钟</p><h3 id="2系统时钟SYSCLK"><a href="#2系统时钟SYSCLK" class="headerlink" title="2系统时钟SYSCLK"></a>2系统时钟SYSCLK</h3><p>系统时钟SYSCLK可来源于三个时钟源：<br>①、HSI振荡器时钟<br>②、HSE振荡器时钟<br>③、PLL时钟<br>最大为72Mhz</p><p><img src="https://img-blog.csdnimg.cn/20190808112745842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><h3 id="3USB时钟"><a href="#3USB时钟" class="headerlink" title="3USB时钟"></a><strong>3USB时钟</strong></h3><p><img src="https://img-blog.csdnimg.cn/20190808112421863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p>STM32中有一个全速功能的USB模块，其串行接口引擎需要一个频率为48MHz的时钟源。该时钟源只能从PLL输出端获取（唯一的），，可以选择为1.5分频或者1分频，也就是，当需要使用USB模块时，PLL必须使能，并且时钟频率配置为48MHz或72MHz</p><h3 id="4把时钟信号输出到外部"><a href="#4把时钟信号输出到外部" class="headerlink" title="4把时钟信号输出到外部"></a><strong>4把时钟信号输出到外部</strong></h3><p><img src="https://img-blog.csdnimg.cn/20190808112900726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p>STM32可以选择一个时钟信号输出到MCO脚(PA8)上，可以选择为PLL输出的2分频、HSI、HSE、或者系统时钟。可以把时钟信号输出供外部使用</p><h3 id="5系统时钟通过AHB分频器给外设提供时钟-右边的部分-重点"><a href="#5系统时钟通过AHB分频器给外设提供时钟-右边的部分-重点" class="headerlink" title="5系统时钟通过AHB分频器给外设提供时钟(右边的部分)  重点"></a>5系统时钟通过AHB分频器给外设提供时钟(右边的部分)  重点</h3><p><strong>从左到右可以简单理解为  系统时钟—&gt;AHB分频器—&gt;各个外设分频倍频器 —&gt;   外设时钟的设置</strong></p><p>右边部分为：<strong>系统时钟SYSCLK通过AHB分频器分频后送给各模块使用</strong>，AHB分频器可选择1、2、4、8、16、64、128、256、512分频。其中AHB分频器输出的时钟送给5大模块使用：   </p><p>　①<strong>内核总线：</strong>送给AHB总线、内核、内存和DMA使用的HCLK时钟。   </p><p>　②<strong>Tick定时器：</strong>通过8分频后送给Cortex的系统定时器时钟。   </p><p>　③I2S总线：直接送给Cortex的空闲运行时钟FCLK。   </p><p>　④<strong>APB1外设：</strong>送给APB1分频器。<strong>APB1分频器可选择1、2、4、8、16分频</strong>，其输出一路供APB1外设使用(PCLK1，最大频率36MHz)，另一路送给通用定时器使用。该倍频器可选择1或者2倍频，时钟输出供定时器2-7使用。   </p><p>　⑤<strong>APB2外设：</strong>送给APB2分频器。APB2分频器可选择1、2、4、8、16分频，其输出一路供APB2外设使用(PCLK2，最大频率72MHz)，另一路送给高级定时器。该倍频器可选择1或者2倍频，时钟输出供定时器1和定时器8使用。</p><p>另外，APB2分频器还有一路输出供ADC分频器使用，分频后送给ADC模块使用。ADC分频器可选择为2、4、6、8分频。 </p><p>需要注意的是，如果 APB 预分频器分频系数是 1，则定时器时钟频率 (TIMxCLK) 为 PCLKx。否则，定      时器时钟频率将为 APB 域的频率的两倍：TIMxCLK = 2xPCLKx。 </p><h3 id="APB1和APB2的对应外设"><a href="#APB1和APB2的对应外设" class="headerlink" title="APB1和APB2的对应外设"></a>APB1和APB2的对应外设</h3><h3 id="F1系列"><a href="#F1系列" class="headerlink" title="F1系列"></a>F1系列</h3><p><img src="https://img-blog.csdnimg.cn/20190808142757981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p><strong>APB1上面连接的是低速外设，包括电源接口、备份接口、CAN、USB、I2C1、I2C2、USART2、USART3、UART4、UART5、SPI2、SP3等；</strong></p><p><strong>而APB2上面连接的是高速外设，包括UART1、SPI1、Timer1、ADC1、ADC2、ADC3、所有的普通I/O口（PA-PE）、第二功能I/O（AFIO）口等。</strong></p><h3 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h3><p>F4系列</p><p><img src="https://img-blog.csdnimg.cn/20190808144124332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p><strong>这个和F1系列类似，我们就举几个特殊的</strong></p><p> APB2总线:高级定时器timer1, timer8以及通用定时器timer9, timer10, timer11   UTART1,USART6</p><p> APB1总线:通用定时器timer2~timer5，通用定时器timer12~timer14以及基本定时器timer6,timer7  UTART2~UTART5</p><p><strong>F4系列的系统时钟频率最高能到168M</strong></p><p><strong>具体  可以在 stm32f10x_rcc.h  和stm32f40x_rcc.h   中查看</strong></p><p><strong>或者通过 STM32参考手册搜索“系统架构”或者“系统结构”  查看外设挂在哪个时钟下</strong>，</p><h3 id="RCC相关寄存器："><a href="#RCC相关寄存器：" class="headerlink" title="RCC相关寄存器："></a>RCC相关寄存器：</h3><p>这里我们以F1系列为例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RCC 寄存器结构，RCC_TypeDeff，在文件“stm32f10x.h”中定义如下：<span class="number">1059</span>行-&gt;<span class="number">1081</span>行。：  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  &#123;</span>  vu32 CR;                  <span class="comment">//HSI,HSE,CSS,PLL等的使能  vu32 CFGR;              //PLL等的时钟源选择以及分频系数设定 vu32 CIR;                // 清除/使能 时钟就绪中断 vu32 APB2RSTR;      //APB2线上外设复位寄存器 vu32 APB1RSTR;      //APB1线上外设复位寄存器 vu32 AHBENR;         //DMA，SDIO等时钟使能 vu32 APB2ENR;       //APB2线上外设时钟使能 vu32 APB1ENR;      //APB1线上外设时钟使能 vu32 BDCR;           //备份域控制寄存器 vu32 CSR;             </span></span><br><span class="line">&#125; RCC_TypeDef;</span><br></pre></td></tr></table></figure><p>可以对上上面的时钟框图和RCC寄存器来学习，对STM32的时钟系统有个大概的了解   其实也就是我们上面介绍的流程，理解了自然也就能写出来</p><h3 id="RCC初始化："><a href="#RCC初始化：" class="headerlink" title="RCC初始化："></a>RCC初始化：</h3><p>这里我们使用HSE(外部时钟），正常使用的时候也都是使用外部时钟</p><p>使用HSE时钟，程序设置时钟参数流程：<br>1、将RCC寄存器重新设置为默认值   RCC_DeInit;<br>2、打开外部高速时钟晶振HSE       RCC_HSEConfig(RCC_HSE_ON);<br>3、等待外部高速时钟晶振工作      HSEStartUpStatus = RCC_WaitForHSEStartUp();<br>4、设置AHB时钟         RCC_HCLKConfig;<br>5、设置高速AHB时钟     RCC_PCLK2Config;<br>6、设置低速速AHB时钟   RCC_PCLK1Config;<br>7、设置PLL              RCC_PLLConfig;<br>8、打开PLL              RCC_PLLCmd(ENABLE);<br>9、等待PLL工作          while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)<br>10、设置系统时钟        RCC_SYSCLKConfig;<br>11、判断是否PLL是系统时钟     while(RCC_GetSYSCLKSource() != 0x08)<br>12、打开要使用的外设时钟      RCC_APB2PeriphClockCmd()/RCC_APB1PeriphClockCmd()</p><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><p>对RCC的配置函数(使用外部8MHz晶振)  </p><p>系统时钟72MHz，APH 72MHz，APB2 72MHz，APB1 32MHz，USB 48MHz TIMCLK=72M</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RCC_Configuration</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="comment">//----------使用外部RC晶振-----------</span></span><br><span class="line">RCC_DeInit();<span class="comment">//初始化为缺省值</span></span><br><span class="line">RCC\_HSEConfig(RCC\_HSE_ON);<span class="comment">//使能外部的高速时钟 </span></span><br><span class="line"><span class="keyword">while</span>(RCC\_GetFlagStatus(RCC\_FLAG_HSERDY) == RESET);<span class="comment">//等待外部高速时钟使能就绪</span></span><br><span class="line"></span><br><span class="line">FLASH\_PrefetchBufferCmd(FLASH\_PrefetchBuffer_Enable);<span class="comment">//Enable Prefetch Buffer</span></span><br><span class="line">FLASH\_SetLatency(FLASH\_Latency_2);<span class="comment">//Flash 2 wait state</span></span><br><span class="line"></span><br><span class="line">RCC\_HCLKConfig(RCC\_SYSCLK_Div1);<span class="comment">//HCLK = SYSCLK</span></span><br><span class="line">RCC\_PCLK2Config(RCC\_HCLK_Div1);<span class="comment">//PCLK2 =  HCLK</span></span><br><span class="line">RCC\_PCLK1Config(RCC\_HCLK_Div2);<span class="comment">//PCLK1 = HCLK/2</span></span><br><span class="line">RCC\_PLLConfig(RCC\_PLLSource\_HSE\_Div1,RCC\_PLLMul\_9);<span class="comment">//PLLCLK = 8MHZ * 9 =72MHZ</span></span><br><span class="line">RCC_PLLCmd(ENABLE);<span class="comment">//Enable PLLCLK</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(RCC\_GetFlagStatus(RCC\_FLAG_PLLRDY) == RESET);<span class="comment">//Wait till PLLCLK is ready</span></span><br><span class="line">    RCC\_SYSCLKConfig(RCC\_SYSCLKSource_PLLCLK);<span class="comment">//Select PLL as system clock</span></span><br><span class="line"><span class="keyword">while</span>(RCC_GetSYSCLKSource()!=<span class="number">0x08</span>);<span class="comment">//Wait till PLL is used as system clock source</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//---------打开相应外设时钟--------------------</span></span><br><span class="line">RCC\_APB2PeriphClockCmd(RCC\_APB2Periph_GPIOA,ENABLE);<span class="comment">//使能APB2外设的GPIOA的时钟 &#125;</span></span><br></pre></td></tr></table></figure><p>也就是我们时钟树框图从左到右的配置，</p><h3 id="时钟监视系统（CSS）"><a href="#时钟监视系统（CSS）" class="headerlink" title="时钟监视系统（CSS）"></a>时钟监视系统（CSS）</h3><p><img src="https://img-blog.csdnimg.cn/20190808151802853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p>STM32还提供了一个时钟监视系统（CSS），用于监视高速外部时钟（HSE）的工作状态。倘若HSE失效，会自动切换（高速内部时钟）HSI作为系统时钟的输入，保证系统的正常运行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1什么是时钟&quot;&gt;&lt;a href=&quot;#1什么是时钟&quot; class=&quot;headerlink&quot; title=&quot;1什么是时钟&quot;&gt;&lt;/a&gt;1什么是时钟&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;时钟是单片机运行的基础，时钟信号推动单片机内各个部分执行相应的指令。&lt;/strong&gt;时钟系
      
    
    </summary>
    
      <category term="STM32" scheme="http://zxiaoxuan.cn/categories/STM32/"/>
    
    
      <category term="STM32" scheme="http://zxiaoxuan.cn/tags/STM32/"/>
    
  </entry>
  
  <entry>
    <title>【STM32】 定时器---正交解码编码器模式详解</title>
    <link href="http://zxiaoxuan.cn/posts/51504/"/>
    <id>http://zxiaoxuan.cn/posts/51504/</id>
    <published>2019-09-22T13:29:18.693Z</published>
    <updated>2019-09-22T13:29:18.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="增量式编码器"><a href="#增量式编码器" class="headerlink" title="增量式编码器"></a>增量式编码器</h1><p>增量式编码器也成为正交编码器，是通过两个信号线的脉冲输出来进行数据处理，一个输出脉冲信号就对应于一个增量位移，编码器每转动固定的位移，就会产生一个脉冲信号  通过读取<strong>单位时间脉冲信号的数量</strong>，便可以达到测速的效果(<strong>v=s/t</strong>），通过对<strong>脉冲信号的累加，和编码器的码盘的周长(转一圈对应距离) ** 便可以达到计算行走距离的效果(</strong>s=n<em>d*</em>)</p><h3 id="编码器信号："><a href="#编码器信号：" class="headerlink" title="*编码器信号： *"></a>*<em>编码器信号： *</em></h3><ul><li><p><strong>A</strong> 脉冲输出 </p></li><li><p><strong>B</strong> 脉冲输出 </p></li><li><p><strong>Z</strong> 零点信号 当编码器旋转到零点时，Z信号会发出一个脉冲表示现在是零位置 表示编码器转了1圈，可用来记录编码器转了多少圈，从而知道运行距离</p></li><li><p><strong>VCC</strong> 电源线</p></li><li><p><strong>GND</strong> 地线</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20190807151156129.png" alt></p><h3 id="编码器线数："><a href="#编码器线数：" class="headerlink" title="编码器线数："></a><strong>编码器线数：</strong></h3><p>编码器的线数 ,是说编码器转一圈输出多少个脉冲,,,如果一个编码器是500线,说明这个编码器转一圈对应的信号线会输出500个脉冲, A B两相转一圈发出的脉冲数一样的,不过存在90°相位差</p><p><strong>线数越高代表编码器能够反应的位置精度越高</strong></p><h3 id="编码器原理："><a href="#编码器原理：" class="headerlink" title="编码器原理："></a><strong>编码器原理：</strong></h3><p>增量式编码器有两个脉冲输出，A相和B相，并且两个相位永远存在90°相位差。 如果两个信号相位差为90度，则这两个信号称为正交。由于两个信号相差90度，因此可以根据两个信号哪个先哪个后来判断方向、并且可以根据AB相脉冲信号数量测得速度，位移等，</p><h3 id="编码器正反转："><a href="#编码器正反转：" class="headerlink" title="编码器正反转："></a><strong>编码器正反转：</strong></h3><p><img src="https://img-blog.csdn.net/20160125151941378" alt="这里写图片描述"></p><p><strong>正转的时候信号线A先输出信号,信号线B后输出  A相超前B相90度  证明是正转</strong></p><p><strong>反转的时候信号线B先输出信号,信号线A后输出 B相超前A相90度 证明是反转</strong></p><h1 id="STM32定时器编码器模式"><a href="#STM32定时器编码器模式" class="headerlink" title="STM32定时器编码器模式"></a>STM32定时器编码器模式</h1><p>   <img src="https://img-blog.csdnimg.cn/20190807161611281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p>STM32的编码器模式共有三种：</p><ul><li><p><strong>仅在TL1计数(A相)</strong></p></li><li><p>** 仅在TL2计数(B相)**</p></li><li><p>** 在TL1和TL2都计数(A相和B相都计数)**</p></li></ul><h3 id="仅在TL1计数-A相"><a href="#仅在TL1计数-A相" class="headerlink" title="仅在TL1计数(A相)"></a><strong>仅在TL1计数(A相)</strong></h3><p>   <img src="https://img-blog.csdnimg.cn/20190807170944950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt>               </p><p><strong>TI2(B相)为高电平时：</strong></p><p>1时刻： <strong>TI1(A相)下降沿，  则向上计数(正转)。</strong></p><p>2时刻：<strong>TI1(A相)上升沿，   则向下计数(反转)</strong></p><p><strong>TI2(B相)为低电平时：</strong></p><p>3时刻： <strong>TI1(A相)上升沿，  则向上计数(正转)。</strong></p><p>4时刻：<strong>TI1(A相)下降沿，   则向下计数(反转)</strong></p><h3 id="仅在TL2计数-B相"><a href="#仅在TL2计数-B相" class="headerlink" title="仅在TL2计数(B相)"></a><strong>仅在TL2计数(B相)</strong></h3><p><img src="https://img-blog.csdnimg.cn/20190807171439114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p><strong>TI1(A相)为高电平时：</strong></p><p>1时刻： <strong>TI2(B相)上升沿，  则向上计数(正转)。</strong></p><p>2时刻：<strong>TI2(B相)下降沿，   则向下计数(反转)</strong></p><p><strong>TI2(B相)为低电平时：</strong></p><p>3时刻： <strong>TI2(B相)下降沿，  则向上计数(正转)。</strong></p><p>4时刻：<strong>TI2(B相)上升沿，   则向下计数(反转)</strong></p><h3 id="在TL1和TL2都计数-A相和B相都计数"><a href="#在TL1和TL2都计数-A相和B相都计数" class="headerlink" title="在TL1和TL2都计数(A相和B相都计数)"></a><strong>在TL1和TL2都计数(A相和B相都计数)</strong></h3><p><img src="https://img-blog.csdnimg.cn/20190807172048512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p><strong>一个脉冲信号周期完成4次跳变。精度提高</strong></p><p><strong>1时刻：TI2为低电平，TI1上升沿跳变，计数器向上计数；</strong></p><p><strong>2时刻：TI1为高电平，TI2上升沿跳变，计数器仍然向上计数；</strong></p><p><strong>3时刻：TI2为高电平，TI1下降沿跳变，计数器仍然向上计数；</strong></p><p><strong>4时刻：TI1为低电平，TI2下降沿跳变，计数器仍然向上计数。</strong>  </p><p><strong>毛刺：只有一个相位脉冲   过滤掉 编码器转动过程中可能产生的毛刺过滤掉</strong></p><p><strong>计数器向下计数原理相同   看图即可很好理解。</strong></p><p><strong>计数器向下计数：</strong></p><p>A下降沿，B低电平<br>B下降沿，A高电平<br>B上升沿，A低电平<br>A上升沿，B高电平</p><p>上升沿与下降沿参看 <a href="https://blog.csdn.net/as480133937/article/details/97396383" target="_blank" rel="noopener">《外部中断—-高低电平触发,(边沿触发)上升沿触发和下降沿触发区别》</a></p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul><li><p>需要增加测量的精度时，可以采用4倍频方式，即分别在A、B相波形的上升沿和下降沿计数，分辨率可以提高4倍，</p></li><li><p>如果只是测速,不要求方向，那么只需要用单片机随意选择一个信号线就行了,,然后定时器边沿触发，检测脉冲计数即可</p></li><li><p>一般是定时器的通道1和2才能作为编码器输入口，对应编码器输出的两相。</p></li><li><p>GPIO配置为配置为上拉输入模式</p></li><li><p><strong>一个定时器做一种工作</strong>，如果你配置了编码器模式，那么剩下的通道就不能配置其他模式</p></li><li><p>两相计数模式下，  *<em>读出来数需要/4 *</em>         *<em>一个脉冲信号对应四次计数   *</em></p></li></ul><h3 id="编码器配置标准外设库"><a href="#编码器配置标准外设库" class="headerlink" title="编码器配置标准外设库"></a>编码器配置标准外设库</h3><p>TIM_EncoderInterfaceConfig，它就是编码器接口的配置函数。简单的只需要配置该函数，使能TIM，即可实现采集编码器上面的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void TIM\_EncoderInterfaceConfig(TIM\_TypeDef* TIMx, uint16\_t TIM\_EncoderMode,                                uint16\_t TIM\_IC1Polarity, uint16\_t TIM\_IC2Polarity)</span><br></pre></td></tr></table></figure><p>TIMx参数就是使用哪个定时器作为编码器接口的捕捉定时器。</p><p>TIM_EncoderMode参数是模式，是单相计数(<strong>仅在TL1计数或仅在TL2计数</strong>)还是两相计数(<strong>在TL1和TL2都计数)</strong>。</p><p>TIM_IC1Polarity和TIM_IC2Polarity参数就是通道1、2的捕捉极性。</p><h3 id><a href="#" class="headerlink" title=" "></a> </h3><h3 id="相关寄存器配置"><a href="#相关寄存器配置" class="headerlink" title="相关寄存器配置"></a>相关寄存器配置</h3><p>● CC1S=’01’ (TIMx_CCMR1寄存器，IC1FP1映射到TI1)</p><p>● CC2S=’01’ (TIMx_CCMR2寄存器，IC2FP2映射到TI2)</p><p>● CC1P=’0’ (TIMx_CCER寄存器，IC1FP1不反相，IC1FP1=TI1)</p><p>● CC2P=’0’ (TIMx_CCER寄存器，IC2FP2不反相，IC2FP2=TI2)</p><p>● SMS=’011’ (TIMx_SMCR寄存器，所有的输入均在上升沿和下降沿有效).</p><p>● CEN=’1’ (TIMx_CR1寄存器，计数器使能) </p><p>*<em>如果计数器只在TI2的边沿计数，则置TIMx_SMCR寄存器中的SMS=001；如果只在TI1边沿计数，则置SMS=010；如果计数器同时在TI1和TI2边沿计数，则置SMS=011 *</em></p><h3 id="编码器模式功能："><a href="#编码器模式功能：" class="headerlink" title="编码器模式功能："></a>编码器模式功能：</h3><ul><li><p>stm32f407中<strong>定时器1、2、3、4、5、8</strong>提供编码器接口模式 </p></li><li><p>可以对输入信号TI1,TI2进行<strong>滤波处理</strong>，数字滤波器由事件器组成，每N个事件才视为一个有效边沿，可以在TIMx_CCMR1、TIMx_CCMR2中的IC1F位域设置      *<em>也就是可以设置每产生几次脉冲才视为1次有效  *</em></p></li></ul><h3 id="各个值的计算："><a href="#各个值的计算：" class="headerlink" title="各个值的计算："></a>各个值的计算：</h3><p><strong>转速计算方法:</strong>用捕获值（一秒内输出的脉冲数）/编码器线数（转速一圈输出脉冲数）/电机减数比（内部电机转动圈数与电机输出轴转动圈数比，即减速齿轮比    没有则不用除）</p><p><strong>运动距离计算</strong>：输出的总脉冲数 / 编码器线数*编码器齿轮周长</p><p><strong>所转角度计算</strong>：    <strong>输出的总脉冲数 / 编码器线数 *360</strong>     或    <strong>溢出中断次数*360+当前计数值</strong> </p><p><strong>转动方向</strong>： *<em>方向在定时器CR1的DIR位里   *</em>dir=(TIMX-&gt;CR1 &amp; 0x0010)&gt;&gt;4;     //取方向标志位<br>if(dir &gt; 0)  //向下计数     else     //向上计数</p><p>那么我们直接看代码：</p><p>定时器初始化设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">void TIM3\_Int\_Init() &#123;</span><br><span class="line">    TIM\_TimeBaseInitTypeDef TIM\_TimeBaseInitStructure;</span><br><span class="line">    TIM\_ICInitTypeDef TIM\_ICInitStructure;</span><br><span class="line">    NVIC\_InitTypeDef NVIC\_InitStructure;</span><br><span class="line"></span><br><span class="line">    RCC\_APB1PeriphClockCmd(RCC\_APB1Periph_TIM3,ENABLE); </span><br><span class="line"></span><br><span class="line">//定时器设置-------------------------------------------------------------    </span><br><span class="line">  TIM\_TimeBaseInitStructure.TIM\_Period = 359*4;  //重装载值   </span><br><span class="line">    TIM\_TimeBaseInitStructure.TIM\_Prescaler=0x0;  //预分频</span><br><span class="line">    TIM\_TimeBaseInitStructure.TIM\_CounterMode=TIM\_CounterMode\_Up; //向上计数</span><br><span class="line">    TIM\_TimeBaseInitStructure.TIM\_ClockDivision=TIM\_CKD\_DIV1; //时钟分割</span><br><span class="line"></span><br><span class="line">    TIM\_TimeBaseInit(TIM3,&amp;TIM\_TimeBaseInitStructure);//初始化TIM3//编码器模式设置--------------------------------------------------------------                 </span><br><span class="line"></span><br><span class="line">    TIM\_EncoderInterfaceConfig(TIM3,TIM\_EncoderMode\_TI12,TIM\_ICPolarity\_Rising, TIM\_ICPolarity_Rising);//计数模式3</span><br><span class="line"></span><br><span class="line">    TIM\_ICStructInit(&amp;TIM\_ICInitStructure); //将结构体中的内容缺省输入</span><br><span class="line">    TIM\_ICInitStructure.TIM\_ICFilter = 0;//滤波器值</span><br><span class="line">    TIM\_ICInit(TIM3, &amp;TIM\_ICInitStructure);  //将TIM_ICInitStructure中的指定参数初始化TIM3//溢出中断设置--------------------------------------------------------------  </span><br><span class="line">    TIM\_ITConfig(TIM3,TIM\_IT_Update,ENABLE); //允许TIM3溢出中断</span><br><span class="line"></span><br><span class="line">    NVIC\_InitStructure.NVIC\_IRQChannel=TIM3_IRQn; </span><br><span class="line">    NVIC\_InitStructure.NVIC\_IRQChannelPreemptionPriority=0x01; </span><br><span class="line">    NVIC\_InitStructure.NVIC\_IRQChannelSubPriority=0x01; </span><br><span class="line">    NVIC\_InitStructure.NVIC\_IRQChannelCmd=ENABLE;</span><br><span class="line">    NVIC\_Init(&amp;NVIC\_InitStructure);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  TIM_SetCounter(TIM3,0); //TIM3-&gt;CNT=0</span><br><span class="line">  TIM_Cmd(TIM3, ENABLE); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重装载值：    (<strong>编码器线数-1 ) *4                因为我们是两相计数，一个脉冲信号4次计数，所以乘4，保证转完1整圈才触发中断</strong></p><p>中断设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int circle\_count=0;//圈数void TIM3\_IRQHandler(void)&#123;    if(TIM\_GetITStatus(TIM3,TIM\_IT_Update)==SET)</span><br><span class="line">    &#123;       </span><br><span class="line">        if((TIM3-&gt;CR1&gt;&gt;4 &amp; 0x01)==0) //DIR==0</span><br><span class="line">            circle_count++;        else if((TIM3-&gt;CR1&gt;&gt;4 &amp; 0x01)==1)//DIR==1</span><br><span class="line">            circle_count--;</span><br><span class="line">    &#125;</span><br><span class="line">    TIM\_ClearITPendingBit(TIM3,TIM\_IT_Update); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各个值的计算：</p><p>脉冲数：  TIM_GetCounter(TIM3)/4  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int angle=0;  //转过总角度int Realyangle = 0;  //当前实际角度 0~360int Distiance=0;   //运行距离extern int circle\_count;   //转过圈数Realyangle = TIM\_GetCounter(TIM3)/4/360 ;      //先除4   最后除编码器线数angle=Realyangle +circle\_count\*360;//当前角度Distiance = angle/360\*编码器齿轮周长  + circle\_count*编码器齿轮周长</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;增量式编码器&quot;&gt;&lt;a href=&quot;#增量式编码器&quot; class=&quot;headerlink&quot; title=&quot;增量式编码器&quot;&gt;&lt;/a&gt;增量式编码器&lt;/h1&gt;&lt;p&gt;增量式编码器也成为正交编码器，是通过两个信号线的脉冲输出来进行数据处理，一个输出脉冲信号就对应于一个增量位移
      
    
    </summary>
    
      <category term="STM32" scheme="http://zxiaoxuan.cn/categories/STM32/"/>
    
    
      <category term="STM32" scheme="http://zxiaoxuan.cn/tags/STM32/"/>
    
  </entry>
  
  <entry>
    <title>【STM32】STM32F4 GPIO八种模式及工作原理详解</title>
    <link href="http://zxiaoxuan.cn/posts/15066/"/>
    <id>http://zxiaoxuan.cn/posts/15066/</id>
    <published>2019-09-22T13:25:59.983Z</published>
    <updated>2019-09-23T00:37:51.918Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-GPIO简介"><a href="#1-GPIO简介" class="headerlink" title="1 GPIO简介"></a>1 GPIO简介</h2><p><strong>GPIO</strong>,即通用I/O(输入/输出)端口，是STM32可控制的引脚。STM32芯片的GPIO引脚与外部设备连接起来，可实现与外部通讯、控制外部硬件或者采集外部硬件数据的功能。</p><p>*<em>STM32F407有7组IO。分别为GPIOA~GPIOG，每组IO有16个IO口，共有112个IO口  通常称为 PAx、PBx、PCx、PDx、PEx、PFx、PGx，其中x为0-15。  并且F4系列是基于Cortex-M4内核  *</em></p><p><strong>GPIO的复用：</strong></p><p>STM32F4 有很多的<strong>内置外设</strong>，这些外设的外部引脚都是与 GPIO 共用的。也就是说，<strong>一个引脚可以有很多作用，但是默认为IO口，如果想使用一个 GPIO内置外设的功能引脚，就需要GPIO的复用，那么当这个 GPIO 作为内置外设使用的时候，就叫做复用。</strong>    比如说串口  就是GPIO复用为串口</p><h2 id="2-GPIO的工作模式"><a href="#2-GPIO的工作模式" class="headerlink" title="2 GPIO的工作模式"></a>2 GPIO的工作模式</h2><p><strong>1、4种输入模式</strong></p><p>（1）GPIO_Mode_IN_FLOATING 浮空输入<br>（2）GPIO_Mode_IPU 上拉输入<br>（3）GPIO_Mode_IPD 下拉输入<br>（4）GPIO_Mode_AIN 模拟输入</p><p>*<em>2、4种输出模式 *</em></p><p>（5）GPIO_Mode_Out_OD 开漏输出（带上拉或者下拉）<br>（6）GPIO_Mode_AF_OD 复用开漏输出（带上拉或者下拉）<br>（7）GPIO_Mode_Out_PP 推挽输出（带上拉或者下拉）<br>（8）GPIO_Mode_AF_PP 复用推挽输出（带上拉或者下拉）<br><strong>3、4种最大输出速度</strong><br>（1）2MHZ  (低速)<br>（2）25MHZ  (中速)<br>（3）50MHZ  (快速)<br>（4）100MHZ  (高速)</p><p><strong>关于他们的定义，都在  stm32f4xx_gpio.h 中，都为结构体形式的定义</strong></p><h2 id="3-GPIO框图剖析"><a href="#3-GPIO框图剖析" class="headerlink" title="3 GPIO框图剖析"></a>3 <strong>GPIO框图剖析</strong></h2><p><img src="https://img-blog.csdnimg.cn/20190801161834709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p>我们所用到的每一个GPIO其内部结构都是这样，分别对应着GPIO的八种模式  这里我们简单的介绍下：</p><ul><li><p><strong>保护二极管：  IO引脚上下两边两个二极管用于防止引脚外部过高、过低的电压输入，</strong>当<strong>引脚电压高于VDD_FT**</strong>时，上方的二极管导通，当引脚电压低于VSS时，下方的二极管导通，防止不正常电压引入芯片导致芯片烧毁 **</p></li><li><p><strong>上拉、下拉电阻：控制引脚默认状态的电压，开启上拉的时候引脚默认电压为高电平，开启下拉的时候引脚默认电压为低电平</strong></p></li><li><p><strong>TTL施密特触发器：</strong>基本原理是当输入电压高于正向阈值电压，输出为高；当输入电压低于负向阈值电压，输出为低；<strong>IO口信号经过触发器后，模拟信号转化为0和1的数字信号    也就是高低电平  并且是TTL电平协议   这也是为什么STM32是TTL电平协议的原因</strong></p></li><li><p><strong>P-MOS管和N-MOS管</strong>：<strong>信号由P-MOS管和N-MOS管，依据两个MOS管的工作方式，使得GPIO具有“推挽输出”和“开漏输出”的模式     P-MOS管高电平导通，低电平关闭，下方的N-MOS低电平导通，高电平关闭</strong></p></li></ul><p>注：  *<em>VDD_FT  代表IO口，兼容3.3V和5V，如果没有标注“FT”，就代表着不兼容5V      *</em></p><p> 在芯片数据手册的引脚定义中，会看到<strong>有“I/O电平”一列  有FT即为支持5V</strong></p><p><img src="https://img-blog.csdnimg.cn/20190801175317972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><h3 id="4-GPIO的八种工作模式剖析："><a href="#4-GPIO的八种工作模式剖析：" class="headerlink" title="4 GPIO的八种工作模式剖析："></a>4 GPIO的八种工作模式<strong>剖析</strong>：</h3><h3 id="浮空输入模式"><a href="#浮空输入模式" class="headerlink" title="浮空输入模式"></a>浮空输入模式</h3><h3 id><a href="#" class="headerlink" title></a><img src="https://img-blog.csdnimg.cn/20190801191842465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></h3><p><strong>浮空输入模式下，I/O端口的电平信号直接进入输入数据寄存器。MCU直接读取I/O口电平，I/O的电平状态是不确定的，完全由外部输入决定；如果在该引脚悬空（在无信号输入）的情况下，读取该端口的电平是不确定的。 (</strong>接用电压表测量其引脚电压为1点几伏，这是个不确定值*<em>) *</em>以用来做KEY识别</p><h3 id="上拉输入模式"><a href="#上拉输入模式" class="headerlink" title="上拉输入模式"></a>上拉输入模式</h3><pre><code>![](https://img-blog.csdnimg.cn/20190801194218819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)</code></pre><p>** IO内部接上拉电阻，此时如果IO口外部没有信号输入或者引脚悬空，IO口默认为高电平  如果I/O口输入低电平，那么引脚就为低电平，MCU读取到的就是低电平**</p><p><strong>STM32的内部上拉是”弱上拉”，即通过此上拉输出的电流是很弱的，如要求大电流还是需要外部上拉。</strong></p><h3 id="下拉输入模式"><a href="#下拉输入模式" class="headerlink" title="下拉输入模式"></a>下拉输入模式</h3><pre><code>![](https://img-blog.csdnimg.cn/20190801195135782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)</code></pre><p>** IO内部接下拉电阻，此时如果IO口外部没有信号输入或者引脚悬空，IO口默认为低电平  如果I/O口输入高电平，那么引脚就为高电平，MCU读取到的就是高电平**</p><h3 id="模拟输入模式"><a href="#模拟输入模式" class="headerlink" title="模拟输入模式"></a>模拟输入模式</h3><pre><code>![](https://img-blog.csdnimg.cn/20190801200336884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)</code></pre><p><strong>当GPIO引脚用于ADC采集电压的输入通道时，用作”模拟输入”功能，此时信号不经过施密特触发器，直接直接进入ADC模块，并且输入数据寄存器为空 ，CPU不能在输入数据寄存器上读到引脚状态</strong></p><p><strong>当GPIO用于模拟功能时，引脚的上、下拉电阻是不起作用的，这个时候即使配置了上拉或下拉模式，也不会影响到模拟信号的输入输出</strong></p><p><strong>除了 ADC 和 DAC 要将 IO 配置为模拟通道之外其他外设功能一律 要配置为复用功能模式，</strong></p><h3 id="开漏输出模式（带上拉或者下拉）"><a href="#开漏输出模式（带上拉或者下拉）" class="headerlink" title="开漏输出模式（带上拉或者下拉）"></a>开漏输出模式（带上拉或者下拉）</h3><pre><code>![](https://img-blog.csdnimg.cn/20190801205006100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)</code></pre><p>在开漏输出模式时<strong>，只有N-MOS管工作，如果我们控制输出为0，低电平，则P-MOS管关闭，N-MOS管导通，使输出低电平，I/O端口的电平就是低电平，若控制输出为1时，高电平，则P-MOS管和N-MOS管都关闭，输出指令就不会起到作用，此时I/O端口的电平就不会由输出的高电平决定，而是由I/O端口外部的上拉或者下拉决定   如果没有上拉或者下拉 IO口就处于悬空状态</strong></p><p>*<em>并且此时施密特触发器是打开的，即输入可用，通过输入数据寄存器GPIOx_IDR可读取I/O的实际状态。，I/O口的电平不一定是输出的电平   *</em></p><h3 id="推挽输出模式（带上拉或者下拉）"><a href="#推挽输出模式（带上拉或者下拉）" class="headerlink" title="推挽输出模式（带上拉或者下拉）"></a>推挽输出模式（带上拉或者下拉）</h3><pre><code>![](https://img-blog.csdnimg.cn/20190801213632139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)</code></pre><p>在推挽输出模式时<strong>，N-MOS管和P-MOS管都工作，如果我们控制输出为0，低电平，则P-MOS管关闭，N-MOS管导通，使输出低电平，I/O端口的电平就是低电平，若控制输出为1 高电平，则P-MOS管导通N-MOS管关闭，使输出高电平，I/O端口的电平就是高电平，  外部上拉和下拉的作用是控制在没有输出时IO口电平</strong></p><p>*<em>此时施密特触发器是打开的，即输入可用，通过输入数据寄存器GPIOx_IDR可读取I/O的实际状态。I/O口的电平一定是输出的电平   *</em></p><h3 id="复用开漏输出（带上拉或者下拉）"><a href="#复用开漏输出（带上拉或者下拉）" class="headerlink" title="复用开漏输出（带上拉或者下拉）"></a>复用开漏输出（带上拉或者下拉）</h3><pre><code>![](https://img-blog.csdnimg.cn/20190801214830330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)</code></pre><p><strong>GPIO复用为其他外设，输出数据寄存器GPIOx_ODR无效；  输出的高低电平的来源于其它外设，施密特触发器打开，输入可用，通过输入数据寄存器可获取I/O实际状态    除了输出信号的来源改变 其他与开漏输出功能相同</strong></p><h3 id="复用推挽输出（带上拉或者下拉）"><a href="#复用推挽输出（带上拉或者下拉）" class="headerlink" title="复用推挽输出（带上拉或者下拉）"></a>复用推挽输出（带上拉或者下拉）</h3><pre><code>![](https://img-blog.csdnimg.cn/20190801215400510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)</code></pre><p><strong>GPIO复用为其他外设(如 I2C)，输出数据寄存器GPIOx_ODR无效；  输出的高低电平的来源于其它外设，施密特触发器打开，输入可用，通过输入数据寄存器可获取I/O实际状态    除了输出信号的来源改变 其他与开漏输出功能相同</strong></p><p><strong>开漏输出和推挽输出的区别：</strong></p><p><strong>推挽输出：</strong></p><p>*<em>可以输出强高低电平，连接数字器件 *</em></p><p><strong>推挽结构一般是指两个三极管分别受两互补信号的控制,总是在一个三极管导通的时候另一个截止.</strong></p><p><strong>开漏输出：</strong></p><p><strong>可以输出强低电平，高电平得靠外部电阻拉高。输出端相当于三极管的集电极.  需要外接上拉电阻，才能实现输出高电平合于做电流型的驱动，其吸收电流的能力相对强(一般20ma以内)；</strong></p><p><strong>在使用任何一种开漏模式时，都需要接上拉电阻，否则只能输出低电平</strong></p><p><img src="https://img-blog.csdnimg.cn/20190802084009482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt><strong>、</strong></p><p>推挽输出电路： 其中IN端输出高电平时下面的PNP三极管截止，而上面NPN三极管导通，输出电平VS+；当IN端输出低电平时则恰恰相反，PNP三极管导通，输出和地相连，为低电平   </p><p>开漏输出电路：IN端输出低电平时，三极管导通，使输出接地，IN端输出高电平时，三极管截止，所以引脚既不输出高电平，也不输出低电平，为高阻态。为正常使用时必须接上拉电阻，</p><p><strong>在STM32中选用IO模式:</strong></p><ul><li><p>上拉输入、下拉输入可以用来检测外部信号；例如，按键等；</p></li><li><p>模拟输入 ——应用ADC模拟输入，或者低功耗下省电</p></li><li><p>开漏输出一般应用在I2C、SMBUS通讯等需要”线与”功能的总线电路中。</p></li><li><p><strong>推挽输出模式一般应用在输出电平为0和3.3伏而且需要高速切换开关状态的场合。</strong>在STM32的应用中，除了必须用开漏模式的场合，我们都习惯使用推挽输出模式。</p></li><li><p>复用功能的推挽输出_AF_PP ——片内外设功能（I2C的SCL,SDA）</p></li><li><p>复用功能的开漏输出_AF_OD——片内外设功能（TX1,MOSI,MISO.SCK.SS）</p></li></ul><h3 id="F4系列与F1系列区别"><a href="#F4系列与F1系列区别" class="headerlink" title="F4系列与F1系列区别:"></a>F4系列与F1系列区别:</h3><p>本质上的区别是F4系列采用了<strong>Cortex-M4内核  而</strong>F1系列采用<strong>Cortex-M3内核</strong></p><p>F1系列(<strong>M3</strong>)IO口基本结构：</p><p><img src="https://img-blog.csdnimg.cn/20190801221426325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p>F4系列(<strong>M4</strong>)IO口基本结构：</p><p><img src="https://img-blog.csdnimg.cn/20190801221500464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p>F4系列设计的更加高级与人性化，他将<strong>外部上下拉电阻转移到了输出/输入驱动器外部</strong>，使得输出模式下也可以实现内部上拉与下拉，方便了用户的使用，增加了灵活性</p><h2 id="GPIO的初始化-F4"><a href="#GPIO的初始化-F4" class="headerlink" title="GPIO的初始化(F4)"></a>GPIO的初始化(F4)</h2><p>这里我们以初始化LED为例</p><p><strong>1.定义一个 GPIO_InitTypeDef 类型的结构体</strong></p><blockquote><p> GPIO_InitTypeDef GPIO_InitStructure;   /<em>定义一个 GPIO_InitTypeDef 类型的结构体</em>/</p></blockquote><p>一共有5个参数</p><p><img src="https://img-blog.csdnimg.cn/20190802082555844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p><strong>2开启 LED 相关的 GPIO 外设时钟</strong></p><blockquote><p>RCC_AHB1PeriphClockCmd ( RCC_AHB1Periph_GPIOB, ENABLE);     /<em>开启 AHB1时钟</em>/</p></blockquote><p>   <strong>Q:为什么要设置时钟？</strong></p><pre><code>任何外设都需要时钟，51单片机，stm32，430等等，因为寄存器是由D触发器组成的，往触发器里面写东西，前提条件是有时钟输入。stm32是低功耗，他将所有的门都默认设置为disable(不使能)，在你需要用哪个门的时候，开哪个门就可以，也就是说用到什么外设，只要打开对应外设的时钟就可以，   其他的没用到的可以还是disable(不使能)，这样耗能就会减少。</code></pre><p><strong>Q:为什么 STM32 要有多个时钟源呢？</strong></p><p>因为首 先 STM32 本身非常复杂，外设非常的多，但是并不是所有外设都需要系统时钟这么高的频率， 比如看门狗以及 RTC 只需要几十 k 的时钟即可。同一个电路，时钟越快功耗越大，同时抗电磁 干扰能力也会越弱，所以对于较为复杂的 MCU 一般都是采取多时钟源的方法来解决这些问题。  </p><p>而相对应的外设功能所使用的时钟 在stm32f4xx.h 中即可查看到</p><p><strong>RCC_AHB1</strong></p><p><img src="https://img-blog.csdnimg.cn/20190802093032688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p><strong>RCC_APB1</strong></p><p><img src="https://img-blog.csdnimg.cn/20190802093048325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p><strong>3选择要控制的 GPIO 引脚</strong></p><blockquote><p> GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;  /<em>选择Pin9引脚</em>/</p></blockquote><p>可选引脚为0-15 一组IO口有16个引脚</p><p><img src="https://img-blog.csdnimg.cn/2019080122332587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p><strong>4设置所选引脚的模式</strong></p><blockquote><p> GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;   /<em>设定为输出模式</em>/</p></blockquote><p>引脚的模式共有四种，分别为输入，输出，复用，和模拟模式</p><p><img src="https://img-blog.csdnimg.cn/2019080209031850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p><strong>5 设定所选引脚的输出类型</strong></p><blockquote><p>GPIO_InitStructure.GPIO_OType = GPIO_OType_PP; /<em>设置引脚的输出类型为推挽输出</em>/</p></blockquote><p>输出模式有两种：推挽输出和开漏输出   </p><p><img src="https://img-blog.csdnimg.cn/20190802090723845.png" alt></p><p><strong>只有输出模式才需要配置，输入模式下不需要配置</strong></p><p><strong>6 设定所选管脚的速度</strong></p><blockquote><p> GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;//设定速度为100MHz  高速模式</p></blockquote><p><img src="https://img-blog.csdnimg.cn/2019080209104520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p><strong>7 设定所选管脚的上拉与下拉</strong></p><blockquote><p>GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP; /<em>设置引脚为上拉模式</em>/</p></blockquote><p>可设置为：上拉，下拉，与浮空</p><p><img src="https://img-blog.csdnimg.cn/20190802091352838.png" alt></p><p><strong>8初始化GPIO</strong></p><blockquote><p> GPIO_Init(GPIOB, &amp;GPIO_InitStructure);    //初始化所设置的引脚</p></blockquote><p>GPIO_Init() 是官方配置的初始化函数  <strong>第一个参数是GPIOX 第二个参数是结构体所对应GPIO各种参数的配置</strong></p><h3 id="GPIO的初始化-F1"><a href="#GPIO的初始化-F1" class="headerlink" title="GPIO的初始化(F1)"></a>GPIO的初始化(F1)</h3><p>F4的初始化相较于F1系列有了很大的改变，在配置F1系列时，结构体只有三个参数  </p><p>** GPIO_InitTypeDef 类型的结构体**</p><p><img src="https://img-blog.csdnimg.cn/20190802093751960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p><strong>所选管脚的速度</strong></p><p><img src="https://img-blog.csdnimg.cn/20190802093918542.png" alt></p><p><strong>所选管脚的8种模式</strong></p><p><img src="https://img-blog.csdnimg.cn/20190802094236801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p><strong>区别：</strong></p><p> F1(M-3)系列管脚速度只有三种模式  并且管脚的模式配置八种模式全部都在一起定义，直接设置即可</p><p>总归还是大同小异，不做过多介绍，看下下方配置即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br></pre></td><td class="code"><pre><span class="line">void led_init(void)&#123;1 GPIO简介</span><br><span class="line">--------</span><br><span class="line"></span><br><span class="line">**GPIO**,即通用I/O(输入/输出)端口，是STM32可控制的引脚。STM32芯片的GPIO引脚与外部设备连接起来，可实现与外部通讯、控制外部硬件或者采集外部硬件数据的功能。</span><br><span class="line"></span><br><span class="line">**STM32F407有7组IO。分别为GPIOA~GPIOG，每组IO有16个IO口，共有112个IO口  通常称为 PAx、PBx、PCx、PDx、PEx、PFx、PGx，其中x为0-15。  并且F4系列是基于Cortex-M4内核  **</span><br><span class="line"></span><br><span class="line">**GPIO的复用：**</span><br><span class="line"></span><br><span class="line">STM32F4 有很多的**内置外设**，这些外设的外部引脚都是与 GPIO 共用的。也就是说，**一个引脚可以有很多作用，但是默认为IO口，如果想使用一个 GPIO内置外设的功能引脚，就需要GPIO的复用，那么当这个 GPIO 作为内置外设使用的时候，就叫做复用。**    比如说串口  就是GPIO复用为串口</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">2 GPIO的工作模式</span><br><span class="line">-----------</span><br><span class="line"></span><br><span class="line">**1、4种输入模式**</span><br><span class="line"></span><br><span class="line">（1）GPIO\_Mode\_IN_FLOATING 浮空输入  </span><br><span class="line">（2）GPIO\_Mode\_IPU 上拉输入  </span><br><span class="line">（3）GPIO\_Mode\_IPD 下拉输入  </span><br><span class="line">（4）GPIO\_Mode\_AIN 模拟输入</span><br><span class="line"></span><br><span class="line">**2、4种输出模式 **</span><br><span class="line"></span><br><span class="line">（5）GPIO\_Mode\_Out_OD 开漏输出（带上拉或者下拉）  </span><br><span class="line">（6）GPIO\_Mode\_AF_OD 复用开漏输出（带上拉或者下拉）  </span><br><span class="line">（7）GPIO\_Mode\_Out_PP 推挽输出（带上拉或者下拉）  </span><br><span class="line">（8）GPIO\_Mode\_AF_PP 复用推挽输出（带上拉或者下拉）  </span><br><span class="line">**3、4种最大输出速度**  </span><br><span class="line">（1）2MHZ  (低速)  </span><br><span class="line">（2）25MHZ  (中速)  </span><br><span class="line">（3）50MHZ  (快速)  </span><br><span class="line">（4）100MHZ  (高速)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">**关于他们的定义，都在  stm32f4xx_gpio.h 中，都为结构体形式的定义**</span><br><span class="line"></span><br><span class="line">3 **GPIO框图剖析**</span><br><span class="line">--------------</span><br><span class="line"></span><br><span class="line">![](https://img-blog.csdnimg.cn/20190801161834709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)</span><br><span class="line"></span><br><span class="line">我们所用到的每一个GPIO其内部结构都是这样，分别对应着GPIO的八种模式  这里我们简单的介绍下：</span><br><span class="line"></span><br><span class="line">*   **保护二极管：  IO引脚上下两边两个二极管用于防止引脚外部过高、过低的电压输入，**当**引脚电压高于VDD_FT****时，上方的二极管导通，当引脚电压低于VSS时，下方的二极管导通，防止不正常电压引入芯片导致芯片烧毁 **</span><br><span class="line">    </span><br><span class="line">*   **上拉、下拉电阻：控制引脚默认状态的电压，开启上拉的时候引脚默认电压为高电平，开启下拉的时候引脚默认电压为低电平**</span><br><span class="line">    </span><br><span class="line">*   **TTL施密特触发器：**基本原理是当输入电压高于正向阈值电压，输出为高；当输入电压低于负向阈值电压，输出为低；**IO口信号经过触发器后，模拟信号转化为0和1的数字信号    也就是高低电平  并且是TTL电平协议   这也是为什么STM32是TTL电平协议的原因**</span><br><span class="line">    </span><br><span class="line">*    **P-MOS管和N-MOS管**：**信号由P-MOS管和N-MOS管，依据两个MOS管的工作方式，使得GPIO具有“推挽输出”和“开漏输出”的模式     P-MOS管高电平导通，低电平关闭，下方的N-MOS低电平导通，高电平关闭**</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">注：  **VDD_FT  代表IO口，兼容3.3V和5V，如果没有标注“FT”，就代表着不兼容5V      **</span><br><span class="line"></span><br><span class="line"> 在芯片数据手册的引脚定义中，会看到**有“I/O电平”一列  有FT即为支持5V**</span><br><span class="line"></span><br><span class="line">![](https://img-blog.csdnimg.cn/20190801175317972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)</span><br><span class="line"></span><br><span class="line">### 4 GPIO的八种工作模式**剖析**：</span><br><span class="line"></span><br><span class="line">###  浮空输入模式</span><br><span class="line"></span><br><span class="line">                   ![](https://img-blog.csdnimg.cn/20190801191842465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)</span><br><span class="line"></span><br><span class="line">**浮空输入模式下，I/O端口的电平信号直接进入输入数据寄存器。MCU直接读取I/O口电平，I/O的电平状态是不确定的，完全由外部输入决定；如果在该引脚悬空（在无信号输入）的情况下，读取该端口的电平是不确定的。 (**接用电压表测量其引脚电压为1点几伏，这是个不确定值**) **以用来做KEY识别</span><br><span class="line"></span><br><span class="line"> 上拉输入模式</span><br><span class="line"></span><br><span class="line">                           ![](https://img-blog.csdnimg.cn/20190801194218819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)</span><br><span class="line"></span><br><span class="line">** IO内部接上拉电阻，此时如果IO口外部没有信号输入或者引脚悬空，IO口默认为高电平  如果I/O口输入低电平，那么引脚就为低电平，MCU读取到的就是低电平**</span><br><span class="line"></span><br><span class="line">**STM32的内部上拉是&quot;弱上拉&quot;，即通过此上拉输出的电流是很弱的，如要求大电流还是需要外部上拉。**</span><br><span class="line"></span><br><span class="line"> 下拉输入模式</span><br><span class="line"></span><br><span class="line">                              ![](https://img-blog.csdnimg.cn/20190801195135782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)</span><br><span class="line"></span><br><span class="line">** IO内部接下拉电阻，此时如果IO口外部没有信号输入或者引脚悬空，IO口默认为低电平  如果I/O口输入高电平，那么引脚就为高电平，MCU读取到的就是高电平**</span><br><span class="line"></span><br><span class="line"> 模拟输入模式</span><br><span class="line"></span><br><span class="line">                              ![](https://img-blog.csdnimg.cn/20190801200336884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)</span><br><span class="line"></span><br><span class="line">**当GPIO引脚用于ADC采集电压的输入通道时，用作&quot;模拟输入&quot;功能，此时信号不经过施密特触发器，直接直接进入ADC模块，并且输入数据寄存器为空 ，CPU不能在输入数据寄存器上读到引脚状态**</span><br><span class="line"></span><br><span class="line">**当GPIO用于模拟功能时，引脚的上、下拉电阻是不起作用的，这个时候即使配置了上拉或下拉模式，也不会影响到模拟信号的输入输出**</span><br><span class="line"></span><br><span class="line">**除了 ADC 和 DAC 要将 IO 配置为模拟通道之外其他外设功能一律 要配置为复用功能模式，**</span><br><span class="line"></span><br><span class="line"> 开漏输出模式（带上拉或者下拉）</span><br><span class="line"></span><br><span class="line">                            ![](https://img-blog.csdnimg.cn/20190801205006100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)</span><br><span class="line"></span><br><span class="line">在开漏输出模式时**，只有N-MOS管工作，如果我们控制输出为0，低电平，则P-MOS管关闭，N-MOS管导通，使输出低电平，I/O端口的电平就是低电平，若控制输出为1时，高电平，则P-MOS管和N-MOS管都关闭，输出指令就不会起到作用，此时I/O端口的电平就不会由输出的高电平决定，而是由I/O端口外部的上拉或者下拉决定   如果没有上拉或者下拉 IO口就处于悬空状态**</span><br><span class="line"></span><br><span class="line">**并且此时施密特触发器是打开的，即输入可用，通过输入数据寄存器GPIOx_IDR可读取I/O的实际状态。，I/O口的电平不一定是输出的电平   **</span><br><span class="line"></span><br><span class="line"> 推挽输出模式（带上拉或者下拉）</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">                          ![](https://img-blog.csdnimg.cn/20190801213632139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)</span><br><span class="line"></span><br><span class="line">在推挽输出模式时**，N-MOS管和P-MOS管都工作，如果我们控制输出为0，低电平，则P-MOS管关闭，N-MOS管导通，使输出低电平，I/O端口的电平就是低电平，若控制输出为1 高电平，则P-MOS管导通N-MOS管关闭，使输出高电平，I/O端口的电平就是高电平，  外部上拉和下拉的作用是控制在没有输出时IO口电平**</span><br><span class="line"></span><br><span class="line">**此时施密特触发器是打开的，即输入可用，通过输入数据寄存器GPIOx_IDR可读取I/O的实际状态。I/O口的电平一定是输出的电平   **</span><br><span class="line"></span><br><span class="line"> 复用开漏输出（带上拉或者下拉）</span><br><span class="line"></span><br><span class="line">                          ![](https://img-blog.csdnimg.cn/20190801214830330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)</span><br><span class="line"></span><br><span class="line">**GPIO复用为其他外设，输出数据寄存器GPIOx_ODR无效；  输出的高低电平的来源于其它外设，施密特触发器打开，输入可用，通过输入数据寄存器可获取I/O实际状态    除了输出信号的来源改变 其他与开漏输出功能相同**</span><br><span class="line"></span><br><span class="line"> 复用推挽输出（带上拉或者下拉）</span><br><span class="line"></span><br><span class="line">                          ![](https://img-blog.csdnimg.cn/20190801215400510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)</span><br><span class="line"></span><br><span class="line">**GPIO复用为其他外设(如 I2C)，输出数据寄存器GPIOx_ODR无效；  输出的高低电平的来源于其它外设，施密特触发器打开，输入可用，通过输入数据寄存器可获取I/O实际状态    除了输出信号的来源改变 其他与开漏输出功能相同**</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">**开漏输出和推挽输出的区别：**</span><br><span class="line"></span><br><span class="line">**推挽输出：**</span><br><span class="line"></span><br><span class="line">**可以输出强高低电平，连接数字器件 **</span><br><span class="line"></span><br><span class="line">**推挽结构一般是指两个三极管分别受两互补信号的控制,总是在一个三极管导通的时候另一个截止.**</span><br><span class="line"></span><br><span class="line">**开漏输出：**</span><br><span class="line"></span><br><span class="line">**可以输出强低电平，高电平得靠外部电阻拉高。输出端相当于三极管的集电极.  需要外接上拉电阻，才能实现输出高电平合于做电流型的驱动，其吸收电流的能力相对强(一般20ma以内)；**</span><br><span class="line"></span><br><span class="line">**在使用任何一种开漏模式时，都需要接上拉电阻，否则只能输出低电平**</span><br><span class="line"></span><br><span class="line">![](https://img-blog.csdnimg.cn/20190802084009482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)**、**</span><br><span class="line"></span><br><span class="line">推挽输出电路： 其中IN端输出高电平时下面的PNP三极管截止，而上面NPN三极管导通，输出电平VS+；当IN端输出低电平时则恰恰相反，PNP三极管导通，输出和地相连，为低电平   </span><br><span class="line"></span><br><span class="line">开漏输出电路：IN端输出低电平时，三极管导通，使输出接地，IN端输出高电平时，三极管截止，所以引脚既不输出高电平，也不输出低电平，为高阻态。为正常使用时必须接上拉电阻，</span><br><span class="line"></span><br><span class="line">**在STM32中选用IO模式:**</span><br><span class="line"></span><br><span class="line">*    上拉输入、下拉输入可以用来检测外部信号；例如，按键等；</span><br><span class="line">    </span><br><span class="line">*   模拟输入 ——应用ADC模拟输入，或者低功耗下省电</span><br><span class="line">    </span><br><span class="line">*   开漏输出一般应用在I2C、SMBUS通讯等需要&quot;线与&quot;功能的总线电路中。</span><br><span class="line">    </span><br><span class="line">*    **推挽输出模式一般应用在输出电平为0和3.3伏而且需要高速切换开关状态的场合。**在STM32的应用中，除了必须用开漏模式的场合，我们都习惯使用推挽输出模式。</span><br><span class="line">    </span><br><span class="line">*   复用功能的推挽输出\_AF\_PP ——片内外设功能（I2C的SCL,SDA）</span><br><span class="line">    </span><br><span class="line">*   复用功能的开漏输出\_AF\_OD——片内外设功能（TX1,MOSI,MISO.SCK.SS）</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">### F4系列与F1系列区别:</span><br><span class="line"></span><br><span class="line">本质上的区别是F4系列采用了**Cortex-M4内核  而**F1系列采用**Cortex-M3内核**</span><br><span class="line"></span><br><span class="line">F1系列(**M3**)IO口基本结构：</span><br><span class="line"></span><br><span class="line">![](https://img-blog.csdnimg.cn/20190801221426325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)</span><br><span class="line"></span><br><span class="line">F4系列(**M4**)IO口基本结构：</span><br><span class="line"></span><br><span class="line">![](https://img-blog.csdnimg.cn/20190801221500464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)</span><br><span class="line"></span><br><span class="line">F4系列设计的更加高级与人性化，他将**外部上下拉电阻转移到了输出/输入驱动器外部**，使得输出模式下也可以实现内部上拉与下拉，方便了用户的使用，增加了灵活性</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">GPIO的初始化(F4)</span><br><span class="line">------------</span><br><span class="line"></span><br><span class="line">这里我们以初始化LED为例</span><br><span class="line"></span><br><span class="line">**1.定义一个 GPIO_InitTypeDef 类型的结构体**</span><br><span class="line"></span><br><span class="line">&gt;  GPIO\_InitTypeDef GPIO\_InitStructure;   /*定义一个 GPIO_InitTypeDef 类型的结构体*/</span><br><span class="line"></span><br><span class="line">一共有5个参数</span><br><span class="line"></span><br><span class="line">![](https://img-blog.csdnimg.cn/20190802082555844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">**2开启 LED 相关的 GPIO 外设时钟**</span><br><span class="line"></span><br><span class="line">&gt; RCC\_AHB1PeriphClockCmd ( RCC\_AHB1Periph_GPIOB, ENABLE);     /*开启 AHB1时钟*/</span><br><span class="line"></span><br><span class="line">   **Q:为什么要设置时钟？**</span><br><span class="line"></span><br><span class="line">    任何外设都需要时钟，51单片机，stm32，430等等，因为寄存器是由D触发器组成的，往触发器里面写东西，前提条件是有时钟输入。stm32是低功耗，他将所有的门都默认设置为disable(不使能)，在你需要用哪个门的时候，开哪个门就可以，也就是说用到什么外设，只要打开对应外设的时钟就可以，   其他的没用到的可以还是disable(不使能)，这样耗能就会减少。</span><br><span class="line"></span><br><span class="line">**Q:为什么 STM32 要有多个时钟源呢？**</span><br><span class="line"></span><br><span class="line">因为首 先 STM32 本身非常复杂，外设非常的多，但是并不是所有外设都需要系统时钟这么高的频率， 比如看门狗以及 RTC 只需要几十 k 的时钟即可。同一个电路，时钟越快功耗越大，同时抗电磁 干扰能力也会越弱，所以对于较为复杂的 MCU 一般都是采取多时钟源的方法来解决这些问题。  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">而相对应的外设功能所使用的时钟 在stm32f4xx.h 中即可查看到</span><br><span class="line"></span><br><span class="line">**RCC_AHB1**</span><br><span class="line"></span><br><span class="line">![](https://img-blog.csdnimg.cn/20190802093032688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)</span><br><span class="line"></span><br><span class="line">**RCC_APB1**</span><br><span class="line"></span><br><span class="line">![](https://img-blog.csdnimg.cn/20190802093048325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)</span><br><span class="line"></span><br><span class="line">**3选择要控制的 GPIO 引脚**</span><br><span class="line"></span><br><span class="line">&gt;  GPIO\_InitStructure.GPIO\_Pin = GPIO\_Pin\_9;  /*选择Pin9引脚*/</span><br><span class="line"></span><br><span class="line">可选引脚为0-15 一组IO口有16个引脚</span><br><span class="line"></span><br><span class="line">![](https://img-blog.csdnimg.cn/2019080122332587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)</span><br><span class="line"></span><br><span class="line">**4设置所选引脚的模式**</span><br><span class="line"></span><br><span class="line">&gt;  GPIO\_InitStructure.GPIO\_Mode = GPIO\_Mode\_OUT;   /*设定为输出模式*/</span><br><span class="line"></span><br><span class="line">引脚的模式共有四种，分别为输入，输出，复用，和模拟模式</span><br><span class="line"></span><br><span class="line">![](https://img-blog.csdnimg.cn/2019080209031850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">**5 设定所选引脚的输出类型**</span><br><span class="line"></span><br><span class="line">&gt; GPIO\_InitStructure.GPIO\_OType = GPIO\_OType\_PP; /*设置引脚的输出类型为推挽输出*/</span><br><span class="line"></span><br><span class="line">输出模式有两种：推挽输出和开漏输出   </span><br><span class="line"></span><br><span class="line">![](https://img-blog.csdnimg.cn/20190802090723845.png)</span><br><span class="line"></span><br><span class="line">**只有输出模式才需要配置，输入模式下不需要配置**</span><br><span class="line"></span><br><span class="line">**6 设定所选管脚的速度**</span><br><span class="line"></span><br><span class="line">&gt;  GPIO\_InitStructure.GPIO\_Speed = GPIO\_Speed\_100MHz;//设定速度为100MHz  高速模式</span><br><span class="line"></span><br><span class="line">![](https://img-blog.csdnimg.cn/2019080209104520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)</span><br><span class="line"></span><br><span class="line">**7 设定所选管脚的上拉与下拉**</span><br><span class="line"></span><br><span class="line">&gt; GPIO\_InitStructure.GPIO\_PuPd = GPIO\_PuPd\_UP; /*设置引脚为上拉模式*/</span><br><span class="line"></span><br><span class="line">可设置为：上拉，下拉，与浮空</span><br><span class="line"></span><br><span class="line">![](https://img-blog.csdnimg.cn/20190802091352838.png)</span><br><span class="line"></span><br><span class="line">**8初始化GPIO**</span><br><span class="line"></span><br><span class="line">&gt;  GPIO\_Init(GPIOB, &amp;GPIO\_InitStructure);    //初始化所设置的引脚</span><br><span class="line"></span><br><span class="line">GPIO_Init() 是官方配置的初始化函数  **第一个参数是GPIOX 第二个参数是结构体所对应GPIO各种参数的配置**</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">### GPIO的初始化(F1)</span><br><span class="line"></span><br><span class="line">F4的初始化相较于F1系列有了很大的改变，在配置F1系列时，结构体只有三个参数  </span><br><span class="line"></span><br><span class="line">** GPIO_InitTypeDef 类型的结构体**</span><br><span class="line"></span><br><span class="line">![](https://img-blog.csdnimg.cn/20190802093751960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)</span><br><span class="line"></span><br><span class="line">**所选管脚的速度**</span><br><span class="line"></span><br><span class="line">![](https://img-blog.csdnimg.cn/20190802093918542.png)</span><br><span class="line"></span><br><span class="line">**所选管脚的8种模式**</span><br><span class="line"></span><br><span class="line">![](https://img-blog.csdnimg.cn/20190802094236801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)</span><br><span class="line"></span><br><span class="line">**区别：**</span><br><span class="line"></span><br><span class="line"> F1(M-3)系列管脚速度只有三种模式  并且管脚的模式配置八种模式全部都在一起定义，直接设置即可</span><br><span class="line"></span><br><span class="line">总归还是大同小异，不做过多介绍，看下下方配置即可</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">void led_init(void)&#123;</span><br><span class="line">GPIO\_InitTypeDef GPIO\_InitStruct;                    //定义初始化结构体</span><br><span class="line">RCC\_APB2PeriphClockCmd(RCC\_APB2Periph_GPIOA,ENABLE); //使能GPIOA时钟</span><br><span class="line"></span><br><span class="line">GPIO\_InitStruct.GPIO\_Mode    = GPIO\_Mode\_Out_PP;     //配置模式</span><br><span class="line">GPIO\_InitStruct.GPIO\_Pin     = GPIO\_Pin\_0;           //配置哪个IO口</span><br><span class="line">GPIO\_InitStruct.GPIO\_Speed   = GPIO\_Speed\_50MHz;     //配置IO口速度,仅输出有效</span><br><span class="line">GPIO\_Init(GPIOA,&amp;GPIO\_InitStruct);                   //初始化GPIOA的参数为以上结构体&#125;</span><br></pre></td></tr></table></figure><pre><code>                                                ![](https://img-blog.csdnimg.cn/20190726200706356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70)GPIO\_InitTypeDef GPIO\_InitStruct;                    //定义初始化结构体RCC\_APB2PeriphClockCmd(RCC\_APB2Periph_GPIOA,ENABLE); //使能GPIOA时钟GPIO\_InitStruct.GPIO\_Mode    = GPIO\_Mode\_Out_PP;     //配置模式GPIO\_InitStruct.GPIO\_Pin     = GPIO\_Pin\_0;           //配置哪个IO口GPIO\_InitStruct.GPIO\_Speed   = GPIO\_Speed\_50MHz;     //配置IO口速度,仅输出有效GPIO\_Init(GPIOA,&amp;GPIO\_InitStruct);                   //初始化GPIOA的参数为以上结构体}</code></pre><pre><code></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-GPIO简介&quot;&gt;&lt;a href=&quot;#1-GPIO简介&quot; class=&quot;headerlink&quot; title=&quot;1 GPIO简介&quot;&gt;&lt;/a&gt;1 GPIO简介&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;GPIO&lt;/strong&gt;,即通用I/O(输入/输出)端口，是STM32可控
      
    
    </summary>
    
      <category term="STM32" scheme="http://zxiaoxuan.cn/categories/STM32/"/>
    
    
      <category term="STM32" scheme="http://zxiaoxuan.cn/tags/STM32/"/>
    
  </entry>
  
  <entry>
    <title>【Python】-将list列表写入文件并读取方法汇总</title>
    <link href="http://zxiaoxuan.cn/posts/16224/"/>
    <id>http://zxiaoxuan.cn/posts/16224/</id>
    <published>2019-09-19T16:00:00.000Z</published>
    <updated>2019-09-30T13:48:17.151Z</updated>
    
    <content type="html"><![CDATA[<p>1.writelines()直接写入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">l=\[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;\]</span><br><span class="line"></span><br><span class="line">f=open(&quot;k.txt&quot;,&quot;w&quot;)</span><br><span class="line"></span><br><span class="line">f.writelines(l)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>该方法写入直接写入列表元素</p><p><img src="https://img-blog.csdnimg.cn/20190620214505357.png" alt></p><p>2.str转化为字符串写入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">l=\[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,1,2,3\]</span><br><span class="line"></span><br><span class="line">f=open(&quot;k.txt&quot;,&quot;w&quot;)</span><br><span class="line"></span><br><span class="line">f.write(str(l))</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>该方法会将整个列表转化为字符串并写入，</p><p><img src="https://img-blog.csdnimg.cn/20190620214740595.png" alt></p><p>3.for循环写入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">l=\[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;\]</span><br><span class="line"></span><br><span class="line">f=open(&quot;k.txt&quot;,&quot;w&quot;)for line in l:</span><br><span class="line">    f.write(line+&apos;\\n&apos;)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>此方法的好处是，每个元素都是单词写入，可以在写入时对每个元素进行修改，并且可以换行。但注意<strong>列表中的数字是没有办法与你所要添加的字符相加的(int类型不能与str相加)</strong></p><p><img src="https://img-blog.csdnimg.cn/20190620215135831.png" alt></p><p>4.使用.join函数修改列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l=\[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;\]</span><br><span class="line">str = &apos;\\n&apos;f=open(&quot;k.txt&quot;,&quot;w&quot;)</span><br><span class="line">f.write(str.join(l))</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>使用join可以很好的添加你想要添加的字符以及数字，非常的灵活，推荐使用，如果列表中存在数值类型，可以先用str转换之后再进行写入</p><p><img src="https://img-blog.csdnimg.cn/20190620215828360.png" alt></p><h3 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h3><p>1read   </p><p>如果使用read来读取，则返回为<strong>字符串</strong>类型，并且<strong>列表只能为字符串类型(str)，不能存在数值类型，如果有数字则会报错</strong></p><p><strong>readline与read相同  ，</strong></p><p><img src="https://img-blog.csdnimg.cn/2019062022115718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p>如果使用readlines来读取，则默认返回为<strong>列表</strong>类型，并且<strong>列表的一个元素为一行元素</strong></p><p><img src="https://img-blog.csdnimg.cn/20190620222412102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p>这时便可以对数据进行很好的处理</p><p>读取列表中的数字，提供一个简单的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for line in l:    if &quot;0&quot; in next or &quot;1&quot; in next：</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.writelines()直接写入&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;lin
      
    
    </summary>
    
      <category term="Python" scheme="http://zxiaoxuan.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://zxiaoxuan.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>智能车之五电感100%入环</title>
    <link href="http://zxiaoxuan.cn/posts/35789/"/>
    <id>http://zxiaoxuan.cn/posts/35789/</id>
    <published>2019-09-18T12:11:05.108Z</published>
    <updated>2019-09-29T07:59:18.520Z</updated>
    
    <content type="html"><![CDATA[<p>写在前面：</p><p>搞了好久，试了不下五六种方案，先是摄像头+电磁加权，之后固定打角，随后又是竖直电感入环，竖直电感又搞了几种方式，总是找不到一种代码简便，又能够稳定稳定入环的方案，看了很多国一国二代码，在今天(5.16)突然想到八字电感，想去官网看看有没有类似的，但是技术报告下不下来，因为没有参考，只好自己摆放了一下电感，然后开始摸索，最后想出来一种方案，基本可以实现完美入环，不太清楚哈工大是否这样使用，但个人测试效果非常可以，</p><p>想着入环岛，那么最基本的肯定要先做到识别，对于环岛的识别，我个人的思想是分为五部分即可，以右环岛为例</p><p>1 在第一部分时，你会发现右边赛道宽度突然变宽，而左边赛道正常(可以区分环岛和十字(十字为两边发生突变))</p><p>这时候便可以加一个标志位1，</p><p>2.在第二部分，我们可以看到左边赛道无突变，右边赛道丢线(检测不到黑点)，各位应该都有丢线标志位</p><p>这时便有环岛标志位2</p><p>3在第三部分(标志位1和标志位2成立)，我们可以看到右边赛道先是逐渐变窄，之后便是逐渐变宽，这时候可以得到标志位3</p><p>并且记录下右赛道刚开始变宽时的行位置</p><p>4<strong>.之后你会发现右边赛道再次丢线，最后一个标志位</strong></p><p>5。当然少不了最后的V(赛道宽度发生突变)</p><p>识别其实不难，大家可以根据自己的图像来具体修改，具体识别会有不同，但有思路即可，你会发现3，4，5在一幅图像中，也可以根据这些来进行判断，(当然，今年各位应该都是电磁+摄像头，这样的话环岛识别便更为简单，电磁信号变为双倍，并且摄像头有少许标志位，便可以很简单的判断出环岛，)之后便是最重要的补线了</p><p>补线</p><p>补线便是根据1和2点根据斜率连接，最小二乘法拟合得到相应的中线</p><p>1点 ：右边界为直线，上一次左边界-这次左边界&gt;10(这一行赛道宽度-上一行赛道宽度&gt;10) 并记录下该行左边界位置，即为1点</p><p>*2点： 前面有提到过，右边界为直线，这一行左边界-上一行左边界&gt;2 记录下此时左右边界位置 右边界为2点 *</p><p>3点： 2点的左边界即为3点</p><p>4.如果为左环岛，则右边界为直道。</p><p>赛道边界法：<br>如果不用拟合直线，可以考虑以1点作为赛道右边界，然后右边界往前依次递增(右环岛为递减) 直到2点处，也可得到不错的入环效果</p><p>具体方法是假设1点为x行y列 2点为x2行y2列 用y-y1得到列数差，x-x1得到行数差 最后列数差/行数差=每行递减值Y</p><p>然后从1点开始，往前一直到2点行每行右边界依次右移 Y 即可得到得到图像</p><p>举个例子 1点为55行 左边界为20列 (55,20) 2点为30行 右边界为70列(30,70) 那么每行递减值 = （70-20）/(55-30) = 2 这样每行位移2即可 当然还可以有一些其他处理让它更接近圆环</p><p>至于最小二乘法拟合直线相信各位都有了解，只要能成功识别1，2两点，拟合补线便是处理问题了</p><p>当然，今年由于限高，可能你的小车看不到2和3点，如果为一下特征，仍然是1点补线，但是从1点到另一边界有赛道的最后一行即可</p><p>2停止补线<br>当车辆进入环内后，可以停止补线了，这时候按照正常寻线来跑即可</p><p>需要注意的是，这里的停止补线标志位要写好，因为小车每次入环的速度和位置是不同的，如果停止补线误判的话会有很大问题</p><p>3出环岛补线</p><p>出环岛补线</p><p>当图中的右赛道边界先减小后增大时的，改行的右边界位置即为补线位置</p><p>上一次右边界-这次右边界&gt;10(这一行赛道宽度-上一行赛道宽度&gt;10) 记录右边界位置</p><p>或者出环岛用电磁出环也可</p><p>毕竟环岛入环是要把他作为一个圆环弯道来处理，不管用什么方法、只要你最后得到的补线能够更好的接近圆环弯道，转向就会越精确,只要1，2两点能够很好识别，怎么让他更好的接近圆环处理，更好的方法需要你的聪慧去发现，同时，入环写好了，出环其实思路一样，</p><p>电磁入环</p><p>电磁入环是五电感入环</p><p>(电感可以改为8字电感)</p><p>具体方法为：</p><p>中间电感一个阀值来识别环岛，识别完成竖直差比和进环，进入后切换水平差比和寻迹，出环时标志位检测用水平电感，延时一定时间或编码器积分清标志即可。</p><p>我们可以这样想，如果是单纯水平电感遇到弯道，会流畅的转向，而在遇到环岛时，我们把竖直电感作为转向环，是不是相当于正常入弯呢</p><p>简单来说，两个不同差和比即可</p><p>Turn_Offset = (float) (LAD-RAD)/(float)(LAD+RAD+MAD)*100;//经典差和比</p><p>Turn_Offset2 = (float) (L1AD-R1AD)/(float)(L1AD+R1AD+MAD)*100;//竖直电感差和比</p><p>当然左竖直电感与与右竖直电感进行差比和 ，还有这一些处理，比如如何适应大小环，入环如何完美和出环稳定性等</p><p>这些问题还是要处理的(可修改PID参数来调节)， 当然希望大家能独立思考下，</p><p>总结：<br>基于今年应该都是电磁+摄像头，可以说在赛道元素处理上即难了，又简单了</p><p>难是对于新手小白(博主)来说，要同时学习处理电磁和摄像头，并且多了一些元素，再加上会车，对小白不是很友好</p><p>简单是电磁+摄像头之后，一些赛道元素可以更好的处理 ，比如环岛，如果单摄像头或者单电磁入环不稳定，可以考虑两个加权，达到较稳定状态，就可以跑得不错。</p><p>总的来说可以是，电感阈值 || 摄像头环岛检测 来判断环岛 (有上帝之光摄像头环岛识别不良) 之后电磁入环还是摄像头入环就要个人考虑了</p><p>感觉有用的话，点个赞再走呗！</p><p>本文作者： Zxiaoxuan</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写在前面：&lt;/p&gt;
&lt;p&gt;搞了好久，试了不下五六种方案，先是摄像头+电磁加权，之后固定打角，随后又是竖直电感入环，竖直电感又搞了几种方式，总是找不到一种代码简便，又能够稳定稳定入环的方案，看了很多国一国二代码，在今天(5.16)突然想到八字电感，想去官网看看有没有类似的，但
      
    
    </summary>
    
      <category term="NXP智能车" scheme="http://zxiaoxuan.cn/categories/NXP%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    
      <category term="NXP智能车" scheme="http://zxiaoxuan.cn/tags/NXP%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
  </entry>
  
  <entry>
    <title>USB转串口 TTL RS-232 RS-485 COM口 UART区别</title>
    <link href="http://zxiaoxuan.cn/posts/7030/"/>
    <id>http://zxiaoxuan.cn/posts/7030/</id>
    <published>2019-09-18T09:18:05.343Z</published>
    <updated>2019-09-18T09:27:37.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1串口"><a href="#1串口" class="headerlink" title="1串口"></a>1串口</h1><p>串口，即串行通信接口，与之相对应的另一种接口叫并口，并行接口。两者的区别是，传输一个字节（8个位）的数据时，串口是将8个位排好队，逐个地在1条连接线上传输，而并口则将8个位一字排开，分别在8条连接线上同时传输   ，<strong>也就是进行数据传输的接口</strong></p><p>串口是一种<strong>物理接口形式</strong>，(硬件)通常指COM接口  ，当然这些接口有着很多标准</p><p><strong>接口标准：</strong></p><p>串口通信的接口标准有很多，<strong>而我们所了解的RS-232C、RS-232、RS-422A、RS-485  都是串口的标准之一</strong></p><p>通常使用的是9 针D 形连接器，简称 DB9接口，也称之为RS-232接口，之前串口通信使用的大多都是 DB9 接口</p><p><img src="https://img-blog.csdn.net/20161118161110850?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p><p><img src="https://img-blog.csdnimg.cn/20190727084643718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p>而有的使用的是老式的DB25 针连接器，也称之为RS-422接口，这种接口目前已经很少使用</p><p><img src="https://img-blog.csdnimg.cn/20190727084628815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p>DB25 和 DB9 接头有公头和母头之分，其中带针状的接头是公头，而带孔状的接头是母头</p><p><img src="https://img-blog.csdnimg.cn/2019072708460742.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p>*<em>而DB9/DB25接口  ，就称为COM口 *</em></p><h1 id="2-UART口"><a href="#2-UART口" class="headerlink" title="2.UART口"></a>2.UART口</h1><p>*<em>嵌入式里面说的串口，一般是指UART口   *</em></p><p>UART  通用异步收发传输器（Universal Asynchronous Receiver/Transmitter)。</p><p>它将要传输的资料在串行通信与并行通信之间加以转换。作为把并行输入信号转成串行输出信号的芯片</p><p>同样它是串行通信接口  UART只有数据线收和发，并无时钟线，故为异步串行通信接口，可以实现全双工传输和接收；在嵌入式中，常用与上位机与外设通信</p><p><strong>单片机中的UART有4个pin（VCC, GND, RX, TX）, 用的TTL电平</strong></p><p><img src="https://img-blog.csdn.net/20161121100753718?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p><p><strong>VCC：</strong>供电pin，一般是3.3v，</p><p><strong>GND：</strong>接地pin，板内共地时可以不单独接，板间通信时候必须接上</p><p><strong>RX：</strong>数据接收引脚</p><p><strong>TX：</strong>数据发送引脚</p><h3 id="TTL电平与RS-232区别"><a href="#TTL电平与RS-232区别" class="headerlink" title="TTL电平与RS-232区别"></a>TTL电平与RS-232区别</h3><p><strong>RS232电平,  它是负逻辑电平，它定义+5<del>+12V为低电平“0”，而-12</del>-5V为高电平“1”</strong></p><p><strong>TTL电平（Transistor-Transistor Logic），该电平的逻辑“1”为+5V，逻辑“0”为0V，称为TTL</strong></p><p><strong>TTL电平标准：</strong></p><p><strong>输出 L： &lt;0.8V ； H：&gt;2.4V。</strong></p><p><strong>输入 L： &lt;1.2V ； H：&gt;2.0V</strong></p><p><strong>需要注意的是</strong>RS-232与<strong>TTL只是一种电平标准，而COM口和UART口是物理接口，只是COM口肯定使用RS-232标准</strong></p><p><strong>而UART一般使用TTL标准</strong></p><h3 id="USB"><a href="#USB" class="headerlink" title="USB"></a>USB</h3><p>通用串行总线（英语：Universal Serial Bus，缩写：<a href="https://baike.baidu.com/item/USB" target="_blank" rel="noopener">U</a>SB）是连接计算机系统与外部设备的一种串口总线标准，也是一种输入输出接口的技术规范，被广泛地应用于个人电脑和移动设备等信息通讯产品  ，随着时代的发展，<strong>USB接口已经逐渐替代了COM口</strong>，成为最主流的接口，现今已经到了USB 3.0</p><p><strong>常见的USB接口：</strong></p><p><img src="https://img-blog.csdnimg.cn/20190727092429880.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p>电脑上的USB接口的输出电压为<strong>直流5V</strong>，输出电流不大于<strong>500毫安 并且</strong>与TTL电平不兼容，信号传输时需要电平转换电路。</p><h3 id="USB转TTL"><a href="#USB转TTL" class="headerlink" title="USB转TTL"></a>USB转TTL</h3><p>我们知道现在电脑使用的基本都是USB接口，而单片机使用的是<strong>TTL标准，那么在嵌入式中我们需要上位机通信，怎么办呢？，这时候便需要一个转换芯片，从而使得电脑(主机)可以通过USB输出TTL电平  ，这便是USB转TTL</strong></p><p><img src="https://img-blog.csdnimg.cn/20190727093456817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p> 那么我们所已知的*<em>CH340G CH340E PL2303 、CP2102 等等 ，都是USB转TTL串口的芯片 *</em></p><p><strong>当然现在普遍使用的为**</strong>CH340G 主要是因为其安全，耐用并且便宜** 满足我们日常的正常使用 </p><p>在接线时注意<strong>单片机RX接转接板TX TX接转接板RX</strong></p><p><img src="https://img-blog.csdnimg.cn/20190727094006869.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p>连接顺序为：</p><p>  电脑USB口—&gt; USB转TTL—-&gt;单片机UART口</p><h3 id="USB转串口-RS-232"><a href="#USB转串口-RS-232" class="headerlink" title="USB转串口(RS-232)"></a>USB转串口(RS-232)</h3><p>我们知道<strong>单片机是UATR口 TTL电平标准</strong>，而电脑是<strong>USB口</strong>  如果我们想用电脑的USB口与单片机串口(COM口)通信，这时就需要使用MAX232之类的电平转换芯片，将单片机TTL电平转换成RS-232电平  ，并且</p><p>将<strong>USB转换为RS-232电平  这就是USB转串口</strong></p><p>我们所说的USB转串口，就是指单片机上装了一个TTL转<strong>RS-232的转换芯片 ，并且有COM口，使得单片机可以输出RS-232电平，这样便可以通过</strong> USB转串口(RS-232)模块连接电脑USB口<strong>，</strong>再与单片机COM口相连<strong>，双方都是RS-232电平标准</strong>，便可以来进行通信</p><p>市场出售的usb转串口线一般会有两个芯片，一个是CH340这类芯片，一个是MAX232类芯片，因为计算机的串口电平标准是RS232电平</p><p>所以通过 USB转<strong>串口(**</strong>RS-232)模块**  USB经过CH340转成了TTL串口，中间那四个引脚可以引出，再经由MAX232转换为RS-232电平，9针串口引出   </p><p><strong>下方为USB转串口(**</strong>RS-232<strong>)</strong>模块**</p><p><img src="https://img-blog.csdnimg.cn/20190727095600600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvMTA5NTE3Ny8yMDE3MDIvMTA5NTE3Ny0yMDE3MDIxMDA5MTYwODk3OS01MjU1Njg3MzguanBn" alt></p><p>并且<strong>MAX232芯片是 TTL电平与RS232电平的专用双向转换芯片</strong>，可以TTL转RS-232，也可以RS-232转TTL</p><p>在单片机上用作TTL转RS-232   </p><p><img src="https://img-blog.csdnimg.cn/20190727095707615.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p>连接顺序为：</p><p>  电脑USB口—&gt;USB转串口—-&gt;单片机COM口</p><p>两个单片机以RS-232通讯协议标准串口的设备间通讯结构图如下：<img src="https://img-blog.csdn.net/20180413140645909" alt>  </p><h3 id="电脑COM口-to-单片机COM口"><a href="#电脑COM口-to-单片机COM口" class="headerlink" title="电脑COM口 to 单片机COM口"></a>电脑COM口 to 单片机COM口</h3><p>当然，如果电脑有COM口，这个时候便可以直接将电脑的COM口与单片机的COM口进行相连，便可以进行通信</p><p><strong>当然在串口通信中通常 电脑的 DB9 为公头，单片机上使用的串口 DB9 为母头，通过一根直通串口线进行相连</strong></p><p>连接顺序为：</p><p>  电脑COM口—&gt;—-&gt;单片机COM口</p><p><img src="https://img-blog.csdnimg.cn/20190727101229401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p>以单<strong>片机串口与PC串口通信就应该遵循下面的连接方式：在单片机串口与上位机给出的rs232口之间，通过电平转换电路(如下面图中的Max232芯片) 实现TTL电平与RS232电平之间的转换。</strong></p><p><img src="https://img-blog.csdn.net/20180410210804176" alt></p><h3 id="电脑USB口-to-单片机USB口"><a href="#电脑USB口-to-单片机USB口" class="headerlink" title="电脑USB口 to 单片机USB口"></a>电脑USB口 to 单片机USB口</h3><p>为了方便，很多单片机上都配备了USB转TTL芯片，直接引出usb接口，便可以实现通信</p><p><img src="https://img-blog.csdnimg.cn/20190727101710102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>最简单理解  xx转xx   就是将前面的转换为后面的  <strong>USB转TTL 就是将USB转换为 TTL电平 USB转串口 就是将USB转换为串口</strong></p><p><strong>①</strong>.COM口：在台式机上常用的口，DB9/DB25接口，接口协议只有两种RS232和RS485</p><p>COM口多见于旧式电脑，用于连接鼠标，调制调解器等设备，现在已被USB取代。</p><p><strong>②</strong>.UART口、COM口指的是物理接口形式;TTL、RS232和RS485指的是电平逻辑标准；</p><p><strong>③</strong>TL电平和RS232电平转换专用芯片有MAX232，TTL电平转USB芯片有CP2102、PL2303、FT230，CH340</p><p><strong>④ COM口 和UART口 都为串口的一种 ，即都为</strong>串行通信  <strong>UART为异步串行通信接口</strong></p><p><strong>⑤UART包含TTL电平的串口和RS232电平的串口，但是我们的单片机的UART是TTL电平</strong></p><p><strong>⑥</strong> 串口按照接口划分标准分为很多种 ，如UATR RS232  同步串行接口 </p><h3 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h3><p><strong>同步通信和异步通信：</strong></p><p>同步通信和异步通信的区别是：时钟线的有无。同步通信有时钟线，<strong>收发双方通过统一的时钟来频率</strong>确定何时进行数据的传输，如I2C和SPI。异步通信没有时钟线，可以任意时刻开始发送字符 但只能在数据的开始和尾加入标志位来区分不同的数据帧，即加上开始位和停止位，所传送的数据以字节为单位。每个字节前加上一位起始位，每个字节的后面加上停止位，接收数据之前也要预先知道波特率的大小，传输效率比同步通信要低。如UART 但方便简单，易于操作</p><p> 简单来说：</p><p>同步是指：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式。<br>异步是指：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。</p><p><strong>串行通信与并行通信：</strong></p><p>串行通信就是一根数据线，数据是一位一位的依次传输    </p><p>而并行通信则是8跟数据线，数据是一个字节一个字节的发送</p><p>串口形容一下就是一条车道，而并口就是有8/16个车道同一时刻能传送8/16位（一个字节/两个字节）数据</p><p><img src="https://img-blog.csdnimg.cn/20190726200706356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1串口&quot;&gt;&lt;a href=&quot;#1串口&quot; class=&quot;headerlink&quot; title=&quot;1串口&quot;&gt;&lt;/a&gt;1串口&lt;/h1&gt;&lt;p&gt;串口，即串行通信接口，与之相对应的另一种接口叫并口，并行接口。两者的区别是，传输一个字节（8个位）的数据时，串口是将8个位排好队，逐
      
    
    </summary>
    
      <category term="嵌入式学习" scheme="http://zxiaoxuan.cn/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="嵌入式学习" scheme="http://zxiaoxuan.cn/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>智能车学习----最小二乘法求拟合曲线(中线)的斜率</title>
    <link href="http://zxiaoxuan.cn/posts/48428/"/>
    <id>http://zxiaoxuan.cn/posts/48428/</id>
    <published>2019-09-18T09:16:34.052Z</published>
    <updated>2019-09-18T09:27:37.237Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最小二乘法："><a href="#最小二乘法：" class="headerlink" title="最小二乘法："></a><strong>最小二乘法：</strong></h2><p>最小二乘法（又称最小平方法）是一种数学<a href="https://baike.baidu.com/item/%E4%BC%98%E5%8C%96" target="_blank" rel="noopener">优化</a>技术。它通过最小化误差的平方和寻找数据的最佳<a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0/301912" target="_blank" rel="noopener">函数</a>匹配。利用最小二乘法可以简便地求得未知的数据，并使得这些求得的数据与实际数据之间误差的平方和为最  小，简单来说，<strong>就是通过最小化误差的平方和，使得拟合对象无限接近目标对象</strong>，这就是最小二乘的核心思想。最小二乘法还可用于<strong>曲线拟合。</strong></p><p>在此先列举一下最小二乘家族成员。最小二乘法<strong>直线拟合</strong>，最小二乘法<strong>多项式（曲线）拟合</strong>，机器学习中<strong>线性回归</strong>的最小二乘法，<strong>系统辨识</strong>中的最小二乘辨识法，参数估计中的最小二乘法，等等</p><p>这里我们要说的是最小二乘法拟合曲线的斜率。</p><p>拟合直线作用：</p><p>在我们做一些处理的时候，得到的数据可能是一些离散的点，而我们往往希望得到一个连续的函数（也就是拟合直线）或者更加密集的离散方程与已知数据相吻合，这过程就叫做拟合，</p><p><img src="https://img-blog.csdnimg.cn/20190731094352961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p>以智能车为例把，我们平时得到的中线，可以说就是一些离散的点，它不是一条顺滑的曲线，而我们的拟合直线，则使用在中线和各种赛道元素补线上，在用中线做偏差处理时，将中线拟合一下，得到的<strong>斜率偏差则是会更加精确</strong>，在一些特殊的赛道元素，如环岛，我们可以用最小二乘法做补线处理，</p><p><img src="https://img-blog.csdnimg.cn/2019040320235819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><h3 id="概念与公式："><a href="#概念与公式：" class="headerlink" title="概念与公式："></a>概念与公式：</h3><p>说到最小二乘法，可能有的同学说没学过，但是我们给出公式应该同学们会说：哦！原来是他啊。</p><h3 id="推导："><a href="#推导：" class="headerlink" title="推导："></a>推导：</h3><p><img src="https://img-blog.csdn.net/20161015151503002?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p><p><img src="https://img-blog.csdn.net/20161015151507487?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p><h3 id="即为："><a href="#即为：" class="headerlink" title="即为："></a>即为：</h3><p><img src="https://img-blog.csdnimg.cn/20190418200709617.png" alt></p><p>最小二乘法多项式直线拟合，就是根据给定的点，用计算的方法求出最佳的 a(斜率) 和 b（截距）。显然，关键是如何求出最佳的 a 和 b。 </p><p>相信各位高中都已经学过了，下面我们给出计算中线斜率的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************线性回归计算中线斜率************************************/</span><span class="comment">// y = Ax+Bint regression(int startline,int endline)&#123;  </span></span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>,SumX=<span class="number">0</span>,SumY=<span class="number">0</span>,SumLines = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">float</span> SumUp=<span class="number">0</span>,SumDown=<span class="number">0</span>,avrX=<span class="number">0</span>,avrY=<span class="number">0</span>,B,A;</span><br><span class="line">  SumLines=endline-startline;   <span class="comment">// startline 为开始行， //endline 结束行 //SumLines</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span>(i=startline;i&lt;endline;i++)     </span><br><span class="line">  &#123; </span><br><span class="line">    SumX+=i;       </span><br><span class="line">    SumY+=Middle\_black\[i\];    <span class="comment">//这里Middle\_black为存放中线的数组</span></span><br><span class="line">  &#125;         </span><br><span class="line">  avrX=SumX/SumLines;     <span class="comment">//X的平均值</span></span><br><span class="line">  avrY=SumY/SumLines;     <span class="comment">//Y的平均值       </span></span><br><span class="line">  SumUp=<span class="number">0</span>;      </span><br><span class="line">  SumDown=<span class="number">0</span>;  </span><br><span class="line">  <span class="keyword">for</span>(i=startline;i&lt;endline;i++)   </span><br><span class="line">  &#123;       </span><br><span class="line">    SumUp+=(Middle_black\[i\]-avrY)*(i-avrX);    </span><br><span class="line">    SumDown+=(i-avrX)*(i-avrX);    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="keyword">if</span>(SumDown==<span class="number">0</span>) </span><br><span class="line">    B=<span class="number">0</span>;  </span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    B=(<span class="keyword">int</span>)(SumUp/SumDown);       </span><br><span class="line">    A=(SumY-B*SumX)/SumLines;  <span class="comment">//截距</span></span><br><span class="line">    <span class="keyword">return</span> B;  <span class="comment">//返回斜率&#125;</span></span><br></pre></td></tr></table></figure><p>看代码很容易可以理解。</p><p>对于斜率的使用，个人是将他与误差结合起来使用，效果还输不错的</p><p><img src="https://img-blog.csdnimg.cn/20190419200008346.png" alt></p><p>那么，用最小二乘法除了拟合中线斜率之外，我们还可以用斜率进行补线操作，以及用最小二乘法预估赛道边界，等等</p><p>这里我们暂时不做阐述，之后博文会更新，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;最小二乘法：&quot;&gt;&lt;a href=&quot;#最小二乘法：&quot; class=&quot;headerlink&quot; title=&quot;最小二乘法：&quot;&gt;&lt;/a&gt;&lt;strong&gt;最小二乘法：&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;最小二乘法（又称最小平方法）是一种数学&lt;a href=&quot;https://b
      
    
    </summary>
    
      <category term="NXP智能车" scheme="http://zxiaoxuan.cn/categories/NXP%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    
      <category term="NXP智能车" scheme="http://zxiaoxuan.cn/tags/NXP%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
  </entry>
  
  <entry>
    <title>位置式PID与增量式PID区别浅析</title>
    <link href="http://zxiaoxuan.cn/posts/29144/"/>
    <id>http://zxiaoxuan.cn/posts/29144/</id>
    <published>2019-09-18T09:15:12.867Z</published>
    <updated>2019-09-18T11:37:40.452Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1PID控制算法"><a href="#1PID控制算法" class="headerlink" title="1PID控制算法"></a>1PID控制算法</h2><h3 id="什么是PID"><a href="#什么是PID" class="headerlink" title="什么是PID"></a>什么是PID</h3><blockquote><p>PID 控制器以各种形式使用超过了 1 世纪，广泛应用在机械设备、气动设备 和电子设备.在工业应用中PID及其衍生算法是应用最广泛的算法之一，是当之无愧的万能算法</p></blockquote><p>PID 实指“比例 proportional”、“积分 integral”、“微分 derivative”，这三项构 成 PID 基本要素。每一项完成不同任务，对系统功能产生不同的影响。它的结构简单，参数易 于调整，是控制系统中经常采用的控制算法。</p><p><strong>PID：比例单元（P）、积分单元（I）和微分单元（D）组成</strong></p><p><img src="https://img-blog.csdnimg.cn/20181209084010623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p>PID控制公式</p><p><img src="https://img-blog.csdnimg.cn/20190425075600728.png" alt></p><p>其中：<strong>u(t)</strong>为控制器输出的控制量；（输出）</p><p><strong>e(t)</strong>为偏差信号，它等于给定量与输出量之差；（输入）</p><p><strong>KP</strong> 为比例系数；（对应参数 P）</p><p><strong>TI</strong> 为积分时间常数；（对应参数I）</p><p><strong>TD</strong> 为微分时间常数。(对应参数 D) </p><p>数字 PID 控制算法通常分为位置式 PID 控制算法和增量式 PID 控制算法。  </p><h3 id="位置式-PID-算法"><a href="#位置式-PID-算法" class="headerlink" title="位置式 PID 算法 :"></a>位置式 PID 算法 :</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9nc3MwLmJhaWR1LmNvbS85NG8zZFNhZ194STRraEdrbzlXVEFuRjZoaHkvemhpZGFvL3doJTNENjAwJTJDODAwL3NpZ249NWJmZjY5MDhmMjE5ODYxODQxMTJlNzgyN2FkZDAyNGIvYjgxMmM4ZmNjM2NlYzNmZDE0ZTc0YjFjZGM4OGQ0M2Y4Njk0MjdmYS5qcGc" alt="pid算法中位置型和增量型有什么区别，分析两者优缺点"></p><p> e(k): *<em>用户设定的值（目标值） -  控制对象的当前的状态值 *</em></p><p>*<em>比例P :   *</em> e(k)</p><p>*<em>积分I : *</em>  ∑e(i)     误差的累加</p><p><strong>微分D :</strong>  e(k) - e(k-1)  这次误差-上次误差</p><p><strong>也就是位置式PID是当前**</strong>系统的实际位置，与你想要达到的预期位置的偏差，<strong>**进行PID控制</strong></p><p>因为有误差积分 ∑e(i)，一直累加，也就是当前的输出u(k)与过去的所有状态都有关系，用到了误差的累加值；（误差e会有误差累加），输出的u(k)对应的是执行机构的实际位置，，一旦控制输出出错(*<em>控制对象的当前的状态值出现问题 *</em>)，u(k)的大幅变化会引起系统的大幅变化</p><p>并且位置式PID在积分项达到饱和时,误差仍然会在积分作用下继续累积，一旦误差开始反向变化，系统需要一定时间从饱和区退出，所以在u(k)达到最大和最小时，要停止积分作用，并且要有<strong>积分限幅</strong>和<strong>输出限幅</strong></p><p><strong>所以在使用位置式PID时，一般我们直接使用PD控制</strong></p><p><strong>而位置式 PID 适用于执行机构不带积分部件的对象，如舵机和平衡小车的直立和**</strong>温控系统的控制**</p><p>结合代码可以很好理解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PID</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">  <span class="keyword">float</span> P,I,D,limit;</span><br><span class="line">&#125;PID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Error</span></span></span><br><span class="line"><span class="class">&#123;</span>  <span class="keyword">float</span> Current_Error;<span class="comment">//当前误差</span></span><br><span class="line">  <span class="keyword">float</span> Last_Error;<span class="comment">//上一次误差</span></span><br><span class="line">  <span class="keyword">float</span> Previous_Error;<span class="comment">//上上次误差&#125;Error;/*! </span></span><br><span class="line"> *  @brief      位置式PID</span><br><span class="line"> *  @since      v1<span class="number">.0</span></span><br><span class="line"> *  *sptr ：误差参数</span><br><span class="line"> *  *pid:  PID参数</span><br><span class="line"> *  NowPlace：当前位置</span><br><span class="line"> *  Point：   预期位置  </span><br><span class="line"> *<span class="comment">/// 位置式PID控制float PID_Realize(Error \*sptr,PID \*pid, int32 NowPlace, float Point)&#123;</span></span><br><span class="line"></span><br><span class="line">int32 iError,<span class="comment">// 当前误差</span></span><br><span class="line"> Realize;   <span class="comment">//实际输出</span></span><br><span class="line"></span><br><span class="line">iError = Point - NowPlace;<span class="comment">// 计算当前误差</span></span><br><span class="line">sptr-&gt;Current_Error += pid-&gt;I * iError;<span class="comment">// 误差积分</span></span><br><span class="line">      sptr-&gt;Current\_Error = sptr-&gt;Current\_Error &gt; pid-&gt;limit?pid-&gt;limit:sptr-&gt;Current_Error;<span class="comment">//积分限幅</span></span><br><span class="line">      sptr-&gt;Current\_Error = sptr-&gt;Current\_Error &lt;-pid-&gt;limit?-pid-&gt;limit:sptr-&gt;Current_Error;</span><br><span class="line">Realize = pid-&gt;P * iError       <span class="comment">//比例P</span></span><br><span class="line">            + sptr-&gt;Current_Error   <span class="comment">//积分I</span></span><br><span class="line">+ pid-&gt;D * (iError - sptr-&gt;Last_Error);  <span class="comment">//微分D</span></span><br><span class="line">sptr-&gt;Last_Error = iError;  <span class="comment">// 更新上次误差</span></span><br><span class="line"><span class="keyword">return</span> Realize;<span class="comment">// 返回实际值&#125;</span></span><br></pre></td></tr></table></figure><h3 id="增量式PID"><a href="#增量式PID" class="headerlink" title="增量式PID"></a>增量式PID</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9nc3MwLmJhaWR1LmNvbS85NG8zZFNhZ194STRraEdrbzlXVEFuRjZoaHkvemhpZGFvL3doJTNENjAwJTJDODAwL3NpZ249NjAyYzFhOTdjOWZkZmMwM2U1MmRlYmJlZTQwZmFiYWMvZTRkZGU3MTE5MGVmNzZjNjBmM2YxNzQyOTcxNmZkZmFhZTUxNjdlZS5qcGc" alt="pid算法中位置型和增量型有什么区别，分析两者优缺点"></p><p><strong>比例P :</strong>   e(k)-e(k-1)   这次误差-上次误差</p><p><strong>积分I :</strong>   e(i)     误差   </p><p>*<em>微分D : *</em> e(k) - 2e(k-1)+e(k-2)   这次误差-2*上次误差+上上次误差</p><p> 增量式PID根据公式可以很好地看出，一旦确定了 KP、TI  、TD，只要使用前后三次测量值的偏差， 即可由公式求出控制增量</p><p><strong>而得出的控制量▲u(k)对应的是近几次位置误差的增量，而不是对应与实际位置的偏差     没有误差累加</strong></p><p>也就是说，增量式PID中不需要累加。控制增量Δu(k)的确定仅与<strong>最近3次的采样值</strong>有关，容易通过加权处理获得比较好的控制效果，并且在系统发生问题时，增量式不会严重影响系统的工作</p><p><strong>总结：</strong>增量型 PID，是对位置型 PID 取增量，这时控制器输出的是相邻两次采样时刻所计算的位置值<br>之差，得到的结果是增量，即在上一次的控制量的基础上需要增加（负值意味减少）控制量。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PID</span>&#123;</span> </span><br><span class="line">  <span class="keyword">float</span> P,I,D,limit;</span><br><span class="line">&#125;PID;<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Error</span>&#123;</span></span><br><span class="line">  <span class="keyword">float</span> Current_Error;<span class="comment">//当前误差</span></span><br><span class="line">  <span class="keyword">float</span> Last_Error;<span class="comment">//上一次误差</span></span><br><span class="line">  <span class="keyword">float</span> Previous_Error;<span class="comment">//上上次误差&#125;Error;/*! </span></span><br><span class="line"> *  @brief      增量式PID</span><br><span class="line"> *  @since      v1<span class="number">.0</span></span><br><span class="line"> *  *sptr ：误差参数</span><br><span class="line"> *  *pid:  PID参数</span><br><span class="line"> *  NowPlace：实际值</span><br><span class="line"> *  Point：   期望值</span><br><span class="line"> *<span class="comment">/// 增量式PID电机控制int32 PID_Increase(Error \*sptr, PID \*pid, int32 NowPlace, int32 Point)&#123;</span></span><br><span class="line"></span><br><span class="line">int32 iError,<span class="comment">//当前误差</span></span><br><span class="line">Increase;<span class="comment">//最后得出的实际增量</span></span><br><span class="line"></span><br><span class="line">iError = Point - NowPlace;<span class="comment">// 计算当前误差</span></span><br><span class="line"></span><br><span class="line">Increase =  pid-&gt;P * (iError - sptr-&gt;Last_Error)   <span class="comment">//比例P</span></span><br><span class="line">  + pid-&gt;I * iError      <span class="comment">//积分I</span></span><br><span class="line">  + pid-&gt;D * (iError - <span class="number">2</span> * sptr-&gt;Last\_Error + sptr-&gt;Previous\_Error);  <span class="comment">//微分D</span></span><br><span class="line"></span><br><span class="line">sptr-&gt;Previous\_Error = sptr-&gt;Last\_Error;<span class="comment">// 更新前次误差</span></span><br><span class="line">sptr-&gt;Last_Error = iError;  <span class="comment">// 更新上次误差</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Increase;<span class="comment">// 返回增量&#125;</span></span><br></pre></td></tr></table></figure><h2 id="增量式与位置式区别："><a href="#增量式与位置式区别：" class="headerlink" title="增量式与位置式区别："></a><strong>增量式与位置式区别：</strong></h2><p>*<em>1增量式算法不需要做累加，控制量增量的确定仅与最近几次偏差采样值有关，计算误差对控制 量计算的影响较小。而位置式算法要用到过去偏差的累加值，容易产生较大的累加误差。 *</em></p><p><strong>2增量式算法得出的是控制量的增量，例如在阀门控制中，只输出阀门开度的变化部分，误动作 影响小，必要时还可通过逻辑判断限制或禁止本次输出，不会严重影响系统的工作。 而位置式的输出直接对应对象的输出，因此对系统影响较大</strong>。</p><p><strong>3增量式PID控制输出的是控制量增量，并无积分作用，因此该方法适用于执行机构带积分部件的对象，如步进电机等，而位置式PID适用于执行机构不带积分部件的对象，如电液伺服阀。</strong></p><p><strong>4在进行PID控制时，位置式PID需要有积分限幅</strong>和<strong>输出限幅，而增量式PID只需输出限幅</strong></p><h3 id="位置式PID优缺点："><a href="#位置式PID优缺点：" class="headerlink" title="位置式PID优缺点："></a><strong>位置式PID优缺点：</strong></h3><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a><strong>优点：</strong></h3><p><strong>①位置式PID是一种非递推式算法，可直接控制执行机构（如平衡小车），u(k)的值和执行机构的实际位置（如小车当前角度）是一一对应的，因此在执行机构不带积分部件的对象中可以很好应用</strong></p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a><strong>缺点：</strong></h3><p><strong>①每次输出均与过去的状态有关，计算时要对e(k)进行累加，运算工作量大。</strong></p><h3 id="增量式PID优缺点："><a href="#增量式PID优缺点：" class="headerlink" title="增量式PID优缺点："></a><strong>增量式PID优缺点：</strong></h3><h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><p><strong>①误动作时影响小，必要时可用逻辑判断的方法去掉出错数据。<br>②手动/自动切换时冲击小，便于实现无扰动切换。当计算机故障时，仍能保持原值。<br>③算式中不需要累加。控制增量Δu(k)的确定仅与最近3次的采样值有关。</strong></p><h3 id><a href="#" class="headerlink" title=" "></a> </h3><p><strong>缺点：</strong></p><p><strong>①积分截断效应大，有稳态误差；</strong></p><p><strong>②溢出的影响大。有的被控对象用增量式则不太好；</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1PID控制算法&quot;&gt;&lt;a href=&quot;#1PID控制算法&quot; class=&quot;headerlink&quot; title=&quot;1PID控制算法&quot;&gt;&lt;/a&gt;1PID控制算法&lt;/h2&gt;&lt;h3 id=&quot;什么是PID&quot;&gt;&lt;a href=&quot;#什么是PID&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="NXP智能车" scheme="http://zxiaoxuan.cn/categories/NXP%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    
      <category term="NXP智能车" scheme="http://zxiaoxuan.cn/tags/NXP%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
  </entry>
  
  <entry>
    <title>OTSU大津法优化算法(0.8ms/1.0ms)</title>
    <link href="http://zxiaoxuan.cn/posts/26471/"/>
    <id>http://zxiaoxuan.cn/posts/26471/</id>
    <published>2019-09-18T07:10:27.200Z</published>
    <updated>2019-09-30T13:32:45.479Z</updated>
    
    <content type="html"><![CDATA[<p>两种优化方式 1.0ms与0.8ms<br>////////////////////大津法二值化//////////////////////<br> <a id="more"></a><br>/*! </p><ul><li><p>@brief      大津法二值化0.8ms程序</p></li><li><p>@since      v1.2</p></li><li><p>*image ：图像地址</p></li><li><p>width:  图像宽</p></li><li><p>height：图像高</p></li><li><p>@author     ZZX</p></li><li><p>注：河北工程大学内部使用</p></li><li><p>/</p></li></ul><p>   //0x4D;0x18-0x1A;<br>uint8 otsuThreshold(uint8 <em>image, uint16 width, uint16 height)<br>{<br>    #define GrayScale 256<br>    int pixelCount[GrayScale] = {0};//每个灰度值所占像素个数<br>    float pixelPro[GrayScale] = {0};//每个灰度值所占总像素比例<br>    int i,j;<br>    int Sumpix = width * height;   //总像素点<br>    uint8 threshold = 0;<br>    uint8</em> data = image;  //指向像素数据的指针</p><p>}</p><p>////////////////////大津法二值化//////////////////////</p><p>/*! </p><ul><li><p>@brief      大津法二值化1.0ms程序</p></li><li><p>@since      v1.2</p></li><li><p>*image ：图像地址</p></li><li><p>width:  图像宽</p></li><li><p>height：图像高</p></li><li><p>@author     ZZX</p></li><li><p>注：河北工程大学内部使用</p></li><li><p>/</p></li></ul><p>   //0x4D;0x18-0x1A;<br>uint8 otsu1ms(uint8 *image, uint16 width, uint16 height)<br>{<br>////////////////////大津法二值化//////////////////////</p><p>/*! </p><ul><li><p>@brief      大津法二值化1.0ms程序</p></li><li><p>@since      v1.2</p></li><li><p>*image ：图像地址</p></li><li><p>width:  图像宽</p></li><li><p>height：图像高</p></li><li><p>@author     ZZX</p></li><li><p>注：河北工程大学内部使用</p></li><li><p>/////////////////////大津法二值化//////////////////////</p></li></ul><p>/*! </p><ul><li><p>@brief      大津法二值化1.0ms程序</p></li><li><p>@since      v1.2</p></li><li><p>*image ：图像地址</p></li><li><p>width:  图像宽</p></li><li><p>height：图像高</p></li><li><p>@author     ZZX</p></li><li><p>注：河北工程大学内部使用</p></li><li><p>/////////////////////大津法二值化//////////////////////</p></li></ul><p>/*! </p><ul><li><p>@brief      大津法二值化1.0ms程序</p></li><li><p>@since      v1.2</p></li><li><p>*image ：图像地址</p></li><li><p>width:  图像宽</p></li><li><p>height：图像高</p></li><li><p>@author     ZZX</p></li><li><p>注：河北工程大学内部使用</p></li><li><p>/////////////////////大津法二值化//////////////////////</p></li></ul><p>/*! </p><ul><li><p>@brief      大津法二值化1.0ms程序</p></li><li><p>@since      v1.2</p></li><li><p>*image ：图像地址</p></li><li><p>width:  图像宽</p></li><li><p>height：图像高</p></li><li><p>@author     ZZX</p></li><li><p>注：河北工程大学内部使用</p></li><li><p>/////////////////////大津法二值化//////////////////////</p></li></ul><p>/*! </p><ul><li><p>@brief      大津法二值化1.0ms程序</p></li><li><p>@since      v1.2</p></li><li><p>*image ：图像地址</p></li><li><p>width:  图像宽</p></li><li><p>height：图像高</p></li><li><p>@author     ZZX</p></li><li><p>注：河北工程大学内部使用</p></li><li><p>/</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;两种优化方式 1.0ms与0.8ms&lt;br&gt;////////////////////大津法二值化//////////////////////&lt;br&gt;
    
    </summary>
    
      <category term="NXP智能车" scheme="http://zxiaoxuan.cn/categories/NXP%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    
      <category term="NXP智能车" scheme="http://zxiaoxuan.cn/tags/NXP%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
  </entry>
  
  <entry>
    <title>智能车环岛浅析(电磁+摄像头)</title>
    <link href="http://zxiaoxuan.cn/posts/21849/"/>
    <id>http://zxiaoxuan.cn/posts/21849/</id>
    <published>2019-09-18T07:07:32.303Z</published>
    <updated>2019-09-18T07:25:38.752Z</updated>
    
    <content type="html"><![CDATA[<p>写在前面：</p><p> 看到网上对于环岛的介绍微乎其微，想着写点什么，对于一些没有祖传代码和资料的同学起到一点指导和抛砖引玉的作用把，看了一些国一国二的代码，发现跟自己想的方法基本一致，所以个人认为应该能对没有思路的同学有一点启发，当然，比赛最主要的就是锻炼个人能力，条条大路通环岛，希望同学们不要被我的这种方法所局限，自己的思想无论在何时都是要有的，当然，由于本人能力不足等原因，如果有错误欢迎批评指出。</p><h1 id="摄像头入环"><a href="#摄像头入环" class="headerlink" title="摄像头入环"></a>摄像头入环</h1><h3 id="1识别环岛"><a href="#1识别环岛" class="headerlink" title="1识别环岛"></a>1识别环岛</h3><p><img src="https://img-blog.csdnimg.cn/20190324100122859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p>想着入环岛，那么最基本的肯定要先做到识别，对于环岛的识别，我个人的思想是分为五部分即可，以右环岛为例</p><p>1 在第一部分时，你会发现<strong>右边赛道宽度突然变宽，而左边赛道正常(可以区分环岛和十字(十字为两边发生突变))</strong></p><p><strong>这时候便可以加一个标志位1，</strong></p><p><strong>2.在第二部分，我们可以看到左边赛道无突变，右边赛道丢线(检测不到黑点)，各位应该都有丢线标志位</strong></p><p><strong>这时便有环岛标志位2</strong></p><p><strong>3在第三部分(标志位1和标志位2成立)，我们可以看到右边赛道先是逐渐变窄，之后便是逐渐变宽，这时候可以得到标志位3</strong></p><p><strong>并且记录下右赛道刚开始变宽时的行位置</strong></p><p><strong>4**</strong>.之后你会发现右边赛道再次丢线，最后一个标志位**</p><p><strong>5。当然少不了最后的V(赛道宽度发生突变)</strong></p><p><strong>识别其实不难，大家可以根据自己的图像来具体修改，具体识别会有不同，但有思路即可，你会发现3，4，5在一幅图像中，也可以根据这些来进行判断，(当然，今年各位应该都是电磁+摄像头，这样的话环岛识别便更为简单，电磁信号变为双倍，并且摄像头有少许标志位，便可以很简单的判断出环岛，)之后便是最重要的补线了</strong></p><p><img src="https://img-blog.csdnimg.cn/2019033110215945.png" alt></p><h3 id="补线"><a href="#补线" class="headerlink" title="补线"></a><strong>补线</strong></h3><p><img src="https://img-blog.csdnimg.cn/2019033110542246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p><strong>补线便是根据1和2点根据斜率连接，最小二乘法拟合得到相应的中线</strong></p><p><strong>1点 ：右边界为直线，上一次左边界-这次左边界&gt;10(这一行赛道宽度-上一行赛道宽度&gt;10) 并记录下该行左边界位置，即为1点</strong></p><p>*<em>2点： 前面有提到过，右边界为直线，这一行左边界-上一行左边界&gt;2 记录下此时左右边界位置 右边界为2点 *</em></p><p><strong>3点： 2点的左边界即为3点</strong></p><p><strong>4.如果为左环岛，则右边界为直道。</strong></p><h3 id="赛道边界法："><a href="#赛道边界法：" class="headerlink" title="赛道边界法："></a>赛道边界法：</h3><p>如果不用拟合直线，可以考虑以1点作为赛道右边界，然后右边界往前依次递增(右环岛为递减) 直到2点处，也可得到不错的入环效果</p><p>具体方法是假设1点为x行y列 2点为x2行y2列  用y-y1得到列数差，x-x1得到行数差 最后列数差/行数差=每行递减值Y</p><p>然后从1点开始，往前一直到2点行每行右边界依次右移 Y  即可得到得到图像</p><p>举个例子  1点为55行 左边界为20列  (55,20) 2点为30行 右边界为70列(30,70)  那么每行递减值 = （70-20）/(55-30) = 2 这样每行位移2即可   当然还可以有一些其他处理让它更接近圆环</p><p>至于最小二乘法拟合直线相信各位都有了解，只要能成功识别1，2两点，拟合补线便是处理问题了</p><p><strong>当然，今年由于限高，可能你的小车看不到2和3点</strong>，如果为一下特征，仍然是1点补线，但是从<strong>1点到另一边界有赛道的最后一行</strong>即可</p><p><img src="https://img-blog.csdnimg.cn/2019040616091891.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><h3 id="2停止补线"><a href="#2停止补线" class="headerlink" title="2停止补线"></a>2停止补线</h3><p>当车辆进入环内后，可以停止补线了，这时候按照正常寻线来跑即可</p><p>需要注意的是，这里的停止补线标志位要写好，因为小车每次入环的速度和位置是不同的，如果停止补线误判的话会有很大问题</p><h3 id="3出环岛补线"><a href="#3出环岛补线" class="headerlink" title="3出环岛补线"></a>3出环岛补线</h3><p><img src="https://img-blog.csdnimg.cn/20190403192811497.png" alt></p><p>出环岛补线</p><p>当图中的右赛道边界先减小后增大时的，改行的右边界位置即为补线位置</p><p><strong>上一次右边界-这次右边界&gt;10(这一行赛道宽度-上一行赛道宽度&gt;10)   记录右边界位置</strong></p><p>或者<strong>出环岛用电磁出环也可</strong></p><p>毕竟环岛入环是要把他作为一个圆环弯道来处理，不管用什么方法、只要你最后得到的<strong>补线能够更好的接近圆环弯道</strong>，转向就会越精确,只要1，2两点能够很好识别，怎么让他更好的接近圆环处理，更好的方法需要你的聪慧去发现，同时，入环写好了，出环其实思路一样，</p><p><img src="https://img-blog.csdnimg.cn/20190331112055211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><h1 id="电磁入环"><a href="#电磁入环" class="headerlink" title="电磁入环"></a>电磁入环</h1><p><img src="https://img-blog.csdnimg.cn/20190331114232679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p>电磁入环是五电感入环</p><p>(<strong>电感可以改为8字电感</strong>)</p><p>具体方法为：</p><p><strong>中间电感一个阀值来识别环岛，识别完成竖直差比和进环，进入后切换水平差比和寻迹，出环时标志位检测用水平电感，延时一定时间或编码器积分清标志即可。</strong></p><p>我们可以这样想，如果是单纯水平电感遇到弯道，会流畅的转向，而在遇到环岛时，我们把竖直电感作为转向环，是不是相当于正常入弯呢    </p><p>简单来说，两个不同差和比即可</p><p>Turn_Offset = (float) (LAD-RAD)/(float)(LAD+RAD+MAD)*100;//经典差和比</p><p>Turn_Offset2 = (float) (L1AD-R1AD)/(float)(L1AD+R1AD+MAD)*100;//竖直电感差和比</p><p>当然左竖直电感与与右竖直电感进行差比和 ，还有这一些处理，比如如何适应大小环，入环如何完美和出环稳定性等</p><p>这些问题还是要处理的(可修改PID参数来调节)，    当然希望大家能独立思考下，</p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>基于今年应该都是电磁+摄像头，可以说在赛道元素处理上即难了，又简单了</p><p>难是对于新手小白(博主)来说，要同时学习处理电磁和摄像头，并且多了一些元素，再加上会车，对小白不是很友好</p><p>简单是电磁+摄像头之后，一些赛道元素可以更好的处理 ，比如环岛，如果单摄像头或者单电磁入环不稳定，可以考虑两个加权，达到较稳定状态，就可以跑得不错。</p><p>总的来说可以是，电感阈值 || 摄像头环岛检测 来判断环岛  (有上帝之光摄像头环岛识别不良)  之后电磁入环还是摄像头入环就要个人考虑了</p><p><strong>感觉有用的话，点个赞再走呗！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写在前面：&lt;/p&gt;
&lt;p&gt; 看到网上对于环岛的介绍微乎其微，想着写点什么，对于一些没有祖传代码和资料的同学起到一点指导和抛砖引玉的作用把，看了一些国一国二的代码，发现跟自己想的方法基本一致，所以个人认为应该能对没有思路的同学有一点启发，当然，比赛最主要的就是锻炼个人能力，条
      
    
    </summary>
    
      <category term="NXP智能车" scheme="http://zxiaoxuan.cn/categories/NXP%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    
      <category term="NXP智能车" scheme="http://zxiaoxuan.cn/tags/NXP%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【C语言】C语言学习整理-putchar,printf，getchar，scanf定义及区别</title>
    <link href="http://zxiaoxuan.cn/posts/51464/"/>
    <id>http://zxiaoxuan.cn/posts/51464/</id>
    <published>2019-09-18T06:40:31.951Z</published>
    <updated>2019-09-18T06:52:14.439Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><blockquote><p>花一点时间认真阅读，这篇文章应该会让您多理解一点东西。</p></blockquote><h3 id="1-getchar"><a href="#1-getchar" class="headerlink" title="1.getchar"></a>1.getchar</h3><p>getchar函数是字符输入函数，其功能是从键盘上获取<strong>一个输入字符。</strong></p><p><strong>读取方式：</strong></p><p>从stdio(输入)流中读字符，相当于getc(stdin），它从标准输入(键盘)里读取下一个字符。，返回值为用户输入的ASCⅡ码，出错返回-1，用户输入的字符被存放在键盘缓冲区中.<strong>直到输入回车键才从缓冲区依次提取字符</strong>，当用户键入回车之后,getchar会从输入流中读取第一个字符，</p><p><strong>注意：</strong></p><p>1.getchar只能输入一个字符。如果你输入多个字符，它只接受<strong>第一个字符</strong>。</p><p>_2._如果输入流缓冲区中没有数据，那么getchar就会处于等待状态，从而使程序窗口停留。这也是为什么getchar可以作为暂停函数的原因，</p><h3 id="2-scanf"><a href="#2-scanf" class="headerlink" title="2.scanf"></a><strong>2.scanf</strong></h3><p><strong>scanf（）函数</strong>是格式输入函数，即按用户指定的格式从标准输入设备(键盘) 上把数据输入到指定地址的变量中。</p><p><strong>读取方式：</strong></p><p>一般格式为：scanf（格式控制，地址列表）  也就是scanf(“%?”,&amp;?);   可以读取相对于类型的数值并且存储到制定变量，并且可以读取多个数值，如数字，字符，字符串等    </p><p><strong>注意：</strong></p><p><strong>scanf()在读取数字时会跳过空格、制表符和换行符！</strong></p><h3 id="两者区别："><a href="#两者区别：" class="headerlink" title="两者区别："></a>两者区别：</h3><p>1.scanf返回成功赋值项个数，并将数值赋值到指定参数上，而getchar只读取一个字符并返回其ascii码，并且可以赋值也可以不赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scanf(&quot;%d&quot;,&amp;a);</span><br><span class="line">getchar();</span><br><span class="line">ch =  getchar();   //两者都正确</span><br></pre></td></tr></table></figure><p>2.<strong>结束输入的方式不同</strong></p><p><strong>scanf遇到 回车(enter)，空格，TAB 就会结束一次输入，空格不会接收</strong></p><p><strong>getchar函数只以回车Enter结束输入，接受空格符。</strong></p><p><strong>3.</strong></p><p><strong>scanf在一次输入结束后，不会舍弃最后的回车符（即回车符会残留在缓冲区中）</strong></p><p><strong>getchar回车作为结束的标志，所以在敲回车时’\n’也被存入缓存</strong></p><p><strong>看下面的程序：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;int main()&#123;    char c1,c2;    scanf(&quot;%c %c&quot;,&amp;c1,&amp;c2);   //这里有一个空格</span><br><span class="line">    printf(&quot;%d %d\\n&quot;,c1,c2);    scanf(&quot;%c%c&quot;,&amp;c1,&amp;c2);    printf(&quot;%d %d\\n&quot;,c1,c2);    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190509135241746.png" alt></p><p>第一次输入a和b正常，没有问题，但是第二次就出现问题了，</p><p>scanf<strong>单字符</strong>输入时规定只接收一个字符，所以第一次输入a  b 时 ，<strong>第一个scanf(“%c %c”）之间有一个空格，所以在输入字符a之后，我们可以输入空格，enter，，scanf都会自动忽略它(那个空格会读取停止字符并释放掉)</strong>，所以第一次输入正常，但它却把<strong>回车符也作为字符对待</strong>的。在我们输入完b之后按回车(Enter)，这个回车符是放在缓冲区的，并且<strong>不会舍弃最后的回车符</strong></p><p>第二次调用scanf(“%c%c”,&amp;c1,&amp;c2);是从缓冲区中取两个字符，首先把第一次调用scanf(“%c%c”,&amp;c1,&amp;c2);后输入的回车当作输入字符赋值给c1 ，之后把a赋值给了c2</p><p>这就在输入逻辑上造成了混乱。</p><p>我们这样改一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;int main()&#123;    char c1,c2;    scanf(&quot;%c %c&quot;,&amp;c1,&amp;c2);   //这里有一个空格</span><br><span class="line">    printf(&quot;%d %d\\n&quot;,c1,c2);    scanf(&quot; %c %c&quot;,&amp;c1,&amp;c2);   //这里也有了空格</span><br><span class="line">    printf(&quot;%d %d\\n&quot;,c1,c2);    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190509140847814.png" alt></p><p>这下就会正确了</p><p><strong>scanf(“ %c”,&amp;c)这个空格（换成\n或者\t也可以），这样就把缓冲区中的回车当成第一个字符，读取后丢掉</strong></p><p><strong>可以很好理解：  空格( )即为读取一个结束字符然后丢掉，而普通的字符不受影响</strong></p><p>用好之后可以避免很多程序BUG</p><p>当然我们也可以用<strong>getchar()来把之前的缓冲区里的回车删除掉，而不用 (空格)  这是getchar()的常用用法之一</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;int main()&#123;    char c1,c2;    scanf(&quot;%c %c&quot;,&amp;c1,&amp;c2);   //这里有一个空格</span><br><span class="line">    printf(&quot;%d %d\\n&quot;,c1,c2);</span><br><span class="line">    getchar();   //吸收回车缓存</span><br><span class="line">    scanf(&quot;%c %c&quot;,&amp;c1,&amp;c2);   //这里也有了空格</span><br><span class="line">    printf(&quot;%d %d\\n&quot;,c1,c2);    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来一个下方加深理解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;char c1\[10\],c2\[10\];int main()&#123; </span><br><span class="line">scanf(&quot;%s&quot;,&amp;c1);    printf(&quot;%s\\n&quot;,c1);    scanf(&quot; %s&quot;,&amp;c2);  </span><br><span class="line">    printf(&quot;%s&quot;,c2);    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若输入Hello World！的时候有空格 结果为下方：</p><p><img src="https://img-blog.csdnimg.cn/20190509181224598.png" alt></p><p><img src="https://img-blog.csdnimg.cn/20190509181824809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p>输入完Hello World！之后按回车(Enter)直接执行完毕</p><p>因为在你输入Hello World！并且按下Enter(回车)的时候，Hello World！和Enter(回车)都会被送入到输入流缓冲区</p><p>而第一个scanf读取时遇到  空格  直接停止读取，所以c1为Hello   这时候第一个空格被释放</p><p>而第二个scanf继续从输入流缓冲区读取剩下的数据(World！)在读取完！之后有一个Enter(回车) 停止读取，直接执行Printf</p><p>程序运行完毕</p><p>4.<strong>scanf()在读取数字时会跳过空格、回车(Enter)、制表符和换行符！</strong></p><p><strong>getchar函数只能输入字符型,</strong>输入时遇到回车键才从缓冲区依次提取字符。</p><p><strong>看下面的程序：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;int main()&#123;    int c1,c2;    scanf(&quot;%d%d&quot;,&amp;c1,&amp;c2);   //没有空格</span><br><span class="line">    printf(&quot;%d %d\\n&quot;,c1,c2);    scanf(&quot;%d%d&quot;,&amp;c1,&amp;c2);   //没有空格</span><br><span class="line">    printf(&quot;%d %d\\n&quot;,c1,c2);    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果正常，因为会<strong>自动跳过空格、回车(Enter)来进行读取</strong></p><p><img src="https://img-blog.csdnimg.cn/20190509180443497.png" alt></p><h2 id="技能提升："><a href="#技能提升：" class="headerlink" title="技能提升："></a>技能提升：</h2><h3 id="1gets"><a href="#1gets" class="headerlink" title="1gets"></a><strong>1gets</strong></h3><p><strong>gets()以Enter结束输入，但可以接受空格，会舍弃最后的回车符！并且gets()可以读取多个字符，就像%c字符与getchar()对应</strong></p><p><strong>而%s字符串与gets()对称</strong></p><p><strong>需要用getchar()吃掉回车的几种情况：</strong></p><ol><li><p>前面有scanf 后面也要用scanf()时，中间要用一个空的getchar（）吃回车；</p></li><li><p>前面有scanf，后面要用ch=getchar()接收字符时，中间要用一个空的getchar（）吃回车；</p></li><li><p>2个ch=getchar()中间需要一个空的getchar()吃回车。</p></li></ol><h2 id="putchar于printf"><a href="#putchar于printf" class="headerlink" title="putchar于printf"></a>putchar于printf</h2><p>这两个函数其实区别很明显，我们简单介绍下，明天还要交作业。。。i</p><h3 id="1putchar"><a href="#1putchar" class="headerlink" title="1putchar"></a>1putchar</h3><p><strong>1 定义</strong></p><p>putchar(a)向终端输出一个字符。，其中a可以是被单引号）引起来的一个字符[putchar(‘e’)]，可以是介于0~127之间的一个十进制整型数（包含0和127）[putchar(23)] ，也可以是事先用<a href="https://baike.baidu.com/item/char/5156054" target="_blank" rel="noopener">char</a>定义好的一个字符型变量  <strong>并且只能输出单个字符，于getchar()相对应</strong></p><h3 id="2printf"><a href="#2printf" class="headerlink" title="2printf()"></a><strong>2printf()</strong></h3><p><strong>1 定义</strong></p><p>格式化输出函数, 用于向标准输出设备按规定格式输出信息， 并且可以输出各种数据类型，还可以有参数，而putchar只能输出一个字符    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如printf(&quot;%c&quot;,&apos;A&apos;) 相当于 putchar(&apos;A&apos;);</span><br></pre></td></tr></table></figure><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a><strong>区别：</strong></h3><p>其实这两个都很容易理解了，并且区别也很明显，这里我们只做下简单讨论</p><p>*<em>1.putchar会有返回值，并且返回值为()内参数值 *</em>转换为的unsigned int 值  如果遇到错误或者文件结束，putchar() 返回EOF</p><p>而printf()函数返回值为字符串的长度。</p><p><img src="https://img-blog.csdnimg.cn/20190509185615200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a=104;</span><br><span class="line">printf(%d&quot;,a);  //printf将返回3，</span><br><span class="line"></span><br><span class="line">printf(&quot;123\\n&quot;);  //printf将返回4</span><br></pre></td></tr></table></figure><h3 id="技能提升：-1"><a href="#技能提升：-1" class="headerlink" title="技能提升："></a>技能提升：</h3><p>puts()：只能输出字符串   功能是将字符串输出到屏幕。输出时只有遇到 ‘\0’ 也就是字符串结束标志符才会停止 </p><p>并且puts()在使用完之后会自动换行   等效于printf(“%s\n”,s)</p><p>puts()函数的返回值为0</p><h3 id="习题演练："><a href="#习题演练：" class="headerlink" title="习题演练："></a>习题演练：</h3><p>在学习完之后，就来几道题巩固一下吧！</p><p><img src="https://img-blog.csdnimg.cn/20190509191528597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p>（1） c1与c2字符型与整数型皆可，</p><p>原因： 我们学习知道getchar返回的是字符的ASCⅡ码，而c1，c2若为字符型。则分别对应相对于字符，若为整数型则为对应ASCⅡ码 在用</p><pre><code> printf(&quot;%c  %c\\n&quot;,c1,c2);  putchar(c1);  putchar(c2);</code></pre><p>输出的时候，字符型直接输出，而整数型的c1，c2 因为是%c和 putchar只能输出字符，会被转换为相对应ASCⅡ码值的字符输出</p><p><img src="https://img-blog.csdnimg.cn/20190509193445565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p>（2）应用printf(“%d  %d\n”,c1,c2);  并且c1与c2字符型与整数型皆可</p><p>原因：%d为输出整数型，若 c1,c2为字符型，用%d会输出相对应的ASCⅡ码值，若为整数型直接输出</p><p><img src="https://img-blog.csdnimg.cn/20190509192503241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p>（3）不可以</p><p>原因：</p><p>char的范围是ASCII码范围：有符号char   -128 ~ 127 无符号unsigned char ：0 ~ 255</p><p>int的范围是-32768 ~ 32767</p><p>并且字符型为一个字节（无符号的为两个），一个字节转两个没问题，两个转一个就可能出现溢出问题。比如 char a=255,就会溢出，因为有符号字符表达的范围只是-128~127</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-定义&quot;&gt;&lt;a href=&quot;#1-定义&quot; class=&quot;headerlink&quot; title=&quot;1.定义&quot;&gt;&lt;/a&gt;1.定义&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;花一点时间认真阅读，这篇文章应该会让您多理解一点东西。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3
      
    
    </summary>
    
      <category term="C语言" scheme="http://zxiaoxuan.cn/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C语言" scheme="http://zxiaoxuan.cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【c语言】关键字存储类型讲解(auto,extern,static,register,const</title>
    <link href="http://zxiaoxuan.cn/posts/35548/"/>
    <id>http://zxiaoxuan.cn/posts/35548/</id>
    <published>2019-09-18T06:39:13.405Z</published>
    <updated>2019-09-18T06:52:25.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="渣渣C的学习之路"><a href="#渣渣C的学习之路" class="headerlink" title="渣渣C的学习之路"></a>渣渣C的学习之路</h2><p><strong>用最简单的话，让你最快速明白！</strong></p><p>C语言中，<strong>每一个变量和函数都有2个属性：数据类型和数据的存储类别。C的存储类别有4种：自动的（auto）、静态的（static）、寄存器的（register）、外部的（extern）</strong>。变量的存储类别对应<strong>变量的作用域与生命周期</strong>。</p><h1 id="1-extern"><a href="#1-extern" class="headerlink" title="1.extern"></a>1.extern</h1><p>extern外部声明，简单来说：<strong>你如果要在a.c中使用b.c的一个变量avg，直接使用是会报错的，这时候我们便需要用</strong></p><p>*<em>extern int avg; 在a.h中声明avg，这样就可以引用avg了  *</em></p><p><strong>当然你要保证avg是一个全局变量，局部变量</strong>不能用extern的修饰，且局部变量在运行时才在堆栈部分分配内存。</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><p><strong>1.外部声明可以多次，定义只能一次</strong></p><p>简单来说就是avg<strong>只能定义一次</strong>，但是可以有很多外部声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern int a;//声明一个全局变量aint a; //定义一个全局变量aextern int a =0 ;//定义一个全局变量a 并给初值。int a =0;//定义一个全局变量a,并给初值，</span><br></pre></td></tr></table></figure><p>int a 等于 extern int a，都是定义一个可以被外部使用的全局变量，并给初值。<br>但是注意定义只能出现在一处。不管是<strong>int a;还是extern int a=0;还是int a=0;都只能出现一次</strong>，而extern int a，extern a可以出现很多次。</p><p><strong>2.用extern声明外部变量时，类型名可写可不写，如”extern int num;”也可以写成”extern num;”。因为它不是定义变量，可以不指定类型，只许写出外部变量名即可</strong></p><p><strong>3.</strong>变量如果只是用到声明，放在.h中就行了；<br>*<em>如果声明的同时并定义一个全局变量的话，在.h里用extern声明，并在对应的.c里定义。<br>其它的.c文件直接include“xx.h”就行了  *</em></p><p>// ---- Math.h —-<br>extern “C”;<br>// ---- Math.C —-<br>int “C”;</p><p>// ---- Add.c —-  </p><p>#include “Math.h”</p><p>C=5;<br>// C 可以从被调用</p><p>这样子是不是很方便！</p><h1 id="2-auto"><a href="#2-auto" class="headerlink" title="2.*auto   *"></a>2.*<em>auto   *</em></h1><p><strong>auto被解释为一个自动存储变量的关键字，也就是申明一块临时的变量内存</strong>。函数中的形参和在函数中定义的<strong>局部变量</strong>（包括符合语句中的局部变量）都属于此类。如 函数中定义变量 int a; 和 auto int a; 是等价的，关键字“auto”是默认省略的，此关键字很少使用</p><p><strong>注意事项：</strong></p><p><strong>1.auto是定义<a href="https://wenwen.sogou.com/s/?w=%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F&ch=ww.xqy.chain" target="_blank" rel="noopener">局部变量</a>，即只能在定义的范围内使用（一般就是在花括号里{}）</strong>全局变量默认说明符为extern。</p><p>2.<strong>auto变量在离开作用域是会变程序自动释放，不会发生内存溢出情况</strong>（除了包含指针的类）使用auto变量的优势是不需要考虑去变量是否被释放，比较安全。（局部变量）</p><p><strong>3.auto不能作为函数的参数</strong></p><p>4. auto不能直接用来声明数组</p><h1 id="3-static"><a href="#3-static" class="headerlink" title="3.static"></a>3.<strong>static</strong></h1><p>*<em>这个关键字很重要，我们需要对他很了解 *</em></p><p><strong>我们分为几点来介绍他</strong></p><p>1.</p><p>我们知道局部变量在调用完之后就会销毁，而我们有时希望函数中的<strong>局部变量的值在<a href="https://www.baidu.com/s?wd=%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">函数调用</a>结束后不消失而继续保留原值</strong>，即其占用的<a href="https://www.baidu.com/s?wd=%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">存储单元</a>不释放<strong>，在下一次再调用该函数时，该变量已有值（就是上<a href="https://www.baidu.com/s?wd=%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">一次函数</a>调用结束时的值）</strong>。这时就应该指定该局部变量为“静态局部变量”，用关键字static进行声明。</p><p>2<strong>.static在修饰全局变量时，该变量只能在当前文件中使用，其他文件无法访问和使用，即时用extern声明也是无效的，但是可以在多个文件中定义同一个名字的变量，不会受到影响</strong></p><blockquote><p>静态函数只能在声明它的文件中可见，其他文件不能引用该函数</p><p>不同的文件可以使用相同名字的静态函数，互不影响</p></blockquote><p><strong>static避免多个文件使用了相同的变量名而导致冲突,</strong></p><p>　比如有多个文件，分别由几个人独立开发的。假定他们在各自的文件中定义相同的“全局”变量名（仅仅指在他们独自的文件中全局），当系统集成时，由于他们使用了名字一样的“全局”变量，导致有难于遇见的问题。解决这个问题方便的做法就是在各自文件中，在相同的全局变量申明前加上static修饰符。<strong>这样系统就会为他们分配不同的内存</strong>，互不影响了。</p><p><strong>3.static修饰一个函数，则这个函数同样只能在本文件中调用，不能被其他文件调用</strong></p><p><strong>4.Static修饰的局部变量存放在全局数据区的静态变量区。初始化的时候自动初始化为0；</strong> 并且在程序执行期间不销毁，程序执行完成之后才销毁(<strong>在静态存储区，内存中所有字节默认都是0x00</strong>)</p><p>下面是中兴通讯2012校招笔试题的一道问答题：</p><p>1. <strong>static全局变量与普通的全局变量有什么区别 ?</strong></p><p>　　全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。</p><p>　　全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。</p><p>　　这两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。</p><p>　　static全局变量只初使化一次，防止在其他文件单元中被引用; 　</p><ol start="2"><li><p>** static局部变量和普通局部变量有什么区别 ？**</p><p>　　把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。 </p></li></ol><p>　　static局部变量只被初始化一次，下一次依据上一次结果值； 　</p><ol start="3"><li>** static函数与普通函数有什么区别？**</li></ol><p>　　 static函数与普通函数作用域不同,仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static修饰的函数)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件.  </p><h2 id="4-register"><a href="#4-register" class="headerlink" title="4.register"></a>4.register</h2><p>r<strong>egister变量表示将变量存储在CPU内部寄存器中，而不是单纯地寻址访问</strong>，这样可以提高运算速度和效率，</p><p>那么有的同学可能要问，为什么寄存器比寻址访问要快呢？我们首先要知道，<strong>CPU是不会直接和内存打交道的</strong>，他是会通过寄存器跟内存打交道，<strong>数据从内存里拿出来先放到寄存器，然后CPU 再从寄存器里读取数据来处理，处理完后同样把数据通过寄存器存放到内存里，</strong></p><p><strong><a href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8" target="_blank" rel="noopener">寄存器</a>是<a href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98" target="_blank" rel="noopener">内存</a>阶层中的最顶端</strong></p><p>简单来说习大大要处理政务了，那么他是会从各个国家部部长哪里获取信息吧，而不是直接问每个县的县长或者村长获取信息，那么这里CPU就是习大大，通过寄存器(各个国家部门部长)，来对内存进行寻址访问(各个地方的各种事务)，</p><p>正是有着<strong>各种各样各自功能的寄存器(很多部门)</strong>，负责着不同的工作处理，然后汇报给CPU(习大大)，这样程序才能正常进行(国家才能正常运转)，  这样我们可以知道，<strong>寄存器其实就是一块一块小的存储空间，只不过其存取速度要比内存快得多。进水楼台先得月嘛，它离CPU 很近，所以寄存器变量(国家大事)，也就是要优先处理啦。</strong></p><h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><p>1.<strong>register只是请求寄存器变量，不一定能够成功</strong>，</p><p>我们知道寄存器是有限的(各个部门)，如果定义了很多register变量，可能会超过CPU的寄存器个数，超过容量，(各个部门政务超负载了)<br><strong>这时候就没有办法都变为寄存器变量了，这个数量主要看机器性能决定</strong></p><p><strong>2.register变量必须是能被CPU所接受的类型。</strong></p><p><strong>这通常意味着register变量必须是一个单个的值，并且长度应该小于或者等于整型的长度</strong>。不过，有些机器的寄存器也能存放浮点数。  (这个我们很容易理解，不是什么事都能作为国家大事的)</p><p><strong>3.因为register变量可能不存放在内存中，所以不能用“&amp;”来获取register变量的地址。</strong></p><p><strong>4.用register修饰的变量只能是局部变量，不能是全局变量。CPU的寄存器资源有限，因此不可能让一个变量一直占着CPU寄存器</strong>  (领导人不可能一直只处理一件事情)</p><p><strong>5.register修饰符暗示编译程序相应的变量将被频繁地使用，如果可能的话，应将其保存在CPU的寄存器中，所以请注意，**</strong>.register<strong>仅仅</strong>是暗示而不是命令**。      这就好比寄存器（部长）可以说明这件事比较重要，但是不能直接命令CPU(领导人)去做一件事</p><p><strong>6.局部静态变量不能定义为寄存器变量。不能写成：register static int a, b, c</strong>;</p><p>虽然它被称作最近快的变量，但是也是比较不安全的变量，现在使用不多</p><h2 id="5-const"><a href="#5-const" class="headerlink" title="5.const"></a><strong>5.const</strong></h2><p>我对这个关键字一直抱有敬畏之心，因为之前看过一位某国企面试官对面试者提问const时的博客，就一直感觉很有文章</p><p><strong>简单来说：我们在写程序时，如果需要让一个变量保持不变，不能被修改，那就用const来修饰</strong></p><p>const 是 constant 的缩写，意思是“恒定不变的”！</p><p>以下两种定义是相同的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int a = 6;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int const a = 6;</span><br></pre></td></tr></table></figure><p>用 const 定义的变量的值是不允许改变的，即不允许给它重新赋值，即使是赋相同的值也不可以,所以在定义常量的时候要先给他<strong>初始化(赋值)  ，后面任何修改的操作都是错误的</strong></p><h3 id="const和指针"><a href="#const和指针" class="headerlink" title="const和指针"></a><strong>const和指针</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;    const int a;    int const b;    const char \*c;    char \*const d;    const char * const e;    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上面代码， a和b是相同的  </p><p>对于c来说 const在<em>左边*</em> 表示c所指向的内存地址不可改变，即c只能指向一个固定地址，但是地址中的值是可以修改的**</p><p>对于d来说，<strong>指针是只读的，也就是 d 本身的值不能被修改，但是它所指向的内存空间是可以被修改的。</strong></p><p>对于e来说<strong>，不能做任何修改，</strong></p><p>常量：固定值</p><p>变量：可以变化的量</p><p>我们知道，<strong>数组的长度不能是变量</strong>。虽然 const 定义的是<strong>只读</strong>变量，就相当于是定义一个常量。但是只读变量也是变量，所以 <strong>const 定义的变量仍然不能作为数组的长度</strong></p><p>请注意<strong>只读</strong>这两个字，可以说是精华所在</p><h3 id="能力提升："><a href="#能力提升：" class="headerlink" title="能力提升："></a><strong>能力提升：</strong></h3><p>用 const 修饰的变量，无论是全局变量还是局部变量，生存周期都是程序运行的整个过程。全局变量的生存周期为程序运行的整个过程这个是理所当然的。而使用 const 修饰过的局部变量就有了静态特性，它的生存周期也是程序运行的整个过程。我们知道全局变量是静态的，静态的生存周期就是程序运行的整个过程。但是用const修饰过的局部变量只是有了静态特性，并没有说它变成了静态变量。</p><p>我们知道，局部变量存储在栈中，静态变量存储在静态存储区中，而经过 const 修饰过的变量存储在内存中的“只读数据段”中。只读数据段中存放着常量和只读变量等不可修改的量。</p><p> 有兴趣同学可以参考  <a href="https://blog.csdn.net/as480133937/article/details/87608816" target="_blank" rel="noopener">《单片机的内存分配》</a> </p><p>来学习一下</p><p><strong>都看到这儿了，点个赞再走呗！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;渣渣C的学习之路&quot;&gt;&lt;a href=&quot;#渣渣C的学习之路&quot; class=&quot;headerlink&quot; title=&quot;渣渣C的学习之路&quot;&gt;&lt;/a&gt;渣渣C的学习之路&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;用最简单的话，让你最快速明白！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;C语言中，&lt;
      
    
    </summary>
    
      <category term="C语言" scheme="http://zxiaoxuan.cn/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C语言" scheme="http://zxiaoxuan.cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【STM32】STM32 LCD12864 串行通信模式  (从原理让你理解)</title>
    <link href="http://zxiaoxuan.cn/posts/690/"/>
    <id>http://zxiaoxuan.cn/posts/690/</id>
    <published>2019-09-18T06:34:15.963Z</published>
    <updated>2019-09-18T06:34:16.165Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lcd12864简介"><a href="#lcd12864简介" class="headerlink" title="lcd12864简介"></a>lcd12864简介</h2><p>带中文字库的128X64是一种具有4位/8位并行、2线或3线串行多种接口方式，内部含有国标一级、二级简体中文字库的点阵图形液晶显示模块；其显示分辨率为<strong>128×64</strong>，内置<strong>8192个16*16点汉字</strong>，和<strong>128个16*8点ASCII字符集</strong>。利用该模块灵活的接口方式和简单、方便的操作指令，可构成全中文人机交互图形界面。可以显示8×4行16×16点阵的汉字。也可完成图形显示。低电压低功耗是其又一显著特点。由该模块构成的液晶显示方案与同类型的图形点阵液晶显示模块相比，不论硬件电路结构或显示程序都要简洁得多，且该模块的价格也略低于相同点阵的图形液晶模块。</p><p><strong>注：</strong></p><p>我们所用的LCD屏的命名，基本都是按照其分辨率来进行命名的  比如<strong>lcd1602  就是</strong>分辨率为<strong>16×2  lcd128128 就是</strong>分辨率为<strong>128×128</strong></p><h2 id="lcd12864基本特性参数"><a href="#lcd12864基本特性参数" class="headerlink" title="lcd12864基本特性参数"></a>lcd12864基本特性参数</h2><p>（1）低电源电压（VDD：+3.0–+5.5V）</p><p>（2）显示分辨率：128×64点</p><p>（3）内置汉字字库，提供8192个16×16点阵汉字（简繁体可选）</p><p>（4）内置128个16×8点阵字符</p><p>（5）2MHZ时钟频率</p><p>（6）显示方式：STN、半透、正显</p><p>（7）驱动方式：1/32DUTY，1/5BIAS</p><p>（8）视角方向：6点</p><p>（9）背光方式：侧部高亮白色LED，功耗仅为普通LED的1/5—1/10</p><p>（10）通讯方式：<strong>串行、并口可选</strong></p><p>（11）内置DC-DC转换电路，无需外加负压</p><p>（12）无需片选信号，简化软件设计</p><p>（13）工作温度：0℃-+55℃，存储温度：-20℃-+60℃</p><h2 id="lcd12864引脚图及功能"><a href="#lcd12864引脚图及功能" class="headerlink" title="lcd12864引脚图及功能"></a><strong>lcd12864引脚图及功能</strong></h2><p><img src="https://img-blog.csdnimg.cn/20190729163212285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p>我们所用的为串口通信模式，所以仅介绍下串行所用管脚</p><p><img src="https://img-blog.csdnimg.cn/20190729164628436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p><strong>引脚：</strong></p><p><strong>1 VSS  电源负极</strong></p><p><strong>2 VDD 电源正极</strong></p><p>*<em>4 CS 片选引脚 高电位可接受数据，低电位锁存   *</em></p><p><strong>5 SID 串行数据输入端</strong></p><p>*<em>6 CLK 串行同步时钟 *</em></p><p><strong>可选引脚：</strong></p><p>3 V0 调节屏幕亮度   </p><p>15 PSB <strong>低电平有效 其中低电平为串口方式 ** 如果只用串口通信模式  **可以将PSB引脚飞线与地线相连 即固定低电平</strong></p><p>17 RESET 复位引脚 低电平可使LCD复位     </p><p>19 A LCD背光源的电源</p><p>20 K LCD背光源的地      <strong>如果需要背光   可以将19引脚与LCD2引脚电源正极相连，20引脚与LCD1引脚电源地相连</strong></p><h3 id="串行模式下传输过程"><a href="#串行模式下传输过程" class="headerlink" title="串行模式下传输过程"></a>串行模式下传输过程</h3><p><img src="https://img-blog.csdnimg.cn/20190729192300482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p><strong>1.首先CS片选一直为高电平期间,LCD可接受数据或指令,</strong></p><p><strong>2.</strong>随后，单片机要给出<strong>数据传输起始位</strong>，这里是以5个连续的<strong>“1”</strong>作数据起始位，如模块接收到连续的5个“1”，则内部传输被重置并且串行传输将被同步。</p><p><strong>3.</strong>紧接的<strong>两个位指定传输方向</strong>（<strong>RW，用于选择数据的传输方向  ，1是读数据，0是写数据）以及传输性质（RS，用于选择内部数据寄存器或指令寄存器，0是命令寄存器，1是数据寄存器）  **最后的第8位固定为“0”。   到此</strong>第一个字节 /数据传输起始位**发送完成。</p><p>4.在接收到起始位及“RW”和“RS”的第1个字节后，之后便开始传输指令或者数据，在传输过程中会进行拆分处理，<strong>该字节将被分为2个字节来传输或接收。</strong> </p><p>5.你想发送的数据或指令的高4位，被放在发送的第2个字节串行数据的高4位，其低4位则置为“0”；数据或指令的低4位被放在第3个字节的高4位，其低4位也置为“0”，如此完成一个字节指令或数据的传送。  <strong>(D7-D0)</strong></p><p>比如说你想发送的数据为“A” 对应16进制0x41   对应二进制 0100 0001‬</p><p>那么发送的顺序就是：</p><blockquote><p>1 先发送0xFA (11111 010)                <strong>五个</strong>1  <strong>RW=0 RS=1 ，</strong></p><p><strong>2</strong> 发送0100 0000                              <strong>高四位为“A”对应的高四位    低4位补0</strong></p><p><strong>3</strong>发送0001‬ 0000                               <strong>高四位为“A”对应的低四位    低4位补0</strong></p><p> <strong>到此一个字节发送完成</strong></p></blockquote><p><strong>所以写指令之前，必须先发送 11111 000 （即0xF8）<br>写数据之前      必须先发送 11111 010 （即0xFA）</strong></p><p>而如何实现字符的拆分呢？</p><p><strong>参考：</strong><a href="https://blog.csdn.net/as480133937/article/details/88361848" target="_blank" rel="noopener">《C语言运算符与操作符的用法全面汇总(非常有用)》</a></p><p> 将字符“A”的低四位清零 保留高四位   可以做“A”&amp;240( 0xf0)</p><p>**    0100 0001‬——————“A”的二进制数**</p><p>**   1111 0000‬——————240的二进制数**</p><p>**    ——————**</p><p>**   0001 0000                            保留了“A”的高四位**</p><p> 将字符“A”的低四位变为高四位 可以用&lt;&lt;(左移运算符)  A&lt;&lt;4</p><p>**    0100 0001‬——————“A”的二进制数 **</p><p>**    0001 0000 ‬——————保留了“A”的低四位**</p><p><strong>6 完成一个字节数据的发送需要24个时钟周期 因为1个字节实际是发送了3个字节 (3x8)</strong></p><p><strong>7.只有在时钟线SCLK拉低时，数据线SID上的数据才允许变化，在时钟线SCLK高电平时，SID上的数据必须保持稳定(不能变化)</strong></p><p><strong>这点与IIC是相同的</strong></p><h3 id="LCD内部资源-显示原理"><a href="#LCD内部资源-显示原理" class="headerlink" title="LCD内部资源/显示原理"></a>LCD内部资源/显示原理</h3><p>**  LCD的控制芯片为ST7920 ，ST7920有丰富的内部资源，并且内部的ROM已经固化存储了中文字库，半角英文/数字字符**</p><p><strong>也就是自带中文字库</strong></p><p><strong>ST7920的内部资源：</strong></p><p>提供8 位，4 位并行接口及串行接口可选</p><p>自动电源启动复位功能</p><p>内部自建振荡源</p><p><strong>1、</strong>ST7920 内部固化了8192 个<strong>16×16 点阵</strong>的<strong>中文字型</strong>在CGROM(<strong>2M 位中文字型ROM</strong>)里。<br><strong>2、</strong>固化有126 个<strong>16*8</strong> 点阵的<strong>半角英文/数字字符(ASCII)</strong>在HCGROM里。</p><p><strong>3、</strong>提供4个<strong>16×16</strong>点阵<strong>自造字符</strong>的存储空间CGRAM(<strong>字形产生RAM</strong>)。<br><strong>4、</strong>提供<strong>128×64</strong>的点阵绘图共<strong>1024个字节</strong>的存储空间GDRAM(<strong>点阵绘图RAM</strong>)。<br><strong>5、</strong>提供1个16×15点阵图标的存储空间IRAM（ICON RAM）</p><p>*<em>6、64×16 位字符显示RAM *</em>（DDRAM 最多16 字符×4 行)</p><p>那么在LCD上显示字符或者汉字是怎么实现的呢：</p><p><strong>LCD显示原理：</strong></p><p>作为字符显示，在控制器内有个供写入字符代码的缓存器DDRAM ，你只要将要显示的<strong>中文字符编码</strong>或<strong>其他字符编码</strong>写入DDRAM(显示数据)，也就是串行模式下发送一个字节数据，<strong>硬件将依照编码</strong>自动从CGROM(<strong>2M 中文字型ROM)    **HCGROM(</strong>16K ASCII码ROM<strong>)   CGRAM(</strong>自定义字形RAM**）三种字形中自动辨别选择对应的是那种字形的哪个字符/汉字编码，再将要显示的字符/汉字编码显示在屏幕上。</p><p>也就是<strong>字符显示是通过将字符显示编码写入字符显示RAM(DDRAM )实现的</strong></p><p>模块内部的RAM提供<strong>64×16的显示空间 ，最多可以显示4行8字(32个汉字)或64个ASCII码字符的显示       一个汉字2个字节</strong></p><p>DDRAM一共有<strong>32个字符显示区域</strong>，当然<strong>，</strong>字符显示的RAM的地址与32个字符显示区域有着一一对应的关系</p><p>字符显示时，DDRAM地址与液晶屏的位置：</p><p><img src="https://img-blog.csdnimg.cn/2019073010075246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p>通过写入不同的地址，就可以实现字符显示的不同位置</p><h3 id="LCD控制指令"><a href="#LCD控制指令" class="headerlink" title="LCD控制指令"></a>LCD控制指令</h3><p><strong>LCD12864提供了两套控制命令，分别为基本指令和扩展指令    ，涉及到了LCD的清屏，开关，显示字符位置等等</strong></p><p><strong>其实也就是向LCD写入特殊字符而已    ，根据RS和RW可以判断指令方式</strong></p><p><img src="https://img-blog.csdnimg.cn/20190729212410490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hpcGhvdG9zLmJhaWR1LmNvbS90eHowMS9waWMvaXRlbS82MWVlMmMzZWUwODI4YzE4NzFjZjZjY2UuanBnP189MzI2NDIxMg" alt></p><p>下面我们介绍几个常用的：</p><p>*<em>1清屏 *</em></p><p><img src="https://img-blog.csdnimg.cn/2019072921344158.png" alt></p><p>  清除屏幕字符  ，也就是对整块屏幕写入空字符 并且将游标移到开始位置   <strong>在使用清屏时，需要加上一定的延时等待液晶稳定</strong></p><p>RS  RW</p><p>D7 D6 D5 D4 D3 D2 D1 D0</p><p>0  0</p><p>0000 0001</p><p><strong>2显示状态开关</strong></p><p><img src="https://img-blog.csdnimg.cn/20190729222521114.png" alt></p><p>其中第6位置1打开显示，第7位与第8位对应游标相关设置  <strong>一般配置为 0X0C</strong> //显示器开，光标关闭，不反白</p><p>RS  RW</p><p>D7 D6 D5 D4 D3 D2 D1 D0</p><p>0  0</p><p>0 0 0 0 1 1/0 1/0 1/0</p><p><strong>3功能设定</strong></p><p><img src="https://img-blog.csdnimg.cn/20190729223405516.png" alt></p><p>DL = 0/1 : 4/8位数据    我们是使用8位 所以为1     RE=1时，使用扩充指令集，RE=0时，使用基本指令集，我们正常使用基本指令集  所以RE需要为0         <strong>一般配置为 0X30 //  基本指令集 8bit数据流</strong></p><p>RS  RW</p><p>D7 D6 D5 D4 D3 D2 D1 D0</p><p>0  0</p><p>0 0 1 1/0 任意 1/0 任意 任意</p><p><strong>4游标功能设置</strong></p><p><img src="https://img-blog.csdnimg.cn/20190730102827983.png" alt></p><p><strong>进入点设定   ：   是表示在写入或者读取的时候，游标相对于上一个位置的移位  不设置即默认对地址加1(移1位)  如果你想要字符之间有空隙  可以修改移位</strong></p><p>游标的位置移动设置，写入相对应的数据即可改变游标位置，实现LCD界面的书写， <strong>32个字符显示区域对应32个地址</strong></p><p><strong>5读取BF忙标志和地址</strong></p><p><img src="https://img-blog.csdnimg.cn/20190730103632224.png" alt></p><p><strong>忙标志BF:</strong></p><p>BF标志提供内部工作状况，BF=1表示模块内部正在进行操作，此时模块不接受指令和数据. BF=0 模块为准备接受状态，可以接受指令和数据</p><p><strong>6读/写数据</strong></p><p><img src="https://img-blog.csdnimg.cn/20190730104508355.png" alt></p><p>就是进行数据的读写，</p><p><strong>写数据：</strong></p><p>RS  RW</p><p>D7 D6 D5 D4 D3 D2 D1 D0</p><p>1  0</p><p>8bit数据</p><p><strong>读数据：</strong></p><p>RS  RW</p><p>D7 D6 D5 D4 D3 D2 D1 D0</p><p>1  1</p><p>8bit数据</p><p><strong>7</strong> <strong>CGRAM(自定义字形RAM)设置</strong></p><h3 id><a href="#" class="headerlink" title></a><img src="https://img-blog.csdnimg.cn/20190730170204378.png" alt></h3><p>设定该地址即可自定义字形编码，在显示图片时会先将图片编码写入这里，然后再读它进行显示</p><h3 id="LCD初始化"><a href="#LCD初始化" class="headerlink" title="LCD初始化"></a>LCD初始化</h3><p><img src="https://img-blog.csdnimg.cn/20190730105325108.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p>我们把它分为6步分别讲解</p><ul><li><p>1.在开电之后，首先要等待40ms以上，等待液晶自检，使LCD系统复位完成</p></li><li><p>2. 之后便是功能的设定  选择基本指令集或者扩充指令集  随后延时等待100us以上</p></li><li><p>3. 功能设定2   选择8bit数据流 或者 4bit数据流  随后延时37us以上</p></li><li><p>4. 开关显示  是否打开显示开关          随后延时100us以上</p></li><li><p>5.清屏  清空RAM并初始化光标位置    随后延时10us以上</p></li><li><ol start="6"><li>进入模式选择  也就是设定*<em>游标相对于上一个位置的移位 默认为地址自动+1  *</em></li></ol></li></ul><p>之后初始化完成，可以对LCD进行数据的写入或读取</p><p><strong>当然第二步与第三布写入数据是相同的，可以只写一次然后延时137us以上也可</strong></p><h3 id="LCD图片显示"><a href="#LCD图片显示" class="headerlink" title="LCD图片显示"></a>LCD图片显示</h3><p><img src="https://img-blog.csdnimg.cn/20190730165619175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p>LCD12864在地址的排列上是分为上、下半屏来显示的，上半屏横向的列地址（X）是0－7(00h-07h)，下半屏的列地址是8－15(08h-0fh)。而<strong>每个一地址都可写入两个字节的内容</strong>，它们是按高位在前低位在后排列的。垂直方向上的地址（Y）上半屏是0－31(00h-1fh)，下半屏的Y地址仍是0－31(00h-1fh)   </p><p>   也就是一幅图片写入时垂直坐标Y要写64次 (上下屏)   水平横向坐标X要写8次</p><p>在每两个字节写入后时候就要重新<strong>设置垂直地址，再设置水平地址(连续写入两个字节确定X,Y地址)</strong>  然后再写图片的正常编码  这样便可以实现一幅图像的写入     简单说就是对<strong>每个位置写入图片的相对于位置的编码</strong></p><p><strong>图片显示的步骤</strong></p><p><strong>1切换到扩充指令<br>2 关闭绘图显示功能</strong></p><p><strong>3 先将垂直的坐标(Y)写入CGRAM地址<br>4 再将水平的位元组坐标(X)写入CGRAM地址<br>5 将高位字节**</strong>D15－D8写入RAM中<br>6 将低位字节D7－D0写入到RAM中**</p><p><strong>重复3-6步，完成图片各个部分的写入  先写上半屏，再写下半屏</strong></p><p><strong>7 打开绘图显示功能                                                                                                                                                                          8切换回基本指令</strong></p><p>其实也就是先打开CGRAM(<strong>自定义字形RAM</strong>） 然后把定义好的图片编码写入CGRAM  然后再对DDRAM正常写入该图片编码， <strong>这时硬件将依照编码从CGRAM(自定义字形RAM）读取之前写入的图片编码</strong>，然后显示该图片</p><p>具体看代码即可</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><p>用带中文字库的128X64显示模块时应注意以下几点：</p><p> PS： <strong>图片显示之后需要加上延时，否则会持续写入，不会有图片显示</strong></p><p>**     图片写入CGRAM(自定义字形RAM)时必须要先写垂直地址坐标，再写水平地址坐标**</p><p>①欲在某一个位置显示中文字符时，<strong>应先设定显示字符位置</strong>，即先设定显示地址，再写入中文字符编码。</p><p>②显示ASCII字符过程与显示中文字符过程相同。不过在显示连续字符时，只须设定一次显示地址，由<strong>模块自动对地址加1</strong>指向下一个字符位置，否则，显示的字符中将会有一个空ASCII字符位置。</p><p>③当字符编码为2字节时，应先写入高位字节，再写入低位字节。</p><p>④模块在接收指令前，向处理器必须先确认模块内部处于非忙状态，即读取BF标志时BF需为“0”，方可接受新的指令。如果在送出一个指令前不检查BF标志，则在前一个指令和这个指令中间必须延迟一段较长的时间，即等待前一个指令确定执行完成。指令执行的时间请参考指令表中的指令执行时间说明。</p><p>⑤“RE”为基本指令集与扩充指令集的选择控制位。当变更“RE”后，以后的指令集将维持在最后的状态，除非再次变更“RE”位，否则使用相同指令集时，无需每次均重设“RE”位。</p><p>到此，LCD的串行通信就讲的差不多了，<strong>可以结合着代码篇博客，学习完对应相关原理，然后查看相对应代码，可以更好地理解</strong></p><p>如果需要查看代码请移步到下一篇博客：<a href="https://blog.csdn.net/as480133937/article/details/97765912" target="_blank" rel="noopener">《STM32驱动 LCD12864程序代码(串行方式)》</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;lcd12864简介&quot;&gt;&lt;a href=&quot;#lcd12864简介&quot; class=&quot;headerlink&quot; title=&quot;lcd12864简介&quot;&gt;&lt;/a&gt;lcd12864简介&lt;/h2&gt;&lt;p&gt;带中文字库的128X64是一种具有4位/8位并行、2线或3线串行多种接口方式
      
    
    </summary>
    
      <category term="STM32" scheme="http://zxiaoxuan.cn/categories/STM32/"/>
    
    
      <category term="STM32" scheme="http://zxiaoxuan.cn/tags/STM32/"/>
    
  </entry>
  
  <entry>
    <title>【STM32】STM32驱动 LCD12864程序代码(串行方式)</title>
    <link href="http://zxiaoxuan.cn/posts/34132/"/>
    <id>http://zxiaoxuan.cn/posts/34132/</id>
    <published>2019-09-18T06:32:46.963Z</published>
    <updated>2019-09-18T06:32:47.203Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h3><p>这里我们只讲解接线和代码实现，具体的原理在上一篇博客中已经讲解，如果想了解具体原理可以查看上一篇博客</p><p><a href="https://blog.csdn.net/as480133937/article/details/97650805" target="_blank" rel="noopener">《STM32 LCD12864 串行通信模式 (从原理让你理解)》</a></p><p>下方代码的实现也是基于上一篇的讲解顺序来的     </p><p><strong>设备： STM32F407ZGT6</strong></p><h3 id="引脚接线："><a href="#引脚接线：" class="headerlink" title="引脚接线："></a>引脚接线：</h3><ol><li><p>VSS——GND</p></li><li><p>VDD——VCC(5V or 3.3V)</p></li><li><p>V0 亮度调节  不接</p></li><li><p>CS ——接VCC，持续高电平，一直选通。</p></li><li><p>SID ——接PE1</p></li><li><p>SCLK  ——接PE0</p></li><li><p>PSB——接GND  串行模式  或者飞线与1脚相连</p></li><li><p>BLA——VCC(5V or 3.3V)   或者飞线与2脚相连</p></li><li><p>BLK——接GND                 或者飞线与1脚相连</p></li><li><p>剩余引脚不接，留空</p></li></ol><p>这样我们最少只会用到4根线  <strong>VCC电源 GND地线  SID串行输入  SCLK  时钟</strong>  便可以实现串行通信</p><h1 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h1><h3 id="LCD写入一个字节："><a href="#LCD写入一个字节：" class="headerlink" title="LCD写入一个字节："></a>LCD写入一个字节：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#define WRITE\_CMD0xF8//写命令  #define WRITE\_DAT0xFA//写数据/*! </span><br><span class="line">*  @brief      LCD串行发送一个字节</span><br><span class="line"> *  @since      v1.0</span><br><span class="line"> *  @param  byte   写入字节</span><br><span class="line"> *  @author     Z小旋</span><br><span class="line"> */void SendByte(u8 byte)&#123;</span><br><span class="line">     u8 i; </span><br><span class="line">  for(i = 0;i &lt; 8;i++)</span><br><span class="line">    &#123;        if((byte &lt;&lt; i) &amp; 0x80)  //0x80(1000 0000)  只会保留最高位</span><br><span class="line">&#123;</span><br><span class="line">    SID = 1;           // 引脚输出高电平，代表发送1</span><br><span class="line">&#125;else</span><br><span class="line">&#123;</span><br><span class="line">SID = 0;         // 引脚输出低电平，代表发送0</span><br><span class="line">&#125;/*或</span><br><span class="line">SID =(Dbyte &lt;&lt; i) &amp; 0x80;</span><br><span class="line"></span><br><span class="line">上面那样为了方便理解</span><br><span class="line">*/</span><br><span class="line">SCLK = 0;   //时钟线置低  允许SID变化</span><br><span class="line">delay_us(5); //延时使数据写入</span><br><span class="line">SCLK = 1;    //拉高时钟，让从机读SID</span><br><span class="line">&#125;   </span><br><span class="line">&#125;/*! </span><br><span class="line"> *  @brief      LCD写指令</span><br><span class="line"> *  @since      v1.0</span><br><span class="line"> *  @param  Cmd   要写入的指令</span><br><span class="line"> *  @author     Z小旋</span><br><span class="line"> */void Lcd_WriteCmd(u8 Cmd )&#123;</span><br><span class="line">     delay_ms(1);    //由于我们没有写LCD正忙的检测，所以直接延时1ms，使每次写入数据或指令间隔大于1ms 便可不用写忙状态检测</span><br><span class="line">     SendByte(WRITE_CMD);            //11111,RW(0),RS(0),0   </span><br><span class="line">     SendByte(0xf0&amp;Cmd);      //高四位</span><br><span class="line">     SendByte(Cmd&lt;&lt;4);   //低四位(先执行&lt;&lt;)&#125;/*! </span><br><span class="line"> *  @brief      LCD写数据</span><br><span class="line"> *  @since      v1.0</span><br><span class="line"> *  @param  Dat   要写入的数据</span><br><span class="line"> *  @author     Z小旋</span><br><span class="line"> */void Lcd_WriteData(u8 Dat )&#123;</span><br><span class="line">     delay_ms(1);     //由于我们没有写LCD正忙的检测，所以直接延时1ms，使每次写入数据或指令间隔大于1ms 便可不用写忙状态检测</span><br><span class="line">     SendByte(WRITE_DAT);            //11111,RW(0),RS(1),0</span><br><span class="line">     SendByte(0xf0&amp;Dat);      //高四位</span><br><span class="line">     SendByte(Dat&lt;&lt;4);   //低四位(先执行&lt;&lt;)&#125;</span><br></pre></td></tr></table></figure><p>向LCD发送一个字节，也就是SID引脚相对于高低电平 高电平=1 低电平=0  同时时钟线变化，使得数据可以读取和发送</p><p>结合第一篇原理介绍即可理解。</p><p>关于&amp;运算与&lt;&lt;  参看  <a href="https://blog.csdn.net/as480133937/article/details/88361848" target="_blank" rel="noopener">《C语言运算符与操作符的用法全面汇总(非常有用)》</a></p><h3 id="LCD初始化："><a href="#LCD初始化：" class="headerlink" title="LCD初始化："></a>LCD初始化：</h3><p>这里为了方便移植，将GPIO的初始化与LCD初始化分为两个，使用时根据自己的引脚只修改GPIO初始化即可</p><p><strong>宏定义和GPIO初始化：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#define WRITE\_CMD0xF8//写命令  #define WRITE\_DAT0xFA//写数据//接口(SID: PE1  SCLK: PE0) #define SID PEout(1)#define SCLK PEout(0)/*! </span><br><span class="line">*  @brief      GPIO_init</span><br><span class="line"> *  @since      v1.0</span><br><span class="line"> *  @param  None</span><br><span class="line"> *  @author     Z小旋</span><br><span class="line"> *  使用时自行修改这里的初始化即可</span><br><span class="line"> */void lcd\_GPIO\_init()&#123;</span><br><span class="line">       </span><br><span class="line">  GPIO\_InitTypeDef  GPIO\_InitStructure;</span><br><span class="line"></span><br><span class="line">  RCC\_AHB1PeriphClockCmd(RCC\_AHB1Periph_GPIOE, ENABLE);//使能GPIOE时钟</span><br><span class="line"></span><br><span class="line">  //GPIOE0,E1初始化设置</span><br><span class="line">  GPIO\_InitStructure.GPIO\_Pin = GPIO\_Pin\_0 | GPIO\_Pin\_1;</span><br><span class="line">  GPIO\_InitStructure.GPIO\_Mode = GPIO\_Mode\_OUT;//普通输出模式</span><br><span class="line">  GPIO\_InitStructure.GPIO\_OType = GPIO\_OType\_PP;//推挽输出</span><br><span class="line">  GPIO\_InitStructure.GPIO\_Speed = GPIO\_Speed\_100MHz;//100MHz</span><br><span class="line">  GPIO\_InitStructure.GPIO\_PuPd =  GPIO\_PuPd\_NOPULL;//无上拉</span><br><span class="line">  GPIO\_Init(GPIOE, &amp;GPIO\_InitStructure);//初始化</span><br><span class="line">  SID=1;</span><br><span class="line">  SCLK=1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据不同的型号和管脚修改对应初始化即可</p><p><strong>LCD初始化：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*! </span><br><span class="line"> *  @brief      LCD初始化</span><br><span class="line"> *  @since      v1.0</span><br><span class="line"> *  @param  None</span><br><span class="line"> *  @author     Z小旋</span><br><span class="line"> */void Lcd_Init(void)&#123; </span><br><span class="line">    delay_ms(50);   //等待液晶自检（延时&gt;40ms）</span><br><span class="line">Lcd_WriteCmd(0x30);        //功能设定:选择基本指令集  ，选择8bit数据流</span><br><span class="line">    delay_ms(1);//延时&gt;137us </span><br><span class="line">    Lcd_WriteCmd(0x0c);        //开显示</span><br><span class="line">    delay_ms(1);//延时&gt;100us</span><br><span class="line">    Lcd_WriteCmd(0x01);        //清除显示，并且设定地址指针为00H</span><br><span class="line">    delay_ms(30);//延时&gt;10ms</span><br><span class="line">Lcd_WriteCmd(0x06);        //每次地址自动+1，初始化完成&#125;</span><br></pre></td></tr></table></figure><h3 id="LCD写入字符或汉字："><a href="#LCD写入字符或汉字：" class="headerlink" title="LCD写入字符或汉字："></a>LCD写入字符或汉字：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/* 字符显示RAM地址    4行8列 */uint8\_t LCD\_addr\[4\]\[8\]=&#123;</span><br><span class="line">&#123;0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87&#125;,  //第一行</span><br><span class="line">&#123;0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97&#125;,//第二行</span><br><span class="line">&#123;0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F&#125;,//第三行</span><br><span class="line">&#123;0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F&#125;//第四行</span><br><span class="line">&#125;;/*! </span><br><span class="line"> *  @brief      显示字符或汉字</span><br><span class="line"> *  @since      v1.0</span><br><span class="line"> *  @param  x: row(0~3)</span><br><span class="line"> *  @param  y: line(0~7) </span><br><span class="line"> *  @param str: 要显示的字符或汉字</span><br><span class="line"> *  @author     Z小旋</span><br><span class="line"> */void LCD\_Display\_Words(uint8\_t x,uint8\_t y,uint8_t*str)&#123; </span><br><span class="line">Lcd\_WriteCmd(LCD\_addr\[x\]\[y\]); //写初始光标位置</span><br><span class="line">while(*str&gt;0)</span><br><span class="line">    &#123; </span><br><span class="line">      Lcd_WriteData(*str);    //写数据</span><br><span class="line">      str++;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先写入DDRAM对应初始游标位置，然后在该位置写入字符串 写一个字节之后，DDRAM对应游标地址就自动+1到下一个游标位置继续写，直到字符串空为止</p><h3 id="LCD清屏："><a href="#LCD清屏：" class="headerlink" title="LCD清屏："></a>LCD清屏：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*! </span><br><span class="line"> *  @brief      清屏函数</span><br><span class="line"> *  @since      v1.0</span><br><span class="line"> *  @param  None</span><br><span class="line"> *  @author     Z小旋</span><br><span class="line"> */void LCD_Clear(void)</span><br><span class="line">&#123;</span><br><span class="line">Lcd_WriteCmd(0x01);//清屏指令</span><br><span class="line">delay_ms(2);//延时以待液晶稳定【至少1.6ms】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LCD显示图片："><a href="#LCD显示图片：" class="headerlink" title="LCD显示图片："></a>LCD显示图片：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/*! </span><br><span class="line"> *  @brief      显示图片</span><br><span class="line"> *  @since      v1.0</span><br><span class="line"> *  @param  *pic   图片地址</span><br><span class="line"> *  @author   </span><br><span class="line"> */void LCD\_Display\_Picture(uint8_t *img)</span><br><span class="line">&#123;uint8_t x,y,i;</span><br><span class="line">Lcd_WriteCmd(0x34);//切换到扩充指令</span><br><span class="line">Lcd_WriteCmd(0x34);//关闭图形显示</span><br><span class="line">for(i = 0; i &lt; 1; i++)   //上下屏写入</span><br><span class="line">&#123;for(y=0;y&lt;32;y++)   //垂直Y写32次</span><br><span class="line">&#123;  </span><br><span class="line">for(x=0;x&lt;8;x++)   //横向X写8次</span><br><span class="line">&#123;</span><br><span class="line">Lcd_WriteCmd(0x80 + y);//行地址</span><br><span class="line">Lcd_WriteCmd(0x80 + x+i);//列地址</span><br><span class="line">Lcd_WriteData(*img ++);//写高位字节数据 D15－D8   </span><br><span class="line">Lcd_WriteData(*img ++);//写低位字节数据 D7－D0</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Lcd_WriteCmd(0x36);//打开图形显示</span><br><span class="line">Lcd_WriteCmd(0x30);        //切换回基本指令</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体原理可以结合 LCD图片显示 部分查看</p><p>这里要注意  在显示一幅图片之后，要加上2s左右延时，<strong>否则不会有图片显示</strong></p><p><strong>这里再把显示步骤放在下面，方便理解</strong></p><p><strong>图片显示的步骤</strong></p><p><strong>1切换到扩充指令<br>2 关闭绘图显示功能</strong></p><p><strong>3 先将垂直的坐标(Y)写入CGRAM地址<br>4 再将水平的位元组坐标(X)写入CGRAM地址<br>5 将高位字节D15－D8写入RAM中<br>6 将低位字节D7－D0写入到RAM中</strong></p><p><strong>重复3-6步，完成图片各个部分的写入  先写上半屏，再写下半屏</strong></p><p><strong>7 打开绘图显示功能                                                                                                                                                                          8切换回基本指令</strong></p><p>使用图片取模软件时要注意 <strong>图片取模方式：横向取模，字节正序</strong></p><p>到此基本的功能都已经实现了，我把完整的工程代码放到下面，有需要的可以自行下载查看</p><p>弄到百度云了，CSDN下载还要钱。。。</p><p>链接: <a href="https://pan.baidu.com/s/1_OabL-e2mgZebKjjFnW1Ow" target="_blank" rel="noopener">https://pan.baidu.com/s/1_OabL-e2mgZebKjjFnW1Ow</a> 提取码: tfxw </p><p>github：    <a href="https://github.com/ZXiaoxuan/STM32-LCD12864/tree/ZXiaoxuan" target="_blank" rel="noopener">https://github.com/ZXiaoxuan/STM32-LCD12864/tree/ZXiaoxuan</a></p><p>至此，LCD12864完毕，</p><p><img src="https://img-blog.csdnimg.cn/20190726200706356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><p>PS: <strong>代码没有任何问题</strong>，直接修改GPIO初始化部分即可，如果亮不了，先自行检查，还有查看评论区，看下自己是否有相同问题(供电，接线，F1与F4GPIO初始化不同…等等)，不行就在评论区留言,我看到都会回复帮您解决</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;引言：&quot;&gt;&lt;a href=&quot;#引言：&quot; class=&quot;headerlink&quot; title=&quot;引言：&quot;&gt;&lt;/a&gt;引言：&lt;/h3&gt;&lt;p&gt;这里我们只讲解接线和代码实现，具体的原理在上一篇博客中已经讲解，如果想了解具体原理可以查看上一篇博客&lt;/p&gt;
&lt;p&gt;&lt;a href=
      
    
    </summary>
    
      <category term="STM32" scheme="http://zxiaoxuan.cn/categories/STM32/"/>
    
    
      <category term="STM32" scheme="http://zxiaoxuan.cn/tags/STM32/"/>
    
  </entry>
  
  <entry>
    <title>图像处理二之----摄像头二值化算法汇总+代码</title>
    <link href="http://zxiaoxuan.cn/posts/28885/"/>
    <id>http://zxiaoxuan.cn/posts/28885/</id>
    <published>2019-09-18T06:29:30.988Z</published>
    <updated>2019-09-18T07:25:38.754Z</updated>
    
    <content type="html"><![CDATA[<h3 id="上一节中我们讲解了什么是二值化，并且讲到了二值化的一般方法，那么每种算法究竟是怎么样对图像经行二值化处理的呢？，算法的原理是什么呢，怎么样用代码实现，这节我们分享下。"><a href="#上一节中我们讲解了什么是二值化，并且讲到了二值化的一般方法，那么每种算法究竟是怎么样对图像经行二值化处理的呢？，算法的原理是什么呢，怎么样用代码实现，这节我们分享下。" class="headerlink" title="上一节中我们讲解了什么是二值化，并且讲到了二值化的一般方法，那么每种算法究竟是怎么样对图像经行二值化处理的呢？，算法的原理是什么呢，怎么样用代码实现，这节我们分享下。"></a>上一节中我们讲解了什么是二值化，并且讲到了二值化的一般方法，那么每种算法究竟是怎么样对图像经行二值化处理的呢？，算法的原理是什么呢，怎么样用代码实现，这节我们分享下。</h3><h2 id="1-otsu（最大类间方差法、大津法）"><a href="#1-otsu（最大类间方差法、大津法）" class="headerlink" title="1.otsu（最大类间方差法、大津法）"></a>1.otsu（最大类间方差法、大津法）</h2><p>  最大类间方差法是由日本学者大津于1979年提出的,是一种自适应的阈值确定的方法,又叫<strong>大津法,简称OTSU</strong>。它是按图像的灰度特性,将图像分成背景和目标2部分。背景和目标之间的类间方差越大,说明构成图像的2部分的差别越大,当部分目标错分为背景或部分背景错分为目标都会导致2部分差别变小。因此,<strong>使类间方差最大的分割意味着错分概率最小</strong>。</p><p>  阈值将原图象分成前景，背景两个图象。</p><p>  <strong>当取最佳阈值时，背景应该与前景差别最大，关键在于如何选择衡量差别的标准</strong></p><p>而在otsu算法中这个衡量差别的标准就是最大类间方差（英文简称otsu，这也就是这个算法名字的来源）</p><p>对于图像I(x,y),前景(即目标)和背景的分割阈值记作<strong>T</strong>,前景图像占整幅图像的比例记为<strong>ω0</strong>,其平均灰度<strong>μ0</strong>;背景图像占整幅图像的比例为<strong>ω1</strong>,其平均灰度为<strong>μ1</strong>。图像的总平均灰度记为<strong>μ</strong>,类间方差记为<strong>g</strong>。M×N = 像素总数,图像中像素的灰度值小于阈值T的像素个数记作N0,像素灰度大于阈值T的像素个数记作N1</p><p>,则有:<br>　　前景图像占比　　　　ω0=N0/ M×N                                                         (1)<br>　　背景图像占比　　　　ω1=N1/ M×N                                                         (2)<br>　　前景像素+背景像素　　　                        N0+N1=M×N                            (3)<br>　　背景图像+前景图像占比　　　                     　ω0+ω1=1                       （4)<br>　　0~M灰度区间的灰度累计值　　<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wcml2YXRlLmNvZGVjb2dzLmNvbS9naWYubGF0ZXg_JTVDbXUlMjAlM0QlMjAlNUNtdTEqJTVDb21lZ2ElMjAxJTIwJnBsdXM7JTIwJTVDbXUyKiU1Q29tZWdhJTIwMg?x-oss-process=image/format,png" alt="\mu = \mu1*\omega 1 + \mu2*\omega 2">                          (5)</p><p>　   类间方差值　　　<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wcml2YXRlLmNvZGVjb2dzLmNvbS9naWYubGF0ZXg_ZyUyMCUzRCUyMCU1Q29tZWdhJTIwMSUyMColMjAlMjglNUNtdSUyMC0lMjAlNUNtdTElMjklNUUlN0IyJTdEJTIwJnBsdXM7JTIwJTVDb21lZ2ElMjAyJTIwKiUyMCUyOCU1Q211JTIwLSUyMCU1Q211MiUyOSU1RSU3QjIlN0Q?x-oss-process=image/format,png" alt="g = \omega 1 * (\mu - \mu1)^{2} + \omega 2 * (\mu - \mu2)^{2}">                                      (6)  </p><p>将式(5)代入式(6),得到等价公式:<br>          <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wcml2YXRlLmNvZGVjb2dzLmNvbS9naWYubGF0ZXg_ZyUyMCUzRCUyMCU1Q29tZWdhJTIwMSUyMColMjAlNUNvbWVnYTIlMjAqJTIwJTI4JTVDbXUxJTIwLSUyMCU1Q211MiUyOSU1RSU3QjIlN0Q?x-oss-process=image/format,png" alt="g = \omega 1 * \omega2 * (\mu1 - \mu2)^{2}">                                                                     (7)</p><p>或</p><p><img src="https://img-blog.csdnimg.cn/20190402160621543.png" alt></p><p>采用遍历的方法得到使类间方差最大的阈值T,即为所求。</p><h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><h3 id="c代码"><a href="#c代码" class="headerlink" title="c代码"></a>c代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">w0为背景像素点占整幅图像的比例</span><br><span class="line"></span><br><span class="line">u0为w0平均灰度</span><br><span class="line"></span><br><span class="line">w1为前景像素点占整幅图像的比例</span><br><span class="line"></span><br><span class="line">u1为w1平均灰度</span><br><span class="line"></span><br><span class="line">u为整幅图像的平均灰度</span><br><span class="line"></span><br><span class="line">类间方差公式 g = w1 * w2 * (u1 - u2) ^ 2int otsuThreshold(int *image, int col, int row)</span><br><span class="line">&#123;</span><br><span class="line">    #define GrayScale 256</span><br><span class="line">    int width = col;    int height = row;    int pixelCount\[GrayScale\] = &#123;0&#125;; //每个灰度值所占像素个数</span><br><span class="line">    float pixelPro\[GrayScale\] = &#123;0&#125;;//每个灰度值所占总像素比例</span><br><span class="line">    int i, j, pixelSum = width * height;   //总像素</span><br><span class="line">    int threshold = 0;    int* data = image;  //指向像素数据的指针</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //统计灰度级中每个像素在整幅图像中的个数  </span><br><span class="line">    for (i = 0; i &lt; height; i++)</span><br><span class="line">    &#123;        for (j = 0; j &lt; width; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            pixelCount\[(int)data\[i * width + j\]\]++;  //将像素值作为计数数组的下标</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    //遍历灰度级\[0,255\]  </span><br><span class="line">    float w0, w1, u0tmp, u1tmp, u0, u1, u, deltaTmp, deltaMax = 0;    for (i = 0; i &lt; GrayScale; i++)     // i作为阈值</span><br><span class="line">    &#123;</span><br><span class="line">        w0 = w1 = u0tmp = u1tmp = u0 = u1 = u = deltaTmp = 0;        for (j = 0; j &lt; GrayScale; j++)</span><br><span class="line">        &#123;            if (j &lt;= i)   //背景部分  </span><br><span class="line">            &#123;</span><br><span class="line">                pixelPro\[i\] = (float)pixelCount\[i\] / pixelSum;   //计算每个像素在整幅图像中的比例  </span><br><span class="line">                w0 += pixelPro\[j\];//背景像素点占整个图像的比例</span><br><span class="line">                u0tmp += j * pixelPro\[j\];</span><br><span class="line">            &#125;            else   //前景部分  </span><br><span class="line">            &#123;</span><br><span class="line">                pixelPro\[i\] = (float)pixelCount\[i\] / pixelSum;   //计算每个像素在整幅图像中的比例  </span><br><span class="line">                w1 += pixelPro\[j\];//前景像素点占整个图像的比例</span><br><span class="line">                u1tmp += j * pixelPro\[j\];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        u0 = u0tmp / w0;//背景平均灰度μ0</span><br><span class="line">        u1 = u1tmp / w1;//前景平均灰度μ1</span><br><span class="line">        deltaTmp = (float)(w0 \*w1\* pow((u0 - u1), 2)); //类间方差公式 g = w1 * w2 * (u1 - u2) ^ 2</span><br><span class="line">        if (deltaTmp &gt; deltaMax)</span><br><span class="line">        &#123;</span><br><span class="line">            deltaMax = deltaTmp;</span><br><span class="line">            threshold = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    return threshold;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MATALB代码："><a href="#MATALB代码：" class="headerlink" title="MATALB代码："></a>MATALB代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">close all;</span><br><span class="line">clear all;</span><br><span class="line">clc;</span><br><span class="line"></span><br><span class="line">input = imread(&apos;R.png&apos;);%读图</span><br><span class="line">input = rgb2gray(input);%灰度转换</span><br><span class="line"></span><br><span class="line">L = 256;%给定灰度级</span><br><span class="line">\[ni, li\] = imhist(input,L);  %ni-各灰度等级出现的次数；li-对应的各灰度等级</span><br><span class="line">% figure,plot(xi,ni);%显示绝对直方图统计</span><br><span class="line">% title(&apos;绝对直方图统计&apos;)</span><br><span class="line"></span><br><span class="line">\[M,N\] = size(input);%获取图像大小</span><br><span class="line">MN = M*N;%像素点总数</span><br><span class="line"></span><br><span class="line">%%Step1 计算归一化直方图</span><br><span class="line"></span><br><span class="line">pi = ni/MN;  %pi-统计各灰度级出现的概率</span><br><span class="line">figure,plot(li,pi);%显示相对直方图统计</span><br><span class="line">title(&apos;相对直方图统计&apos;)</span><br><span class="line"></span><br><span class="line">%%Step2  计算像素被分到C1中的概率P1(k)</span><br><span class="line"></span><br><span class="line">sum = 0;%用来存储各灰度级概率和</span><br><span class="line">P1 = zeros(L,1);%用来存储累积概率和for k = 1:L</span><br><span class="line">    sum = sum +pi(k,1);</span><br><span class="line">    P1(k,1) = sum;%累加概率</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">%%Step3  计算像素至K级的累积均值m(k)</span><br><span class="line"></span><br><span class="line">sum1 = 0;%用来存储灰度均值</span><br><span class="line">m = zeros(L,1);%用来存储累计均值for k = 1:L</span><br><span class="line">    sum1 = sum1+k*pi(k,1);</span><br><span class="line">    m(k,1) = sum1;%累积均值</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">%%Step4  计算全局灰度均值mg</span><br><span class="line"></span><br><span class="line">mg = sum1;</span><br><span class="line"></span><br><span class="line">%%Step5 计算类间方差sigmaB2 </span><br><span class="line">sigmaB2 = zeros(L,1);for k = 1:L    if(P1(k,1) == 0)</span><br><span class="line">        sigmaB2(k,1) = 0;  %为了防止出现NaN    else</span><br><span class="line">        sigmaB2(k,1) = ((mg\*P1(k,1)-m(k,1))^2)/(P1(k,1)\*(1-P1(k,1)));</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">%%Step6 得到最大类间方差以及阈值</span><br><span class="line"></span><br><span class="line">\[MsigmaB2,T\] = max(sigmaB2);%获取最大类间方差MsigmaB2，以及所在位置（即阈值）</span><br><span class="line">output = zeros(M,N);%定义二值化输出图像for i = 1:M    for j = 1:N        if input(i,j)&gt;T</span><br><span class="line">            output(i,j) = 1;        else</span><br><span class="line">            output(i,j)=0;</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">figure,imshow(output);%显示结果</span><br><span class="line"></span><br><span class="line">%%Step7 可分性度量eta</span><br><span class="line"></span><br><span class="line">sigmaG2 = 0;%全局方差for k = 1:L</span><br><span class="line">    sigmaG2 = sigmaG2+(k-mg)^2*pi(k,1);</span><br><span class="line">end</span><br><span class="line">eta = MsigmaB2/sigmaG2;</span><br></pre></td></tr></table></figure><p>或者直接调用MATALB函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">I=imread(&apos;D:\\Images\\pic_loc\\1870405130305041503.jpg&apos;);</span><br><span class="line">a=rgb2gray(I);</span><br><span class="line">level = graythresh(a);</span><br><span class="line">a=im2bw(a,level);</span><br><span class="line">imshow(a,\[\]);</span><br></pre></td></tr></table></figure><p>缺陷:OSTU算法在处理光照不均匀的图像的时候，效果会明显不好，因为利用的是全局像素信息。</p><h2 id="2-灰度平局值法："><a href="#2-灰度平局值法：" class="headerlink" title="2.灰度平局值法："></a>2.<strong>灰度平局值法：</strong></h2><p>　**　1、描述:即使用整幅图像的灰度平均值作为二值化的阈值，一般该方法可作为其他方法的初始猜想值。**</p><p><strong>原理：</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMwLmNuYmxvZ3MuY29tL2Jsb2cvMzQ5MjkzLzIwMTMwOS8wNzEwMTIwOS1jOGU1NWM3NjNlOWE0OTAyODlkOWZlNmQ1OGM3NjdjYi54LXBuZw?x-oss-process=image/format,png" alt></p><p>代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> public static int GetMeanThreshold(int* HistGram)</span><br><span class="line">    &#123;        int Sum = 0, Amount = 0;        for (int Y = 0; Y &lt; 256; Y++)</span><br><span class="line">        &#123;</span><br><span class="line">            Amount += HistGram\[Y\];</span><br><span class="line">            Sum += Y * HistGram\[Y\];</span><br><span class="line">        &#125;        return Sum / Amount;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>缺点：同样受光线影响较大，但是方法简单，处理快</strong></p><h2 id="3-双峰法"><a href="#3-双峰法" class="headerlink" title="3.双峰法"></a><strong>3.双峰法</strong></h2><p>介绍：如果图像灰度直方图呈明显的双峰状，则选取双峰间的最低谷出作为图像分割的阈值所在。，如下图，以<strong>T为阈值</strong>进行二值化分，可以将目标和背景分割开。</p><p>在一些简单的图像中，物体的灰度分布比较有规律，背景与各个目标在图像的直方图各自形成一个波峰，即区域与波峰一一对应，每两个波峰之间形成一个波谷。那么<strong>，选择双峰之间的波谷所代表的灰度值T作为阈值</strong>，即可实现两个区域的分割。如下图所示。</p><p><img src="https://img-blog.csdnimg.cn/20190228101935260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><h3 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a><strong>代码实现：</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">int GetIntermodesThreshold(int* HistGram)</span><br><span class="line">    &#123;        int Y, Iter = 0, Index;        double* HistGramC = new double\[256\];           // 基于精度问题，一定要用浮点数来处理，否则得不到正确的结果</span><br><span class="line">        double* HistGramCC = new double\[256\];          // 求均值的过程会破坏前面的数据，因此需要两份数据</span><br><span class="line">        for (Y = 0; Y &lt; 256; Y++)</span><br><span class="line">        &#123;</span><br><span class="line">            HistGramC\[Y\] = HistGram\[Y\];</span><br><span class="line">            HistGramCC\[Y\] = HistGram\[Y\];</span><br><span class="line">        &#125;        // 通过三点求均值来平滑直方图</span><br><span class="line">        while (IsDimodal(HistGramCC) == false)                                                  // 判断是否已经是双峰的图像了      </span><br><span class="line">        &#123;</span><br><span class="line">            HistGramCC\[0\] = (HistGramC\[0\] + HistGramC\[0\] + HistGramC\[1\]) / 3;                   // 第一点</span><br><span class="line">            for (Y = 1; Y &lt; 255; Y++)</span><br><span class="line">                HistGramCC\[Y\] = (HistGramC\[Y - 1\] + HistGramC\[Y\] + HistGramC\[Y + 1\]) / 3;       // 中间的点</span><br><span class="line">            HistGramCC\[255\] = (HistGramC\[254\] + HistGramC\[255\] + HistGramC\[255\]) / 3;           // 最后一点</span><br><span class="line">            memcpy(HistGramCC, HistGramC, 256 * sizeof(double));         // 备份数据，为下一次迭代做准备</span><br><span class="line">            Iter++;            if (Iter &gt;= 10000) return -1;                                                       // 似乎直方图无法平滑为双峰的，返回错误代码</span><br><span class="line">        &#125;// 阈值为两峰值的平均值</span><br><span class="line">        int* Peak = new int\[2\];        for (Y = 1, Index = 0; Y &lt; 255; Y++)            if (HistGramCC\[Y - 1\] &lt; HistGramCC\[Y\] &amp;&amp; HistGramCC\[Y + 1\] &lt; HistGramCC\[Y\]) Peak\[Index++\] = Y - 1;        return ((Peak\[0\] + Peak\[1\]) / 2);</span><br><span class="line">    &#125;    bool IsDimodal(double* HistGram)       // 检测直方图是否为双峰的</span><br><span class="line">    &#123;        // 对直方图的峰进行计数，只有峰数位2才为双峰 </span><br><span class="line">        int Count = 0;        for (int Y = 1; Y &lt; 255; Y++)</span><br><span class="line">        &#123;            if (HistGram\[Y - 1\] &lt; HistGram\[Y\] &amp;&amp; HistGram\[Y + 1\] &lt; HistGram\[Y\])</span><br><span class="line">            &#123;</span><br><span class="line">                Count++;                if (Count &gt; 2) return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        if (Count == 2)            return true;        else</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a>Python代码：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#coding:utf-8import cv2import numpy as npfrom matplotlib import pyplot as plt</span><br><span class="line"></span><br><span class="line">image = cv2.imread(&quot;E:/python/cv/2ModeMethod/test.jpg&quot;)</span><br><span class="line">gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">plt.subplot(131), plt.imshow(image, &quot;gray&quot;)</span><br><span class="line">plt.title(&quot;source image&quot;), plt.xticks(\[\]), plt.yticks(\[\])</span><br><span class="line">plt.subplot(132), plt.hist(image.ravel(), 256)</span><br><span class="line">plt.title(&quot;Histogram&quot;), plt.xticks(\[\]), plt.yticks(\[\])</span><br><span class="line">ret1, th1 = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY)</span><br><span class="line">plt.subplot(133), plt.imshow(th1, &quot;gray&quot;)</span><br><span class="line">plt.title(&quot;2-Mode Method&quot;), plt.xticks(\[\]), plt.yticks(\[\])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><strong>缺点：当不同区域（即目标）之间的灰度分布有一定的重叠时，双峰法的效果就很差，也就是说，图像为双峰时才能用双峰法</strong></p><p><strong>上述代码已经给出判断双峰图的代码</strong></p><h2 id="4最佳迭代法"><a href="#4最佳迭代法" class="headerlink" title="4最佳迭代法"></a>4最佳迭代法</h2><p>迭代法图像二值化的算法思想是：首先，初始化一个阈值Th，然后按照某种策略通过迭代不断更新这一阈值，直到满足给定的约束条件为止。</p><p>迭代法是基于逼近的思想，迭代阈值的获取步骤可以归纳如下：</p><p>（1）求出图象的最大灰度值和最小灰度值，分别记为gl和gu，令初始阈值为：</p><pre><code>                  ![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMwLmNuYmxvZ3MuY29tL2Jsb2cvMzQ5MjkzLzIwMTMwOS8wNzExMDA1OS01ODQ5YmYzM2IwYjE0NTRkODk0NjkwZGIzODU1YTIwMi54LXBuZw?x-oss-process=image/format,png)(2) 根据阈值T0将图象分割为前景和背景，分别求出两者的平均灰度值Ab和Af:</code></pre><p>　　        　　　　<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMwLmNuYmxvZ3MuY29tL2Jsb2cvMzQ5MjkzLzIwMTMwOS8wNzExMDU0OC1mY2VhM2ViYjgxODU0MTc1YTU0ZjQ5NDdhOWI2YjhjYi54LXBuZw?x-oss-process=image/format,png" alt></p><pre><code>(3) 令                    ![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMwLmNuYmxvZ3MuY29tL2Jsb2cvMzQ5MjkzLzIwMTMwOS8wNzExMDcxMS04MDIwZGIyNDRmMTY0OGUyYTM3MjUyM2FmNDkxYzY5Ny54LXBuZw?x-oss-process=image/format,png)</code></pre><p>如果Tk=Tk+1,则取Tk为所求得的阈值，否则，转2继续迭代</p><h2 id="MATALB代码实现："><a href="#MATALB代码实现：" class="headerlink" title="MATALB代码实现："></a>MATALB代码实现：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; clear all</span><br><span class="line"></span><br><span class="line">%读入图像</span><br><span class="line"></span><br><span class="line">I=imread(&apos;D:\\Administrator\\My Pictures\\Lenagray.bmp&apos;);</span><br><span class="line"></span><br><span class="line">%计算灰度的最小值和最大值</span><br><span class="line"></span><br><span class="line">tmin=min(I(:));</span><br><span class="line"></span><br><span class="line">tmax=max(I(:));</span><br><span class="line"></span><br><span class="line">%设定初始阈值</span><br><span class="line"></span><br><span class="line">th=(tmin+tmax)/2;</span><br><span class="line"></span><br><span class="line">%定义开关变量，用于控制循环次数</span><br><span class="line"></span><br><span class="line">ok=true;</span><br><span class="line"></span><br><span class="line">%迭代法计算阈值while ok</span><br><span class="line"></span><br><span class="line">   g1=I&gt;=th;</span><br><span class="line"></span><br><span class="line">   g2=I&lt;=th;</span><br><span class="line"></span><br><span class="line">   u1=mean(I(g1));</span><br><span class="line"></span><br><span class="line">   u2=mean(I(g2));</span><br><span class="line"></span><br><span class="line">   thnew=(u1+u2)/2;</span><br><span class="line"></span><br><span class="line">   %设定两次阈值的比较，当满足小于1时，停止循环</span><br><span class="line"></span><br><span class="line">   ok=abs(th-thnew)&gt;=1;</span><br><span class="line"></span><br><span class="line">   th=thnew;</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">th=abs(floor(th));</span><br><span class="line"></span><br><span class="line">%阈值分割</span><br><span class="line"></span><br><span class="line">J=im2bw(I,th/255);</span><br><span class="line"></span><br><span class="line">%结果显示</span><br><span class="line"></span><br><span class="line">figure(1);</span><br><span class="line"></span><br><span class="line">imshow(I);title(&apos;原始图像&apos;);</span><br><span class="line"></span><br><span class="line">figure(2);</span><br><span class="line"></span><br><span class="line">str=\[&apos;迭代分割：阈值Th=&apos;,num2str(th)\];</span><br><span class="line"></span><br><span class="line">imshow(J);</span><br><span class="line"></span><br><span class="line">title(str);</span><br></pre></td></tr></table></figure><h2 id="代码实现：-2"><a href="#代码实现：-2" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> public static int GetIterativeBestThreshold(int\[\] HistGram)</span><br><span class="line">    &#123;        int X, Iter = 0;        int MeanValueOne, MeanValueTwo, SumOne, SumTwo, SumIntegralOne, SumIntegralTwo;        int MinValue, MaxValue;        int Threshold, NewThreshold;        for (MinValue = 0; MinValue &lt; 256 &amp;&amp; HistGram\[MinValue\] == 0; MinValue++) ;        for (MaxValue = 255; MaxValue &gt; MinValue &amp;&amp; HistGram\[MinValue\] == 0; MaxValue--) ;        if (MaxValue == MinValue) return MaxValue;          // 图像中只有一个颜色             </span><br><span class="line">        if (MinValue + 1 == MaxValue) return MinValue;      // 图像中只有二个颜色</span><br><span class="line"></span><br><span class="line">        Threshold = MinValue;</span><br><span class="line">        NewThreshold = (MaxValue + MinValue) &gt;&gt; 1;        while (Threshold != NewThreshold)    // 当前后两次迭代的获得阈值相同时，结束迭代    </span><br><span class="line">        &#123;</span><br><span class="line">            SumOne = 0; SumIntegralOne = 0;</span><br><span class="line">            SumTwo = 0; SumIntegralTwo = 0;</span><br><span class="line">            Threshold = NewThreshold;            for (X = MinValue; X &lt;= Threshold; X++)         //根据阈值将图像分割成目标和背景两部分，求出两部分的平均灰度值      </span><br><span class="line">            &#123;</span><br><span class="line">                SumIntegralOne += HistGram\[X\] * X;</span><br><span class="line">                SumOne += HistGram\[X\];</span><br><span class="line">            &#125;</span><br><span class="line">            MeanValueOne = SumIntegralOne / SumOne;            for (X = Threshold + 1; X &lt;= MaxValue; X++)</span><br><span class="line">            &#123;</span><br><span class="line">                SumIntegralTwo += HistGram\[X\] * X;</span><br><span class="line">                SumTwo += HistGram\[X\];</span><br><span class="line">            &#125;</span><br><span class="line">            MeanValueTwo = SumIntegralTwo / SumTwo;</span><br><span class="line">            NewThreshold = (MeanValueOne + MeanValueTwo) &gt;&gt; 1;       //求出新的阈值</span><br><span class="line">            Iter++;            if (Iter &gt;= 1000) return -1;</span><br><span class="line">        &#125;        return Threshold;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="5百分比阈值（P-Tile法）"><a href="#5百分比阈值（P-Tile法）" class="headerlink" title="5百分比阈值（P-Tile法）"></a>5<strong>百分比阈值（P-Tile法）</strong></h2><p><strong>p-tile算法是一种基于灰度直方图统计的的自动阈值选择算法，该算法需要基于一定的先验条件—背景与目标所占的面积比P%。<br>该算法选择阈值的原则是，依次累积灰度直方图，直到该累积值大于或等于前景图像（目标）所占面积，此时的灰度级即为所求的阈值</strong></p><h2 id="代码实现：-3"><a href="#代码实现：-3" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  //HistGram灰度图像的直方图</span><br><span class="line"> //Tile背景在图像中所占的面积百分比</span><br><span class="line">    int GetPTileThreshold(int* HistGram, int Tile)</span><br><span class="line">    &#123;        int Y, Amount = 0, Sum = 0;        for (Y = 0; Y &lt; 256; Y++) Amount += HistGram\[Y\];        //  像素总数</span><br><span class="line">         for (Y = 0; Y &lt; 256; Y++)</span><br><span class="line">        &#123;</span><br><span class="line">            Sum = Sum + HistGram\[Y\];            if (Sum &gt;= Amount * Tile / 100) return Y;</span><br><span class="line">        &#125;        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="缺点：该方法简单高效，但是对于先验概率难于估计的图像却无能为力。。条件很苛刻，大部分情况下都用不上"><a href="#缺点：该方法简单高效，但是对于先验概率难于估计的图像却无能为力。。条件很苛刻，大部分情况下都用不上" class="headerlink" title="缺点：该方法简单高效，但是对于先验概率难于估计的图像却无能为力。。条件很苛刻，大部分情况下都用不上"></a>缺点：该方法简单高效，但是对于先验概率难于估计的图像却无能为力。。条件很苛刻，大部分情况<a href="https://www.baidu.com/s?wd=%E4%B8%8B%E9%83%BD&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">下都</a>用不上</h2><h2 id="6-Niblack二值化算法"><a href="#6-Niblack二值化算法" class="headerlink" title="6.Niblack二值化算法"></a>6.Niblack二值化算法</h2><p>Niblack二值化算法是比较简单的局部阈值方法，阈值的计算公式是T = m + k*v，其中m为以该像素点为中心的区域的平均灰度值，v是该区域的标准差，k是一个修正系数</p><p>它根据以像素点为中心的邻域内的点的情况为此像素计算阈值。下面是每个像素阈值的计算公式，m是均值，s是标准差</p><p><img src="https://img-blog.csdnimg.cn/20190307174824824.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt></p><h3 id="MATALB代码：-1"><a href="#MATALB代码：-1" class="headerlink" title="MATALB代码："></a>MATALB代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function g=segNiBlack(f,w2,k)</span><br><span class="line">% segmentation method using Niblack thresholding method</span><br><span class="line">% input: w2 is the half width of the window</span><br><span class="line"> </span><br><span class="line">w = 2*w2 + 1;</span><br><span class="line">window = ones(w, w);</span><br><span class="line">% compute sum of pixels in WxW window</span><br><span class="line">sp = conv2(f, window, &apos;same&apos;);</span><br><span class="line">% convert to mean</span><br><span class="line">n = w^2;            % number of pixels in window</span><br><span class="line">m = sp / n;</span><br><span class="line">% compute the stdif k ~= 0</span><br><span class="line">    % compute sum of pixels squared in WxW window</span><br><span class="line">    sp2 = conv2(f.^2, window, &apos;same&apos;);</span><br><span class="line">    % convert to std</span><br><span class="line">    var = (n*sp2 - sp.^2) / n / (n-1);</span><br><span class="line">    s = sqrt(var);  </span><br><span class="line">    % compute Niblack threshold</span><br><span class="line">    t = m + k * s;else</span><br><span class="line">    t = m;</span><br><span class="line">end</span><br><span class="line">g=f&lt;t;</span><br><span class="line"> </span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="C代码："><a href="#C代码：" class="headerlink" title="C代码："></a>C代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void NiBlack(BYTE \*image\_in, BYTE \*image\_out, int xsize, int ysize)&#123;/*////////////////////////////////////////////////////////////////////</span><br><span class="line">// 作者：杨魁</span><br><span class="line">//参数列表：</span><br><span class="line">//image_in            输入图像的指针</span><br><span class="line">//image_out        输出图像的指针</span><br><span class="line">//xsize                图像的宽</span><br><span class="line">//ysize                图像的高</span><br><span class="line">////////////////////////////////////////////////////////////////////*/</span><br><span class="line"> int sum = 0;int i, j, h, k;;//用于循环int Average = 0;//平均值int num = 0;//用于自加int w\_size = 7;//窗口大小为2\*w\_size+1int Area = (2 \* w\_size + 1)*(2 * w\_size + 1);int \*d = (int \*)malloc(sizeof(int)*Area);//数组空间int T = 0;//阈值int S = 0;//标准差</span><br><span class="line"> for (j = w\_size; j &lt; ysize - w\_size; j++)</span><br><span class="line">&#123;    for (i = w\_size; i &lt; xsize - w\_size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = 0;</span><br><span class="line">        num = 0;        for (h = 0; h &lt; 2 * w_size + 1; h++)</span><br><span class="line">        &#123;            for (k = 0; k &lt; 2 * w_size + 1; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                d\[num++\] = GetGray(image\_in, xsize, i + w\_size - k, j + w_size - h);        //求area领域内的像素值</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        for (h = 0; h &lt;Area; h++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += d\[h\];//求总和</span><br><span class="line">        &#125;</span><br><span class="line">        Average = sum / Area;</span><br><span class="line">        sum = 0;        for (h = 0; h &lt; Area; h++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += (d\[h\] * d\[h\]);</span><br><span class="line">        &#125;</span><br><span class="line">        S = sqrt((float)sum);</span><br><span class="line">        S = S / Area;</span><br><span class="line">         T = Average + 0.05*S;//确定阈值</span><br><span class="line">        *(image\_out + j \*xsize + i) = \*(image\_in + j *xsize + i) &gt; T ? 255 : 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;free(d);</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;  /// 快速的二维数组元素局部窗口求和程序  /// &lt;/summary&gt;  /// &lt;param name=&quot;array&quot;&gt; 输入二维数组&lt;/param&gt;   /// &lt;param name=&quot;winR&quot;&gt;窗口半径&lt;/param&gt;  /// &lt;returns&gt;输出结果&lt;/returns&gt;  /// &lt;summary&gt;  public static int\[,\] LocalSum_Fast(byte\[,\] array, int winR)  </span><br><span class="line">&#123;  </span><br><span class="line">    int width = array.GetLength(0);  </span><br><span class="line">    int height = array.GetLength(1);  </span><br><span class="line">    int\[,\] temp = new int\[width, height\];//保存中间结果的数组  </span><br><span class="line">    int\[,\] sum = new int\[width, height\];  </span><br><span class="line">  </span><br><span class="line">    //不考虑边界情况，  </span><br><span class="line">    //水平方向：winR行至width-winR行，  </span><br><span class="line">    //垂直方向：winR列至width-winR列  </span><br><span class="line">  </span><br><span class="line">    //对起始行winR在垂直方向求线性和  </span><br><span class="line">    for (int x = winR; x &lt; width - winR; x++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        for (int k = -winR; k &lt;= winR ; k++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            temp\[x, winR\] += array\[x, winR + k\];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    //从winR+1行至末尾行height-winR，依次基于前一行的求和结果进行计算。  </span><br><span class="line">    for (int y = winR + 1; y &lt; height - winR; y++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        for (int x = winR; x &lt; width - winR; x++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            temp\[x, y\] = temp\[x, y - 1\] + array\[x, y + winR\]   </span><br><span class="line">                         - array\[x, y - 1 - winR\];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    //基于保存的垂直方向求和结果，进行水平方向求和  </span><br><span class="line">    //对起始列winR在水平方向求线性和  </span><br><span class="line">    for (int y = winR; y &lt; height - winR; y++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        for (int k = -winR; k &lt;= winR ; k++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            sum\[winR, y\] += temp\[winR + k, y\];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    //从winR+1列至末尾列height-winR，依次基于前一列的求和结果进行计算。  </span><br><span class="line">    for (int x = winR + 1; x &lt; width - winR; x++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        for (int y = winR; y &lt; height - winR; y++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            sum\[x, y\] = sum\[x - 1, y\] + temp\[x + winR, y\]   </span><br><span class="line">                        - temp\[x - winR - 1, y\];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    //运算完成，输出求和结果。  </span><br><span class="line">    return sum;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-bernsen二值化"><a href="#7-bernsen二值化" class="headerlink" title="7.bernsen二值化"></a>7.bernsen二值化</h3><p>bernsen算法的中心思想：</p><p>先人为设定两个值S与TT(Bemsen最初设S为15，TT设为128)，计算以图像中任意像素尸为中心的大小为k×k窗口内的所有像素的最大值M与最小值N，两者的均值T，如果朋M-N大于S，则当前P的阈值为T；若小于S，则表示该窗口所在区域灰度级灰度级差别较小，那么窗口在目标区或在背景区，再判断T与TT的关系，若T&gt;TT则当前点灰度值为255，否则当前点灰度值为0。</p><p>改进的bernsen算法：</p><p>1.消除个别灰度特异点，设采用的阈值为T1。</p><p>T1的取值满足：<br><img src="https://img-blog.csdn.net/20160524174620833" alt="这里写图片描述"></p><p>A为图像的总像素个数</p><p>代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int getThreshBernsen(IplImage *src)</span><br><span class="line">    &#123;</span><br><span class="line">        uchar num\[256\];        int w = src-&gt;width;        int h = src-&gt;height;        int s = src-&gt;widthStep;        int T1 = 0;        int pix = 0;        int a = w * h;        memset(num, 0, 256);        //统计灰度值的个数</span><br><span class="line">        for(int i=0; i&lt;=255; i++)</span><br><span class="line">        &#123;            for(int j=1; j&lt;= h; j++)</span><br><span class="line">            &#123;                for(int m=1; m&lt;= w; m++)</span><br><span class="line">                &#123;                    if(((uchar*)src-&gt;imageData + j*s)\[m\] == i)</span><br><span class="line">                    &#123;</span><br><span class="line">                        num\[i\] = num\[i\] + 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;        for(int i=255; i&gt;=0; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            pix = pix + num\[i\];            if(pix &gt;= (0.1*a))</span><br><span class="line">            &#123;</span><br><span class="line">                T1 = i;                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        cout &lt;&lt; T1 &lt;&lt; endl;        return T1;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id><a href="#" class="headerlink" title=" "></a> </h3><h3 id="二值化的方法有很多，基于每个人来说都会有着适合自己的方法，这里我们只介绍上述几种主流方法，正常使用已经足以，方法不在于多，而在于精，可能你用一种方法就很完美，也可能要不断修改，找到最适合的，图像处理好才是王道。"><a href="#二值化的方法有很多，基于每个人来说都会有着适合自己的方法，这里我们只介绍上述几种主流方法，正常使用已经足以，方法不在于多，而在于精，可能你用一种方法就很完美，也可能要不断修改，找到最适合的，图像处理好才是王道。" class="headerlink" title="二值化的方法有很多，基于每个人来说都会有着适合自己的方法，这里我们只介绍上述几种主流方法，正常使用已经足以，方法不在于多，而在于精，可能你用一种方法就很完美，也可能要不断修改，找到最适合的，图像处理好才是王道。"></a>二值化的方法有很多，基于每个人来说都会有着适合自己的方法，这里我们只介绍上述几种主流方法，正常使用已经足以，方法不在于多，而在于精，可能你用一种方法就很完美，也可能要不断修改，找到最适合的，图像处理好才是王道。</h3><p>参考：</p><p>ttps://<a href="http://www.cnblogs.com/Imageshop/p/3307308.html" target="_blank" rel="noopener">www.cnblogs.com/Imageshop/p/3307308.html</a><br><a href="https://blog.csdn.net/liuzhuomei0911/article/details/51440305" target="_blank" rel="noopener">https://blog.csdn.net/liuzhuomei0911/article/details/51440305</a><br><a href="https://blog.csdn.net/jinzhichaoshuiping/article/details/51480520" target="_blank" rel="noopener">https://blog.csdn.net/jinzhichaoshuiping/article/details/51480520</a><br><a href="https://www.cnblogs.com/naniJser/archive/2012/12/12/2814324.html" target="_blank" rel="noopener">https://www.cnblogs.com/naniJser/archive/2012/12/12/2814324.html</a><br><a href="https://blog.csdn.net/wu\_lian\_nan/article/details/69371720" target="_blank" rel="noopener">https://blog.csdn.net/wu\_lian\_nan/article/details/69371720</a><br><a href="https://blog.csdn.net/zyzhangyue/article/details/45841121" target="_blank" rel="noopener">https://blog.csdn.net/zyzhangyue/article/details/45841121</a></p><p>还有一些参考较少的文献，这里就不罗列了，写这个用到参考文献实在太多，抱歉抱歉</p><p><strong>整理实属不易，点个赞再走呗！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;上一节中我们讲解了什么是二值化，并且讲到了二值化的一般方法，那么每种算法究竟是怎么样对图像经行二值化处理的呢？，算法的原理是什么呢，怎么样用代码实现，这节我们分享下。&quot;&gt;&lt;a href=&quot;#上一节中我们讲解了什么是二值化，并且讲到了二值化的一般方法，那么每种算法究
      
    
    </summary>
    
      <category term="NXP智能车" scheme="http://zxiaoxuan.cn/categories/NXP%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    
      <category term="NXP智能车" scheme="http://zxiaoxuan.cn/tags/NXP%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Python天气预报查询</title>
    <link href="http://zxiaoxuan.cn/posts/29156/"/>
    <id>http://zxiaoxuan.cn/posts/29156/</id>
    <published>2019-09-18T06:24:10.871Z</published>
    <updated>2019-09-18T06:25:53.471Z</updated>
    
    <content type="html"><![CDATA[<p>功能：  <strong>实现城市天气预报查询，并提供未来四天查询</strong></p><p>两个网站接口，直接返回数据，之后对数据进行读取和处理，很简单的小程序</p><p><strong>效果图：</strong><br><img src="https://img-blog.csdnimg.cn/20190918142125533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>代码实现：</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">print(<span class="string">'------天气查询------'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_weather_data</span><span class="params">()</span> :</span></span><br><span class="line">    city_name = input(<span class="string">'请输入要查询的城市名称：'</span>)</span><br><span class="line">    url1 = <span class="string">'http://wthrcdn.etouch.cn/weather_mini?city='</span>+urllib.parse.quote(city_name)</span><br><span class="line">    url2 = <span class="string">'http://wthrcdn.etouch.cn/weather_mini?citykey=101010100'</span></span><br><span class="line">    <span class="comment">#网址1只需要输入城市名，网址2需要输入城市代码</span></span><br><span class="line">    <span class="comment">#print(url1)</span></span><br><span class="line">    weather_data = urllib.request.urlopen(url1).read()</span><br><span class="line">    <span class="comment">#读取网页数据</span></span><br><span class="line">    weather_data = gzip.decompress(weather_data).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="comment">#解压网页数据</span></span><br><span class="line">    weather_dict = json.loads(weather_data)</span><br><span class="line">    <span class="comment">#将json数据转换为dict数据</span></span><br><span class="line">    <span class="keyword">return</span> weather_dict</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_weather</span><span class="params">(weather_data)</span>:</span></span><br><span class="line">    weather_dict = weather_data </span><br><span class="line">    <span class="comment">#将json数据转换为dict数据</span></span><br><span class="line">    <span class="keyword">if</span> weather_dict.get(<span class="string">'desc'</span>) == <span class="string">'invilad-citykey'</span>:</span><br><span class="line">        print(<span class="string">'你输入的城市名有误，或者天气中心未收录你所在城市'</span>)</span><br><span class="line">    <span class="keyword">elif</span> weather_dict.get(<span class="string">'desc'</span>) ==<span class="string">'OK'</span>:</span><br><span class="line">        forecast = weather_dict.get(<span class="string">'data'</span>).get(<span class="string">'forecast'</span>)</span><br><span class="line">        print(<span class="string">'城市：'</span>,weather_dict.get(<span class="string">'data'</span>).get(<span class="string">'city'</span>))</span><br><span class="line">        print(<span class="string">'温度：'</span>,weather_dict.get(<span class="string">'data'</span>).get(<span class="string">'wendu'</span>)+<span class="string">'℃ '</span>)</span><br><span class="line">        print(<span class="string">'感冒：'</span>,weather_dict.get(<span class="string">'data'</span>).get(<span class="string">'ganmao'</span>))</span><br><span class="line">        print(<span class="string">'风向：'</span>,forecast[<span class="number">0</span>].get(<span class="string">'fengxiang'</span>))</span><br><span class="line">        print(<span class="string">'风级：'</span>,forecast[<span class="number">0</span>].get(<span class="string">'fengli'</span>))</span><br><span class="line">        print(<span class="string">'高温：'</span>,forecast[<span class="number">0</span>].get(<span class="string">'high'</span>))</span><br><span class="line">        print(<span class="string">'低温：'</span>,forecast[<span class="number">0</span>].get(<span class="string">'low'</span>))</span><br><span class="line">        print(<span class="string">'天气：'</span>,forecast[<span class="number">0</span>].get(<span class="string">'type'</span>))</span><br><span class="line">        print(<span class="string">'日期：'</span>,forecast[<span class="number">0</span>].get(<span class="string">'date'</span>))</span><br><span class="line">        print(<span class="string">'*******************************'</span>)</span><br><span class="line">        four_day_forecast =input(<span class="string">'是否要显示未来四天天气，是/否：'</span>)</span><br><span class="line">        <span class="keyword">if</span> four_day_forecast == <span class="string">'是'</span> <span class="keyword">or</span> <span class="string">'Y'</span> <span class="keyword">or</span> <span class="string">'y'</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">                print(<span class="string">'日期：'</span>,forecast[i].get(<span class="string">'date'</span>))</span><br><span class="line">                print(<span class="string">'风向：'</span>,forecast[i].get(<span class="string">'fengxiang'</span>))</span><br><span class="line">                print(<span class="string">'风级：'</span>,forecast[i].get(<span class="string">'fengli'</span>))</span><br><span class="line">                print(<span class="string">'高温：'</span>,forecast[i].get(<span class="string">'high'</span>))</span><br><span class="line">                print(<span class="string">'低温：'</span>,forecast[i].get(<span class="string">'low'</span>))</span><br><span class="line">                print(<span class="string">'天气：'</span>,forecast[i].get(<span class="string">'type'</span>))</span><br><span class="line">                print(<span class="string">'--------------------------'</span>)</span><br><span class="line">    print(<span class="string">'***********************************'</span>)</span><br><span class="line"></span><br><span class="line">show_weather(get_weather_data())</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;功能：  &lt;strong&gt;实现城市天气预报查询，并提供未来四天查询&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;两个网站接口，直接返回数据，之后对数据进行读取和处理，很简单的小程序&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;效果图：&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://im
      
    
    </summary>
    
      <category term="Python" scheme="http://zxiaoxuan.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://zxiaoxuan.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>图像处理一之-摄像头二值化处理-(什么是二值化)</title>
    <link href="http://zxiaoxuan.cn/posts/57165/"/>
    <id>http://zxiaoxuan.cn/posts/57165/</id>
    <published>2019-09-18T06:06:43.823Z</published>
    <updated>2019-09-18T12:13:36.977Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图像二值化-binary-image"><a href="#图像二值化-binary-image" class="headerlink" title="图像二值化 binary image"></a>图像二值化 binary image</h1><h3 id="什么是二值化："><a href="#什么是二值化：" class="headerlink" title="什么是二值化："></a>什么是二值化：</h3><p>** 二值化<strong>是<a href="https://baike.baidu.com/item/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2" target="_blank" rel="noopener">图像分割</a>的一种最简单的方法。二值化可以把<a href="https://baike.baidu.com/item/%E7%81%B0%E5%BA%A6%E5%9B%BE%E5%83%8F" target="_blank" rel="noopener">灰度图像</a>转换成<a href="https://baike.baidu.com/item/%E4%BA%8C%E5%80%BC%E5%9B%BE%E5%83%8F" target="_blank" rel="noopener">二值图像</a>。把大于某个</strong>临界灰度值(阈值)**的像素灰度设为灰度极大值(255)，把小于这个值的像素灰度设为灰度极小值（0），从而实现二值化，</p><h3 id="简单来说：设定一个阈值valve，对于视频信号矩阵中的每一行，从左至右比较各像素值和阈值的大小，若图像灰度值大于或等于阈值，则判定该像素对应的255；反之，小于阈值的灰度值则为0。就是将图像上的像素点的灰度值设置为0或255，也就是将整个图像呈现出明显的黑白效果。"><a href="#简单来说：设定一个阈值valve，对于视频信号矩阵中的每一行，从左至右比较各像素值和阈值的大小，若图像灰度值大于或等于阈值，则判定该像素对应的255；反之，小于阈值的灰度值则为0。就是将图像上的像素点的灰度值设置为0或255，也就是将整个图像呈现出明显的黑白效果。" class="headerlink" title="简单来说：设定一个阈值valve，对于视频信号矩阵中的每一行，从左至右比较各像素值和阈值的大小，若图像灰度值大于或等于阈值，则判定该像素对应的255；反之，小于阈值的灰度值则为0。就是将图像上的像素点的灰度值设置为0或255，也就是将整个图像呈现出明显的黑白效果。"></a>简单来说：设定一个阈值valve，对于视频信号矩阵中的每一行，从左至右比较各像素值和阈值的大小，若图像灰度值大于或等于阈值，则判定该像素对应的255；反之，小于阈值的灰度值则为0。就是将图像上的像素点的<a href="https://wenwen.sogou.com/s/?w=%E7%81%B0%E5%BA%A6%E5%80%BC&ch=ww.xqy.chain" target="_blank" rel="noopener">灰度值</a>设置为0或255，也就是将整个图像呈现出明显的黑白效果。</h3><h2 id="二值化的作用："><a href="#二值化的作用：" class="headerlink" title="二值化的作用："></a>二值化的作用：</h2><h3 id="简单通俗的说：二值化的所用就是将图像分成黑和白，更加有利于做图像处理判别。也就是我们说的黑白图像"><a href="#简单通俗的说：二值化的所用就是将图像分成黑和白，更加有利于做图像处理判别。也就是我们说的黑白图像" class="headerlink" title="简单通俗的说：二值化的所用就是将图像分成黑和白，更加有利于做图像处理判别。也就是我们说的黑白图像"></a>简单通俗的说：二值化的所用就是将图像分成黑和白，更加有利于做图像处理判别。也就是我们说的黑白图像</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9nc3MxLmJkc3RhdGljLmNvbS85dm8zZFNhZ194STRraEdrcG9XSzFIRjZoaHkvYmFpa2UvYzAlM0RiYWlrZTkyJTJDNSUyQzUlMkM5MiUyQzMwL3NpZ249MzYzNDRjMDRkMzMzYzg5NWIyNzM5MDI5YjA3YTE4OTUvZDhmOWQ3MmE2MDU5MjUyZGVkM2EyNjk3M2U5YjAzM2I1YmI1Yjk3Ny5qcGc?x-oss-process=image/format,png" alt></p><p>在了解了这些之后，我们看下二值化的方法：</p><p>根据阈值选取的不同，二值化的算法分为<strong>固定阈值</strong>和<strong>自适应阈值(动态阈值)</strong>。 比较常用的二值化方法则有：<strong>双峰法</strong>、<strong>P参数法</strong>、<strong>迭代法</strong>和<strong>OTSU法</strong>等</p><h3 id="固定阈值和自适应阈值："><a href="#固定阈值和自适应阈值：" class="headerlink" title="固定阈值和自适应阈值："></a><strong>固定阈值</strong>和<strong>自适应阈值：</strong></h3><p><strong>这个就很简单理解了，固定阈值就是设置一个固定的阈值，进行二值化处理，而现在大部分二值化算法用的都是自适应阈值(动态阈值)，很容易理解：</strong>固定阈值的二值化呢，，一个阈值往往只对应一类图像，如果图像的光照变暗了，或者其他因素改变了，那个单阈值情况的二值化效果会大大的折扣。自适应二值化其实就是一种根据图片的灰度直方图，得到一个适合本图像的二值化阈值。</p><h3 id="硬件二值化和软件二值化"><a href="#硬件二值化和软件二值化" class="headerlink" title="硬件二值化和软件二值化:"></a>硬件二值化和软件二值化:</h3><p><strong>硬件二值化</strong>的摄像头，是二值化的过程由逻辑芯片直接处理，就是内部自带二值化，它输出的就是二值化后的值了，，所得的图像即为黑白。给单片机节约二值化处理时间，从而不需要进行二值化处理。—-<strong>软件二值化</strong>就是摄像头没有自带二值化，需要自己做二值化处理</p><p>附最简单二值化代码，其他算法之后讲解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Void image_binaryzation()&#123;for(int i=0;i&lt;Row;i++)</span><br><span class="line"></span><br><span class="line">&#123;    for(int j=0;j&lt;Col;j++)</span><br><span class="line"></span><br><span class="line">    &#123;if(Image\[i\]\[j\] &gt;= Threshold)</span><br><span class="line"></span><br><span class="line">       Image_new\[i\]\[j\]=1;else</span><br><span class="line"></span><br><span class="line">    Image_new\[i\]\[j\]=0;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其中-Row是对应采集到的行数，Col是列数，Image-i-j-是摄像头采集未二值化的数据存放的数组，Image-new-i-j-是新建的存放二值化后的数组，Threshold是阈值（前面有阈值的讲解）。"><a href="#其中-Row是对应采集到的行数，Col是列数，Image-i-j-是摄像头采集未二值化的数据存放的数组，Image-new-i-j-是新建的存放二值化后的数组，Threshold是阈值（前面有阈值的讲解）。" class="headerlink" title="其中 Row是对应采集到的行数，Col是列数，Image[i][j]是摄像头采集未二值化的数据存放的数组，Image_new[i][j]是新建的存放二值化后的数组，Threshold是阈值（前面有阈值的讲解）。"></a>其中 Row是对应采集到的行数，Col是列数，Image[i][j]是摄像头采集未二值化的数据存放的数组，Image_new[i][j]是新建的存放二值化后的数组，Threshold是阈值（前面有阈值的讲解）。</h3><p><strong>整理不易，点个赞再走呗！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;图像二值化-binary-image&quot;&gt;&lt;a href=&quot;#图像二值化-binary-image&quot; class=&quot;headerlink&quot; title=&quot;图像二值化 binary image&quot;&gt;&lt;/a&gt;图像二值化 binary image&lt;/h1&gt;&lt;h3 id=&quot;什
      
    
    </summary>
    
      <category term="NXP智能车" scheme="http://zxiaoxuan.cn/categories/NXP%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
    
      <category term="NXP智能车" scheme="http://zxiaoxuan.cn/tags/NXP%E6%99%BA%E8%83%BD%E8%BD%A6/"/>
    
  </entry>
  
</feed>
